---
marp: true
theme: default
paginate: true
header: "FHEVM Bootcamp - Module 09: On-Chain Randomness"
footer: "Zama Developer Program"
---

# Module 09: On-Chain Randomness

Generate truly unpredictable encrypted random numbers.

---

# The Problem with Traditional Randomness

```solidity
// INSECURE: Predictable and manipulable
uint256 random = uint256(keccak256(abi.encodePacked(
    block.timestamp,
    block.prevrandao,
    msg.sender
)));
```

- Validators can manipulate block data
- Front-runners can predict the outcome
- Everyone can compute the "random" value

---

# FHE Solution: Encrypted Randomness

```solidity
euint32 random = FHE.randEuint32();
FHE.allowThis(random);
```

- Random value is **encrypted** -- nobody can see it
- Generated by the FHE co-processor
- Cannot be predicted or front-run
- Only revealed through explicit decryption

---

# Available Random Functions

| Function | Type | Range |
|----------|------|-------|
| `FHE.randEbool()` | `ebool` | true / false |
| `FHE.randEuint8()` | `euint8` | 0 - 255 |
| `FHE.randEuint16()` | `euint16` | 0 - 65,535 |
| `FHE.randEuint32()` | `euint32` | 0 - ~4.3 billion |
| `FHE.randEuint64()` | `euint64` | 0 - 2^64-1 |
| `FHE.randEuint128()` | `euint128` | 0 - 2^128-1 |
| `FHE.randEuint256()` | `euint256` | 0 - 2^256-1 |

---

# Random in Range: 0 to N-1

Use `FHE.rem()` to constrain the range:

```solidity
// Random from 0 to 99
euint32 random = FHE.randEuint32();
euint32 inRange = FHE.rem(random, 100);
FHE.allowThis(inRange);
```

---

# Bounded Random: Power-of-2 Ranges

```solidity
// Efficient: built-in bounded random (power-of-2 only)
euint8 coinFlip = FHE.randEuint8(2);    // 0 or 1
euint8 direction = FHE.randEuint8(4);    // 0, 1, 2, or 3
euint32 card = FHE.randEuint32(64);      // 0 to 63

// General: any range via FHE.rem()
euint8 dice = FHE.rem(FHE.randEuint8(), 6); // 0-5
dice = FHE.add(dice, FHE.asEuint8(1));       // 1-6
```

> upperBound **must** be a power of 2 (2, 4, 8, 16, 32, ...)

---

# Random in Range: Min to Max

```solidity
// Random from 10 to 50
euint32 random = FHE.randEuint32();
euint32 range = FHE.rem(random, 41);        // 0 to 40
euint32 result = FHE.add(range, FHE.asEuint32(10)); // 10 to 50
FHE.allowThis(result);
```

Formula: `FHE.add(FHE.rem(random, max - min + 1), min)`

---

# Example: Dice Roll

```solidity
function rollDice() internal returns (euint8) {
    euint8 random = FHE.randEuint8();
    euint8 roll = FHE.rem(random, 6);       // 0 to 5
    euint8 dice = FHE.add(roll, FHE.asEuint8(1)); // 1 to 6
    FHE.allowThis(dice);
    return dice;
}
```

The result is encrypted -- nobody knows the roll until decryption.

---

# Example: Encrypted Lottery

```solidity
contract EncryptedLottery is ZamaEthereumConfig {
    address[] public players;
    euint32 private _winnerIndex;

    function closeLottery() public onlyOwner {
        euint32 random = FHE.randEuint32();
        _winnerIndex = FHE.rem(random, uint32(players.length));
        FHE.allowThis(_winnerIndex);
        FHE.allow(_winnerIndex, msg.sender);
    }

    function revealWinner() public onlyOwner {
        FHE.makePubliclyDecryptable(_winnerIndex);
        // Winner index can now be decrypted by anyone
    }
}
```

---

# Example: Hidden Card Deal

```solidity
mapping(address => euint8) private _hands;

function dealCard() public {
    euint8 card = FHE.rem(FHE.randEuint8(), 52); // 0-51
    _hands[msg.sender] = card;

    FHE.allowThis(_hands[msg.sender]);
    FHE.allow(_hands[msg.sender], msg.sender);
    // Only the player can see their card (via reencryption)
}
```

Other players cannot see your card!

---

# Example: Random NFT Attributes

```solidity
function mintNFT(uint256 tokenId) public {
    // Each attribute: random 1-100
    euint8 str = FHE.add(
        FHE.rem(FHE.randEuint8(), 100),
        FHE.asEuint8(1)
    );
    euint8 agi = FHE.add(
        FHE.rem(FHE.randEuint8(), 100),
        FHE.asEuint8(1)
    );
    // ... store and grant ACL
}
```

Attributes are hidden until the owner reveals them.

---

# Security Properties

| Property | Explanation |
|----------|-------------|
| **Unpredictable** | Co-processor RNG, not blockchain data |
| **Encrypted** | Result is a ciphertext |
| **Front-run proof** | Attackers cannot read the value |
| **Manipulation proof** | Validators cannot influence output |

---

# Best Practices

1. **Use smallest type** -- `euint8` for dice, not `euint256`
2. **Generate at the right time** -- When the outcome is needed
3. **Always `FHE.allowThis()`** after generation
4. **Use `FHE.rem()` for ranges** -- `FHE.rem(random, N)` for [0, N-1]
5. **Separate calls for independent values** -- Each needs full entropy

---

# Common Mistakes

| Mistake | Fix |
|---------|-----|
| Using `block.prevrandao` | Use `FHE.randEuintXX()` |
| Forgetting `FHE.allowThis()` | Always call after generation |
| Using `euint256` for small ranges | Use smallest suitable type |
| Pre-generating randomness | Generate when needed |

---

# Summary

- `FHE.randEuintXX()` = encrypted random number generation
- Values are **encrypted** and **unpredictable**
- Use `FHE.rem(random, N)` for range [0, N-1]
- Add constant for offset ranges
- Always manage ACL after generation
- Ideal for lotteries, games, NFTs, and any fairness-critical application

---

# Core Concepts Complete!

You now have the foundational skills for FHEVM development:
- Encrypted types and operations
- Access control (ACL)
- Encrypted inputs with ZK proofs
- Decryption patterns
- Conditional logic
- On-chain randomness

Next: Project modules (ERC-20, Voting, Auction, Capstone)
