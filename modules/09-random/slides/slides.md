---
marp: true
theme: default
paginate: true
header: "FHEVM Bootcamp - Module 09: On-Chain Randomness"
footer: "Zama Developer Program"
---

# Module 09: On-Chain Randomness

Generate truly unpredictable encrypted random numbers.

---

# The Problem with Traditional Randomness

```solidity
// INSECURE: Predictable and manipulable
uint256 random = uint256(keccak256(abi.encodePacked(
    block.timestamp,
    block.prevrandao,
    msg.sender
)));
```

- Validators can manipulate block data
- Front-runners can predict the outcome
- Everyone can compute the "random" value

<!--
Speaker notes: Start by showing why traditional on-chain randomness is broken. Validators can manipulate block.timestamp and block.prevrandao, and anyone can precompute the "random" value. This is why on-chain games and lotteries have been exploited repeatedly.
-->

---

# FHE Solution: Encrypted Randomness

```solidity
euint32 random = FHE.randEuint32();
FHE.allowThis(random);
```

- Random value is **encrypted** -- nobody can see it
- Generated by the FHE co-processor
- Cannot be predicted or front-run
- Only revealed through explicit decryption

<!--
Speaker notes: FHE randomness solves the problem completely. The random value is generated by the coprocessor, encrypted immediately, and nobody -- not even the contract deployer or validators -- can see it until it is explicitly decrypted. Compare this to Chainlink VRF, which is public once delivered.
-->

---

# Available Random Functions

| Function | Type | Range |
|----------|------|-------|
| `FHE.randEbool()` | `ebool` | true / false |
| `FHE.randEuint8()` | `euint8` | 0 - 255 |
| `FHE.randEuint16()` | `euint16` | 0 - 65,535 |
| `FHE.randEuint32()` | `euint32` | 0 - ~4.3 billion |
| `FHE.randEuint64()` | `euint64` | 0 - 2^64-1 |
| `FHE.randEuint128()` | `euint128` | 0 - 2^128-1 |
| `FHE.randEuint256()` | `euint256` | 0 - 2^256-1 |

<!--
Speaker notes: One function per type. The output is a full-range random value of that type, encrypted. For most applications, use the smallest type possible -- FHE.randEuint8() for dice and card games, FHE.randEuint32() for lottery indices.
-->

---

# Random in Range: 0 to N-1

Use `FHE.rem()` to constrain the range:

```solidity
// Random from 0 to 99
euint32 random = FHE.randEuint32();
euint32 inRange = FHE.rem(random, 100);
FHE.allowThis(inRange);
```

<!--
Speaker notes: FHE.rem is the key technique for constraining random ranges. Generate a full-range random, then take modulo N to get a value in [0, N-1]. Remember that FHE.rem requires a plaintext divisor, which works perfectly here since the range is a known constant.
-->

---

# Bounded Random: Power-of-2 Ranges

```solidity
// Efficient: built-in bounded random (power-of-2 only)
euint8 coinFlip = FHE.randEuint8(2);    // 0 or 1
euint8 direction = FHE.randEuint8(4);    // 0, 1, 2, or 3
euint32 card = FHE.randEuint32(64);      // 0 to 63

// General: any range via FHE.rem()
euint8 dice = FHE.rem(FHE.randEuint8(), 6); // 0-5
dice = FHE.add(dice, FHE.asEuint8(1));       // 1-6
```

> upperBound **must** be a power of 2 (2, 4, 8, 16, 32, ...)

<!--
Speaker notes: The bounded random variant (with an argument) is more gas-efficient but only works for powers of 2. For arbitrary ranges like 1-6 for dice, use FHE.rem plus FHE.add. Show both approaches so students can choose the right one.
-->

---

# Random in Range: Min to Max

```solidity
// Random from 10 to 50
euint32 random = FHE.randEuint32();
euint32 range = FHE.rem(random, 41);        // 0 to 40
euint32 result = FHE.add(range, FHE.asEuint32(10)); // 10 to 50
FHE.allowThis(result);
```

Formula: `FHE.add(FHE.rem(random, max - min + 1), min)`

<!--
Speaker notes: Have students memorize this formula: rem for range, add for offset. Random from 10 to 50 means a range of 41 values (50-10+1), so rem by 41 gives 0-40, then add 10 to shift to 10-50. This is the universal pattern for any min-max range.
-->

---

# Example: Dice Roll

```solidity
function rollDice() internal returns (euint8) {
    euint8 random = FHE.randEuint8();
    euint8 roll = FHE.rem(random, 6);       // 0 to 5
    euint8 dice = FHE.add(roll, FHE.asEuint8(1)); // 1 to 6
    FHE.allowThis(dice);
    return dice;
}
```

The result is encrypted -- nobody knows the roll until decryption.

<!--
Speaker notes: The dice roll is a great hands-on exercise. Ask students to implement it before showing the answer. Point out the type choice -- euint8 is perfect for 1-6 values and is the cheapest option.
-->

---

# Example: Encrypted Lottery

```solidity
contract EncryptedLottery is ZamaEthereumConfig {
    address[] public players;
    euint32 private _winnerIndex;

    function closeLottery() public onlyOwner {
        euint32 random = FHE.randEuint32();
        _winnerIndex = FHE.rem(random, uint32(players.length));
        FHE.allowThis(_winnerIndex);
        FHE.allow(_winnerIndex, msg.sender);
    }

    function revealWinner() public onlyOwner {
        FHE.makePubliclyDecryptable(_winnerIndex);
        // Winner index can now be decrypted by anyone
    }
}
```

<!--
Speaker notes: The lottery example combines randomness with public decryption. During closeLottery, the winner index is generated but kept encrypted. revealWinner uses makePubliclyDecryptable to announce the result. Point out the separation of concerns: generate and reveal are different functions.
-->

---

# Example: Hidden Card Deal

```solidity
mapping(address => euint8) private _hands;

function dealCard() public {
    euint8 card = FHE.rem(FHE.randEuint8(), 52); // 0-51
    _hands[msg.sender] = card;

    FHE.allowThis(_hands[msg.sender]);
    FHE.allow(_hands[msg.sender], msg.sender);
    // Only the player can see their card (via reencryption)
}
```

Other players cannot see your card!

<!--
Speaker notes: The card dealing example shows per-user randomness with per-user ACL. Each player's card is stored in a mapping and only that player has ACL access. This is the foundation for any card game, poker, or hidden-information game on FHEVM.
-->

---

# Example: Random NFT Attributes

```solidity
function mintNFT(uint256 tokenId) public {
    // Each attribute: random 1-100
    euint8 str = FHE.add(
        FHE.rem(FHE.randEuint8(), 100),
        FHE.asEuint8(1)
    );
    euint8 agi = FHE.add(
        FHE.rem(FHE.randEuint8(), 100),
        FHE.asEuint8(1)
    );
    // ... store and grant ACL
}
```

Attributes are hidden until the owner reveals them.

<!--
Speaker notes: Encrypted NFT attributes are a compelling use case. The owner mints an NFT with hidden stats that they can choose to reveal later. This enables loot-box mechanics, surprise reveals, and fair random attribute generation without any off-chain server.
-->

---

# Security Properties

| Property | Explanation |
|----------|-------------|
| **Unpredictable** | Co-processor RNG, not blockchain data |
| **Encrypted** | Result is a ciphertext |
| **Front-run proof** | Attackers cannot read the value |
| **Manipulation proof** | Validators cannot influence output |

<!--
Speaker notes: Review the four security properties. The key differentiator from other on-chain randomness solutions (like Chainlink VRF) is that FHE randomness is encrypted -- nobody sees the value, not even the oracle. This makes it truly front-run proof.
-->

---

# Best Practices

1. **Use smallest type** -- `euint8` for dice, not `euint256`
2. **Generate at the right time** -- When the outcome is needed
3. **Always `FHE.allowThis()`** after generation
4. **Use `FHE.rem()` for ranges** -- `FHE.rem(random, N)` for [0, N-1]
5. **Separate calls for independent values** -- Each needs full entropy

<!--
Speaker notes: Emphasize best practice 5: do not try to derive multiple random values from one call (like splitting a uint256 into bytes). Each independent random value should use its own FHE.randEuintXX() call for full entropy and security.
-->

---

# Common Mistakes

| Mistake | Fix |
|---------|-----|
| Using `block.prevrandao` | Use `FHE.randEuintXX()` |
| Forgetting `FHE.allowThis()` | Always call after generation |
| Using `euint256` for small ranges | Use smallest suitable type |
| Pre-generating randomness | Generate when needed |

<!--
Speaker notes: Quickly review the common mistakes. The block.prevrandao habit is hard to break for developers coming from standard Solidity. Pre-generating randomness is wasteful because unused random values still cost gas.
-->

---

# Summary

- `FHE.randEuintXX()` = encrypted random number generation
- Values are **encrypted** and **unpredictable**
- Use `FHE.rem(random, N)` for range [0, N-1]
- Add constant for offset ranges
- Always manage ACL after generation
- Ideal for lotteries, games, NFTs, and any fairness-critical application

<!--
Speaker notes: Recap the module: FHE randomness is encrypted, unpredictable, and manipulation-proof. Combined with the ACL system, it enables fair games where even the game operator cannot cheat. This completes the core concept modules.
-->

---

# Core Concepts Complete!

You now have the foundational skills for FHEVM development:
- Encrypted types and operations
- Access control (ACL)
- Encrypted inputs with ZK proofs
- Decryption patterns
- Conditional logic
- On-chain randomness

Next: Project modules (ERC-20, Voting, Auction, Capstone)

<!--
Speaker notes: Celebrate this milestone! Students now have all the core FHEVM concepts. The remaining modules are project-based -- they apply everything learned so far to build real applications. Take a break before diving into Module 10 if time allows.
-->
