// AUTO-GENERATED by scripts/bundle-lessons.js — do not edit manually

export const lessons: Record<string, string> = {
  "00-prerequisites": `# Module 00 - Lesson: Solidity Prerequisites

---

## Table of Contents

1. [Solidity Data Types](#1-solidity-data-types)
2. [Mappings & Structs](#2-mappings--structs)
3. [Events & Emit](#3-events--emit)
4. [Modifiers & Access Control](#4-modifiers--access-control)
5. [msg.sender, require, revert](#5-msgsender-require-revert)
6. [ERC-20 Standard Overview](#6-erc-20-standard-overview)
7. [Hardhat Testing Basics](#7-hardhat-testing-basics)
8. [Summary](#8-summary)

---

## 1. Solidity Data Types

Solidity is a statically-typed language. Every variable must have its type declared at compile time. The most commonly used types fall into two categories: **value types** and **reference types**.

### 1.1 Value Types

Value types are passed by value -- when you assign them to a new variable or pass them to a function, a copy is made.

#### \`uint\` / \`int\`

Unsigned and signed integers. The default size is 256 bits.

\`\`\`solidity
uint256 public totalSupply;    // 0 to 2^256 - 1
int256  public temperature;    // -(2^255) to 2^255 - 1
uint8   public decimals = 18;  // 0 to 255
\`\`\`

> **Tip:** Use \`uint256\` unless you have a specific reason to use a smaller size. The EVM operates on 256-bit words natively.

#### \`address\`

A 20-byte value representing an Ethereum address.

\`\`\`solidity
address public owner;
address payable public treasury;  // can receive ETH via .transfer() / .send()
\`\`\`

#### \`bool\`

A boolean, either \`true\` or \`false\`.

\`\`\`solidity
bool public paused = false;
\`\`\`

### 1.2 Reference Types

Reference types store a reference (pointer) to the data location.

#### \`string\`

UTF-8 encoded text of arbitrary length.

\`\`\`solidity
string public name = "My Token";
\`\`\`

#### \`bytes\`

Dynamically-sized byte array. For fixed sizes use \`bytes1\` through \`bytes32\`.

\`\`\`solidity
bytes32 public merkleRoot;
bytes   public data;
\`\`\`

### 1.3 Type Comparison Table

| Type      | Size      | Default Value | Example                |
|-----------|-----------|---------------|------------------------|
| \`uint256\` | 32 bytes  | \`0\`           | \`uint256 x = 42;\`     |
| \`int256\`  | 32 bytes  | \`0\`           | \`int256 y = -1;\`      |
| \`bool\`    | 1 byte    | \`false\`       | \`bool ok = true;\`     |
| \`address\` | 20 bytes  | \`0x0...0\`     | \`address a = msg.sender;\` |
| \`string\`  | dynamic   | \`""\`          | \`string s = "hello";\` |
| \`bytes\`   | dynamic   | \`""\`          | \`bytes b = hex"cafe";\`|
| \`bytes32\` | 32 bytes  | \`0x0...0\`     | \`bytes32 h = keccak256(...);\` |

---

## 2. Mappings & Structs

### 2.1 Mappings

A mapping is a key-value store. It is the most gas-efficient way to look up data by a key.

\`\`\`solidity
// Syntax: mapping(KeyType => ValueType) visibility name;
mapping(address => uint256) public balances;
\`\`\`

Mappings cannot be iterated, have no length, and all possible keys exist (unmapped keys return the default value for the value type).

#### Nested Mappings

\`\`\`solidity
// ERC-20 allowance pattern
mapping(address => mapping(address => uint256)) public allowance;

function approve(address spender, uint256 amount) external {
    allowance[msg.sender][spender] = amount;
}
\`\`\`

### 2.2 Structs

Structs let you define custom composite types.

\`\`\`solidity
struct Proposal {
    uint256 id;
    string  description;
    uint256 voteCount;
    bool    executed;
}

Proposal[] public proposals;

function createProposal(string calldata _desc) external {
    proposals.push(Proposal({
        id: proposals.length,
        description: _desc,
        voteCount: 0,
        executed: false
    }));
}
\`\`\`

### 2.3 Combining Mappings and Structs

\`\`\`solidity
struct UserProfile {
    string  username;
    uint256 reputation;
    bool    exists;
}

mapping(address => UserProfile) public profiles;

function register(string calldata _username) external {
    require(!profiles[msg.sender].exists, "Already registered");
    profiles[msg.sender] = UserProfile(_username, 0, true);
}
\`\`\`

---

## 3. Events & Emit

Events are the mechanism by which smart contracts communicate with the outside world. When emitted, events write data to the transaction log, which can be read by off-chain applications (frontends, indexers, subgraphs).

### 3.1 Declaring Events

\`\`\`solidity
event Transfer(address indexed from, address indexed to, uint256 value);
event Deposit(address indexed user, uint256 amount);
\`\`\`

The \`indexed\` keyword allows filtering on that parameter when querying logs. You may index up to three parameters per event.

### 3.2 Emitting Events

\`\`\`solidity
function transfer(address to, uint256 amount) external {
    require(balances[msg.sender] >= amount, "Insufficient balance");

    balances[msg.sender] -= amount;
    balances[to] += amount;

    emit Transfer(msg.sender, to, amount);
}
\`\`\`

### 3.3 Why Events Matter

- **Off-chain indexing:** Services like The Graph index events to build queryable APIs.
- **Debugging:** Events appear in transaction receipts and are visible in block explorers.
- **Cost:** Events are much cheaper than storage writes. They cost roughly 375 gas for the topic + 8 gas per byte of data.

---

## 4. Modifiers & Access Control

Modifiers allow you to attach reusable preconditions to functions.

### 4.1 The \`onlyOwner\` Pattern

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract Ownable {
    address public owner;
    uint256 public fee;

    error NotOwner();

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;  // <-- placeholder for the function body
    }

    function setFee(uint256 _fee) external onlyOwner {
        // only the owner can call this
        fee = _fee;
    }
}
\`\`\`

### 4.2 Custom Modifiers

\`\`\`solidity
modifier whenNotPaused() {
    require(!paused, "Contract is paused");
    _;
}

modifier validAddress(address _addr) {
    require(_addr != address(0), "Invalid address");
    _;
}

function transfer(address to, uint256 amount)
    external
    whenNotPaused
    validAddress(to)
{
    // function body runs after both modifiers pass
}
\`\`\`

### 4.3 Modifier Execution Order

When you stack multiple modifiers, they execute left to right. Each \`_\` is replaced by the next modifier (or the function body for the last modifier).

---

## 5. msg.sender, require, revert

### 5.1 \`msg.sender\`

\`msg.sender\` is a global variable that holds the address of the account (or contract) that directly called the current function.

\`\`\`solidity
function whoAmI() external view returns (address) {
    return msg.sender;  // returns the caller's address
}
\`\`\`

### 5.2 \`require\`

\`require\` is used for input validation. If the condition is \`false\`, the transaction reverts and any state changes in the current call are undone.

\`\`\`solidity
function withdraw(uint256 amount) external {
    require(amount > 0, "Amount must be > 0");
    require(balances[msg.sender] >= amount, "Insufficient balance");

    balances[msg.sender] -= amount;
    payable(msg.sender).transfer(amount);
}
\`\`\`

### 5.3 \`revert\` with Custom Errors

Since Solidity 0.8.4, custom errors provide a gas-efficient alternative to \`require\` with string messages.

\`\`\`solidity
error InsufficientBalance(uint256 available, uint256 requested);

function withdraw(uint256 amount) external {
    if (balances[msg.sender] < amount) {
        revert InsufficientBalance(balances[msg.sender], amount);
    }
    // ...
}
\`\`\`

### 5.4 Comparison

| Pattern | Gas Cost | Use When |
|---------|----------|----------|
| \`require(cond, "msg")\` | Higher (stores string) | Quick checks, readability |
| \`if (!cond) revert CustomError()\` | Lower | Production contracts, complex errors |

---

## 6. ERC-20 Standard Overview

ERC-20 is the most widely adopted token standard on Ethereum. It defines a common interface that all fungible tokens implement, enabling interoperability across wallets, DEXs, and DeFi protocols.

### 6.1 Interface

\`\`\`solidity
interface IERC20 {
    // Returns the total supply of tokens
    function totalSupply() external view returns (uint256);

    // Returns the balance of a specific account
    function balanceOf(address account) external view returns (uint256);

    // Transfers tokens from the caller to a recipient
    function transfer(address to, uint256 amount) external returns (bool);

    // Returns the remaining allowance for a spender
    function allowance(address owner, address spender) external view returns (uint256);

    // Approves a spender to transfer up to \`amount\` tokens
    function approve(address spender, uint256 amount) external returns (bool);

    // Transfers tokens from one account to another (requires allowance)
    function transferFrom(address from, address to, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
\`\`\`

### 6.2 Minimal Implementation

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract SimpleToken {
    string  public name     = "SimpleToken";
    string  public symbol   = "STK";
    uint8   public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 _initialSupply) {
        totalSupply = _initialSupply * 10 ** decimals;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(balanceOf[from] >= amount, "Insufficient balance");
        require(allowance[from][msg.sender] >= amount, "Insufficient allowance");

        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }
}
\`\`\`

### 6.3 Key Concepts

- **\`decimals\`:** Most tokens use 18 decimals. USDC uses 6. Always check the decimals of a token before performing arithmetic.
- **Approve/TransferFrom pattern:** Allows contracts (like DEXs) to spend tokens on behalf of the owner. The owner first calls \`approve(spender, amount)\`, then the spender calls \`transferFrom(owner, recipient, amount)\`.
- **Zero-address checks:** Production code should check that \`to != address(0)\` to prevent accidental token burns.

---

## 7. Hardhat Testing Basics

Hardhat is the most popular Solidity development framework. It provides a local EVM environment, compilation, deployment scripting, and a testing framework built on Mocha and Chai.

### 7.1 Project Setup

\`\`\`bash
mkdir my-project && cd my-project
npm init -y
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox
npx hardhat init
\`\`\`

### 7.2 Writing a Test

\`\`\`javascript
// test/SimpleToken.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("SimpleToken", function () {
    let token;
    let owner;
    let addr1;
    let addr2;

    beforeEach(async function () {
        [owner, addr1, addr2] = await ethers.getSigners();

        const SimpleToken = await ethers.getContractFactory("SimpleToken");
        token = await SimpleToken.deploy(1000);
        await token.waitForDeployment();
    });

    describe("Deployment", function () {
        it("should set the correct total supply", async function () {
            const totalSupply = await token.totalSupply();
            expect(totalSupply).to.equal(ethers.parseUnits("1000", 18));
        });

        it("should assign all tokens to the deployer", async function () {
            const ownerBalance = await token.balanceOf(owner.address);
            expect(ownerBalance).to.equal(await token.totalSupply());
        });
    });

    describe("Transfers", function () {
        it("should transfer tokens between accounts", async function () {
            const amount = ethers.parseUnits("100", 18);

            await token.transfer(addr1.address, amount);
            expect(await token.balanceOf(addr1.address)).to.equal(amount);
        });

        it("should revert when sender has insufficient balance", async function () {
            const amount = ethers.parseUnits("1", 18);

            await expect(
                token.connect(addr1).transfer(owner.address, amount)
            ).to.be.revertedWith("Insufficient balance");
        });

        it("should emit a Transfer event", async function () {
            const amount = ethers.parseUnits("50", 18);

            await expect(token.transfer(addr1.address, amount))
                .to.emit(token, "Transfer")
                .withArgs(owner.address, addr1.address, amount);
        });
    });
});
\`\`\`

### 7.3 Running Tests

\`\`\`bash
npx hardhat test                    # run all tests
npx hardhat test --grep "transfer"  # run tests matching pattern
npx hardhat test --verbose          # detailed output
\`\`\`

### 7.4 Common Chai Matchers

| Matcher | Description | Example |
|---------|-------------|---------|
| \`expect(x).to.equal(y)\` | Strict equality | \`expect(balance).to.equal(100n)\` |
| \`.to.be.revertedWith(msg)\` | Expects revert with message | \`expect(tx).to.be.revertedWith("...")\` |
| \`.to.be.revertedWithCustomError\` | Expects custom error | \`expect(tx).to.be.revertedWithCustomError(contract, "Err")\` |
| \`.to.emit(contract, event)\` | Expects event emission | \`expect(tx).to.emit(token, "Transfer")\` |
| \`.to.changeTokenBalance\` | Checks token balance change | \`expect(tx).to.changeTokenBalance(token, addr, 100)\` |

### 7.5 Fixtures (Performance Optimization)

\`\`\`javascript
const { loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");

async function deployFixture() {
    const [owner, addr1] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("SimpleToken");
    const token = await Token.deploy(1000);
    return { token, owner, addr1 };
}

describe("SimpleToken", function () {
    it("test 1", async function () {
        const { token, owner } = await loadFixture(deployFixture);
        // each test gets a fresh snapshot
    });
});
\`\`\`

---

## 8. Summary

In this module you reviewed the essential Solidity building blocks:

- **Data types:** \`uint256\`, \`address\`, \`bool\`, \`string\`, \`bytes\` -- know when to use each.
- **Mappings & structs:** The primary data structures for on-chain storage.
- **Events:** Cheap, indexable logs for off-chain consumption.
- **Modifiers:** Reusable preconditions that keep your functions clean.
- **Validation:** \`require\` and custom \`revert\` errors for robust input checking.
- **ERC-20:** The standard fungible token interface every Solidity developer must know.
- **Hardhat testing:** Write, run, and debug tests locally before deploying.

These fundamentals form the foundation upon which fhEVM builds. In the next module, you will learn what Fully Homomorphic Encryption is and why it matters for blockchain privacy.

---

**Next:** [Module 01 - Introduction to FHE](../01-intro-to-fhe/README.md)
`,
  "01-intro-to-fhe": `# Module 01 - Lesson: Introduction to Fully Homomorphic Encryption

---

## Table of Contents

1. [Encryption Fundamentals](#1-encryption-fundamentals)
2. [What is Homomorphic Encryption?](#2-what-is-homomorphic-encryption)
3. [Types of Homomorphic Encryption](#3-types-of-homomorphic-encryption)
4. [TFHE -- Torus Fully Homomorphic Encryption](#4-tfhe----torus-fully-homomorphic-encryption)
5. [The Privacy Problem on Blockchain](#5-the-privacy-problem-on-blockchain)
6. [Privacy Solutions Compared](#6-privacy-solutions-compared)
7. [What is fhEVM?](#7-what-is-fhevm)
8. [fhEVM Architecture](#8-fhevm-architecture)
9. [Use Cases](#9-use-cases)
10. [Summary](#10-summary)

---

## 1. Encryption Fundamentals

Before diving into homomorphic encryption, let us review the two fundamental categories of encryption.

### 1.1 Symmetric Encryption

In symmetric encryption, the **same key** is used for both encryption and decryption.

\`\`\`
Plaintext  --[Key]--> Ciphertext  --[Key]--> Plaintext
\`\`\`

**Example:** AES (Advanced Encryption Standard)

- Fast and efficient
- Challenge: How do you securely share the key?
- Use case: Encrypting data at rest, disk encryption, TLS session keys

### 1.2 Asymmetric Encryption

In asymmetric encryption, two different keys are used: a **public key** for encryption and a **private key** for decryption.

\`\`\`
Plaintext  --[Public Key]--> Ciphertext  --[Private Key]--> Plaintext
\`\`\`

**Example:** RSA, Elliptic Curve Cryptography (ECC)

- Solves the key distribution problem
- Slower than symmetric encryption
- Use case: HTTPS, digital signatures, blockchain wallets

### 1.3 The Limitation of Traditional Encryption

With traditional encryption, if you want to perform any computation on encrypted data, you must:

1. Decrypt the data first
2. Perform the computation on the plaintext
3. Re-encrypt the result

This means that **whoever performs the computation must have access to the plaintext data**. This is a fundamental problem for privacy in cloud computing, blockchain, and any scenario where computation is delegated to an untrusted party.

---

## 2. What is Homomorphic Encryption?

**Homomorphic Encryption (HE)** is a form of encryption that allows computations to be performed directly on encrypted data, without ever decrypting it. The result of the computation, when decrypted, is identical to the result of performing the same computation on the plaintext.

### 2.1 The Locked Ballot Box Analogy

Imagine a voting scenario:

1. Each voter writes their vote on a slip of paper and places it inside a **locked box** (encryption).
2. The election authority can **shake, weigh, or manipulate** the locked boxes to tally the votes (computation on ciphertext) -- without ever opening them.
3. At the end, a single trusted authority **unlocks the final result** (decryption) and announces the outcome.

At no point did anyone see an individual vote. Yet the final tally is mathematically correct.

### 2.2 Formal Definition

For an encryption scheme \`E\` and a computation \`f\`:

\`\`\`
D(f(E(a), E(b))) = f(a, b)
\`\`\`

In other words: decrypting the result of computing on encrypted values yields the same result as computing on the original plaintext values.

### 2.3 A Simple Illustration

Suppose we have an encryption scheme that supports addition:

\`\`\`
Encrypt(5) = X
Encrypt(3) = Y

X + Y = Z  (computed on ciphertexts, never decrypted)

Decrypt(Z) = 8  (same as 5 + 3)
\`\`\`

The server that computed \`X + Y\` never learned the values 5, 3, or 8.

---

## 3. Types of Homomorphic Encryption

Not all homomorphic encryption schemes are created equal. They differ in which operations they support and how many times those operations can be applied.

### 3.1 Partially Homomorphic Encryption (PHE)

PHE supports **one type of operation** (either addition or multiplication) an **unlimited** number of times.

| Scheme   | Operation      | Year |
|----------|---------------|------|
| RSA      | Multiplication | 1977 |
| Paillier | Addition       | 1999 |
| ElGamal  | Multiplication | 1985 |

**Limitation:** You cannot combine addition and multiplication, which means you cannot evaluate arbitrary functions.

### 3.2 Somewhat Homomorphic Encryption (SHE)

SHE supports **both addition and multiplication**, but only for a **limited number of operations**. Each operation introduces noise into the ciphertext. After too many operations, the noise overwhelms the signal and decryption fails.

Think of it like a photocopy of a photocopy -- each generation degrades quality.

### 3.3 Fully Homomorphic Encryption (FHE)

FHE supports **both addition and multiplication** for an **unlimited number of operations**. It achieves this through a technique called **bootstrapping**, which periodically "refreshes" the ciphertext to reduce noise.

\`\`\`
+-------------------+------------+--------------+------------------+
| Type              | Operations | # Operations | Arbitrary Funcs? |
+-------------------+------------+--------------+------------------+
| PHE               | One        | Unlimited    | No               |
| SHE               | Both       | Limited      | No               |
| FHE               | Both       | Unlimited    | Yes              |
+-------------------+------------+--------------+------------------+
\`\`\`

\`\`\`mermaid
graph LR
    PHE["PHE<br/>One operation<br/>Unlimited times<br/>(RSA 1977, Paillier 1999)"]
    SHE["SHE<br/>Both operations<br/>Limited times<br/>(noise accumulates)"]
    FHE["FHE<br/>Both operations<br/>Unlimited times<br/>(bootstrapping!)"]

    PHE --> SHE --> FHE

    style PHE fill:#ffcdd2
    style SHE fill:#fff9c4
    style FHE fill:#c8e6c9
\`\`\`

### 3.4 Historical Timeline

- **1978:** Rivest, Adleman, and Dertouzos propose the idea of computing on encrypted data.
- **2009:** Craig Gentry publishes the first FHE construction (lattice-based). It was groundbreaking but extremely slow -- a single operation took minutes.
- **2016:** TFHE scheme published by Chillotti, Gama, Georgieva, and Izabachene, enabling fast bootstrapped gate-by-gate evaluation.
- **2023:** Zama releases the fhEVM, bringing FHE to EVM-compatible smart contracts.

---

## 4. TFHE -- Torus Fully Homomorphic Encryption

### 4.1 What is TFHE?

TFHE (Torus Fully Homomorphic Encryption) is a specific FHE scheme that operates over the **torus** -- a mathematical structure that can be visualized as the interval [0, 1) where the endpoints wrap around (like a clock).

### 4.2 Why TFHE?

Among the various FHE schemes (BGV, BFV, CKKS, TFHE), TFHE has several advantages that make it ideal for blockchain:

| Property | TFHE Advantage |
|----------|---------------|
| **Bootstrapping speed** | Very fast bootstrapping (milliseconds per gate), enabling practical computation |
| **Boolean and integer operations** | Natively supports operations on individual bits and small integers |
| **Exact arithmetic** | No approximation errors (unlike CKKS which works with approximate numbers) |
| **Programmable bootstrapping** | Can evaluate a lookup table during bootstrapping itself |

### 4.3 How TFHE Works (High Level)

1. **Encryption:** A plaintext value is encoded as a point on the torus, then noise is added to hide it. The noisy point is the ciphertext.
2. **Computation:** Homomorphic operations (addition, multiplication, comparisons) are performed on the ciphertexts. Each operation increases the noise level.
3. **Bootstrapping:** When noise gets too high, a special procedure "refreshes" the ciphertext, reducing noise back to a manageable level. This is the key innovation that makes FHE practical.
4. **Decryption:** The private key is used to remove the noise and recover the original plaintext result.

### 4.4 Supported Data Types in Zama's TFHE Library

Zama's TFHE library for fhEVM provides encrypted equivalents of common Solidity types:

| Plaintext Type | Encrypted Type | Description |
|---------------|---------------|-------------|
| \`bool\`   | \`ebool\`   | Encrypted boolean |
| \`uint8\`  | \`euint8\`  | Encrypted 8-bit unsigned integer |
| \`uint16\` | \`euint16\` | Encrypted 16-bit unsigned integer |
| \`uint32\` | \`euint32\` | Encrypted 32-bit unsigned integer |
| \`uint64\` | \`euint64\` | Encrypted 64-bit unsigned integer |
| \`uint128\`| \`euint128\`| Encrypted 128-bit unsigned integer |
| \`uint256\`| \`euint256\`| Encrypted 256-bit unsigned integer (limited ops) |
| \`address\`| \`eaddress\`| Encrypted address |

---

## 5. The Privacy Problem on Blockchain

### 5.1 Everything is Public

Public blockchains like Ethereum are radically transparent by design. Every transaction, every state variable, every function call is visible to everyone. While this transparency enables trustlessness and auditability, it creates serious privacy problems.

### 5.2 What is Exposed?

| Data | Visibility | Problem |
|------|-----------|---------|
| **Token balances** | Fully public | Anyone can see how much you own |
| **Transaction history** | Fully public | All transfers are traceable |
| **DeFi positions** | Fully public | Liquidation levels, strategies visible to competitors |
| **Voting choices** | Fully public | No secret ballot possible |
| **Bids in auctions** | Fully public | Front-running and manipulation |
| **Medical/identity data** | Cannot store | Regulation prevents public health data |
| **Smart contract state** | Fully public | Even \`private\` variables are readable from storage |

### 5.3 Real Consequences

**Front-running:** In DeFi, when you submit a large swap transaction, bots can see it in the mempool, place a trade ahead of yours to move the price, and profit at your expense. This is called MEV (Maximal Extractable Value) and costs users billions of dollars per year.

**No secret voting:** On-chain governance votes are visible as they are cast, creating social pressure and enabling vote buying.

**Business confidentiality:** A company cannot use a public blockchain for payroll, supply chain, or competitive bidding without exposing sensitive data to competitors.

### 5.4 The \`private\` Keyword Misconception

A common misconception among new Solidity developers:

\`\`\`solidity
uint256 private secretNumber = 42;
\`\`\`

The \`private\` keyword in Solidity only prevents **other contracts** from reading the variable. Anyone can read it directly from the blockchain's storage slots using tools like \`eth_getStorageAt\`. **There is no data privacy on a public blockchain by default.**

---

## 6. Privacy Solutions Compared

Several cryptographic approaches attempt to solve blockchain privacy. Each has different trade-offs.

### 6.1 Zero-Knowledge Proofs (ZK-Proofs)

**What it does:** Proves that a statement is true without revealing the underlying data.

**Example:** "I can prove I have more than 100 tokens without telling you my exact balance."

**Strengths:**
- Well-researched, production-ready (zkSync, Starknet, Aztec)
- Can provide both privacy and scalability (ZK-Rollups)

**Limitations:**
- Proves properties about data, but does not enable computation on hidden data
- Complex circuit design required for each computation
- Cannot hide state from the smart contract itself -- the contract cannot compute on data it cannot see

### 6.2 Multi-Party Computation (MPC)

**What it does:** Multiple parties jointly compute a function over their inputs without revealing those inputs to each other.

**Example:** Three employees compute their average salary without any individual learning the others' salaries.

**Strengths:**
- No single point of trust
- Mature research area

**Limitations:**
- Requires communication between all parties during computation (high latency)
- Scales poorly with the number of parties
- Not practical for on-chain computation

### 6.3 Trusted Execution Environments (TEE)

**What it does:** Uses special hardware (like Intel SGX or ARM TrustZone) to create an isolated "enclave" where data is processed in plaintext but protected from the host system.

**Example:** A cloud server processes your medical records inside an enclave. Even the server administrator cannot read the data.

**Strengths:**
- Very fast -- data is processed in plaintext inside the enclave
- Relatively simple to implement

**Limitations:**
- Requires trust in the hardware manufacturer
- History of side-channel attacks (Spectre, Meltdown, SGX-specific attacks)
- Single point of failure if the hardware is compromised

### 6.4 Fully Homomorphic Encryption (FHE)

**What it does:** Allows arbitrary computation directly on encrypted data. The data remains encrypted throughout the entire computation.

**Example:** A smart contract can compare two encrypted bids, determine the winner, and update encrypted balances -- all without ever seeing the actual values.

**Strengths:**
- Strongest privacy guarantee: data is never decrypted during computation
- No hardware trust assumptions
- Composable: encrypted outputs can be inputs to further computations

**Limitations:**
- Computationally expensive (10x-1000x overhead compared to plaintext)
- Requires careful key management
- Still maturing in terms of developer tooling

### 6.5 Comparison Table

\`\`\`
+------------------+------------------+------------------+------------------+------------------+
| Property         | ZK-Proofs        | MPC              | TEE              | FHE              |
+------------------+------------------+------------------+------------------+------------------+
| Data hidden      | From verifier    | From each party  | From host        | From everyone    |
| during compute?  |                  |                  |                  |                  |
+------------------+------------------+------------------+------------------+------------------+
| Compute on       | No (proves       | Yes (jointly)    | Yes (in enclave) | Yes (on cipher)  |
| hidden data?     | properties)      |                  |                  |                  |
+------------------+------------------+------------------+------------------+------------------+
| Hardware trust?  | No               | No               | Yes              | No               |
+------------------+------------------+------------------+------------------+------------------+
| Performance      | Fast (verify)    | Medium           | Fast             | Slow             |
|                  | Slow (prove)     |                  |                  |                  |
+------------------+------------------+------------------+------------------+------------------+
| Composability    | Limited          | Limited          | Full             | Full             |
+------------------+------------------+------------------+------------------+------------------+
| On-chain ready?  | Yes (ZK-Rollups) | Partial          | Partial          | Yes (fhEVM)      |
+------------------+------------------+------------------+------------------+------------------+
| Maturity         | High             | Medium           | Medium           | Growing          |
+------------------+------------------+------------------+------------------+------------------+
\`\`\`

### 6.6 Can They Work Together?

These technologies are not mutually exclusive. In fact, fhEVM combines FHE with ZK-Proofs:

- **FHE** handles the confidential computation.
- **ZK-Proofs** are used to verify that inputs are well-formed and that the computation was performed correctly, without revealing the encrypted data.

---

## 7. What is fhEVM?

### 7.0 About Zama

**Zama** is a cryptography company founded in **2020** by **Rand Hindi** (CEO) and **Pascal Paillier** (CTO), headquartered in **Paris, France**. Zama's mission is to make homomorphic encryption accessible to developers across all platforms.

**Key facts:**
- **Founded:** 2020, Paris, France
- **Funding:** Over \$70M raised (Series A led by Multicoin Capital and Protocol Labs, 2024)
- **Team:** 70+ researchers and engineers, including world-leading cryptographers
- **Open source:** All core libraries (TFHE-rs, Concrete, fhEVM) are open-source under BSD license
- **Products:**
  - **TFHE-rs** - Pure Rust implementation of the TFHE scheme (the cryptographic engine)
  - **Concrete** - FHE compiler for Python/ML workloads
  - **fhEVM** - FHE for Ethereum smart contracts (what this bootcamp teaches)
  - **fhEVM Coprocessor** - Off-chain FHE computation engine for blockchain

**Why Zama matters for blockchain:**

Zama is the first company to make FHE practical for smart contracts. Before fhEVM, there was no way for Solidity developers to write confidential on-chain logic without trusting hardware (TEE) or specialized circuits (ZK). Zama's fhEVM runs on **Ethereum Sepolia** (testnet) and **Ethereum Mainnet**, using a coprocessor architecture that keeps the EVM familiar while adding encrypted computation.

\`\`\`mermaid
graph LR
    A[Zama Company] --> B[TFHE-rs<br/>Crypto Engine]
    A --> C[Concrete<br/>FHE Compiler]
    A --> D[fhEVM<br/>Blockchain FHE]
    D --> E[Solidity Library<br/>FHE.sol]
    D --> F[Coprocessor<br/>FHE Operations]
    D --> G[Gateway + KMS<br/>Decryption]
\`\`\`

### 7.1 Definition

**fhEVM** is an open-source framework developed by Zama that brings Fully Homomorphic Encryption to the Ethereum Virtual Machine. It allows Solidity developers to write smart contracts that operate on encrypted data using a familiar syntax.

### 7.2 The Key Insight

Traditional blockchain: \`Smart Contract computes on PLAINTEXT --> Everyone sees everything\`

fhEVM blockchain: \`Smart Contract computes on CIPHERTEXT --> Nobody sees anything (except authorized parties)\`

With fhEVM, you replace standard Solidity types with their encrypted equivalents and use FHE-specific operators. The contract logic remains in Solidity, but the data it processes is encrypted end-to-end.

### 7.3 What Changes for Developers?

| Standard Solidity | fhEVM Solidity |
|-------------------|----------------|
| \`uint256 balance\` | \`euint64 balance\` |
| \`balance >= amount\` | \`FHE.le(amount, balance)\` |
| \`balance -= amount\` | \`balance = FHE.sub(balance, amount)\` |
| \`if (condition) {...}\` | \`FHE.select(condition, valueIfTrue, valueIfFalse)\` |
| Anyone can read \`balance\` | Only authorized addresses can decrypt \`balance\` |

### 7.4 What Does NOT Change?

- You still write Solidity.
- You still deploy to an EVM-compatible chain.
- You still use Hardhat/Foundry for development.
- You still interact with contracts via ethers.js/wagmi.
- Gas is still paid in the native token.

---

## 8. fhEVM Architecture

The fhEVM ecosystem consists of four main components that work together to enable confidential smart contracts.

### 8.1 Architecture Overview

\`\`\`
    +-------------------+
    |   User / dApp     |
    |  (Frontend + SDK) |
    +--------+----------+
             |
             | Encrypted inputs
             v
    +-------------------+        +-------------------+
    |  Smart Contract   |<------>|   Coprocessor     |
    |  Layer (EVM)      |        |   (FHE Engine)    |
    +--------+----------+        +-------------------+
             |
             | Decryption requests
             v
    +-------------------+        +-------------------+
    |     Gateway       |<------>|       KMS         |
    | (Access Control)  |        | (Key Management)  |
    +-------------------+        +-------------------+
\`\`\`

**Mermaid diagram (for GitHub rendering):**

\`\`\`mermaid
flowchart TD
    User["User / dApp<br/>(Relayer SDK)"]
    SC["Smart Contract<br/>(Solidity + FHE.sol)"]
    CP["Coprocessor<br/>(FHE Operations)"]
    GW["Gateway<br/>(Access Control)"]
    KMS["KMS<br/>(Threshold Decryption)"]

    User -->|"Encrypted inputs<br/>(externalEuintXX + proof)"| SC
    SC <-->|"FHE.add(), FHE.select(),<br/>FHE.gt(), etc."| CP
    SC -->|"Decryption request"| GW
    GW <-->|"Threshold decrypt"| KMS
    GW -->|"Plaintext result"| User

    style User fill:#e1f5fe
    style SC fill:#fff3e0
    style CP fill:#f3e5f5
    style GW fill:#e8f5e9
    style KMS fill:#fce4ec
\`\`\`

### 8.2 Smart Contract Layer

This is the familiar EVM execution environment. Smart contracts are written in Solidity using Zama's \`fhevm\` library. They contain encrypted state variables (\`euint64\`, \`ebool\`, etc.) and call FHE operations via the \`FHE\` library.

**Key points:**
- Contracts look like normal Solidity, with encrypted types and FHE operations.
- The EVM itself does not perform the FHE computations -- it delegates them.
- Encrypted values are stored on-chain as ciphertext handles (references to ciphertexts managed by the coprocessor).

### 8.3 Coprocessor

The coprocessor is the computational engine that performs the actual FHE operations. When a smart contract calls \`FHE.add(a, b)\`, the EVM delegates the heavy cryptographic computation to the coprocessor.

**Key points:**
- Performs all FHE operations: addition, subtraction, multiplication, comparison, bitwise operations, shifts, etc.
- Handles bootstrapping to refresh ciphertexts and maintain correctness.
- Runs off-chain but produces results that are verifiable on-chain.
- This is where the computational overhead of FHE is absorbed.

### 8.4 Gateway

The Gateway is the access control layer that mediates decryption requests. When an authorized party wants to decrypt a value, the request goes through the Gateway.

**Key points:**
- Enforces on-chain access control: only addresses explicitly authorized by the contract can request decryption.
- Acts as an intermediary between the blockchain and the KMS.
- Supports both synchronous (callback-based) and asynchronous decryption patterns.
- Prevents unauthorized access to plaintext values.

### 8.5 KMS (Key Management Service)

The KMS is a distributed threshold decryption service that holds the global FHE secret key in a secure, distributed manner.

**Key points:**
- The global FHE key is split across multiple parties using threshold cryptography.
- No single party can decrypt data on their own.
- Decryption requires a threshold number of parties to cooperate.
- The KMS only decrypts values when authorized by the Gateway (which checks on-chain permissions).

### 8.6 Data Flow Example: Encrypted Token Transfer

\`\`\`mermaid
sequenceDiagram
    participant User as User (Frontend)
    participant SDK as Relayer SDK
    participant Contract as Smart Contract
    participant Coprocessor as FHE Coprocessor
    participant Gateway as Gateway
    participant KMS as KMS

    User->>SDK: Enter amount (e.g. 100)
    SDK->>SDK: Encrypt with network public key
    SDK->>Contract: transfer(to, encryptedAmount, proof)
    Contract->>Coprocessor: FHE.le(amount, senderBalance)
    Coprocessor-->>Contract: ebool hasEnough
    Contract->>Coprocessor: FHE.select(hasEnough, ...)
    Coprocessor-->>Contract: Updated encrypted balances
    Contract->>Contract: Store new balances + update ACL
    User->>Contract: balanceOf(myAddress)
    Contract->>Gateway: Request decryption (ACL check)
    Gateway->>KMS: Threshold decrypt
    KMS-->>Gateway: Plaintext balance
    Gateway-->>User: Balance revealed to authorized user only
\`\`\`

Here is what happens when a user transfers encrypted tokens:

1. **User encrypts input:** The user encrypts the transfer amount client-side using the network's public FHE key and submits the transaction.
2. **Contract receives ciphertext:** The contract receives the encrypted amount as an \`externalEuint64\` and converts it to an \`euint64\` via \`FHE.fromExternal()\`.
3. **FHE computation:** The contract calls \`FHE.le(amount, senderBalance)\` to check if the sender has enough balance. The coprocessor performs this comparison on ciphertexts.
4. **Conditional update:** Using \`FHE.select()\`, the contract conditionally updates balances -- all while the actual values remain encrypted.
5. **Result stored:** The new encrypted balances are stored on-chain.
6. **Optional decryption:** If the user wants to see their balance, they request decryption through the Gateway, which checks ACL permissions and coordinates with the KMS.

---

## 9. Use Cases

FHE on blockchain unlocks entirely new categories of applications that were previously impossible due to the transparency of public chains.

### 9.1 Confidential DeFi

| Application | What FHE Enables |
|-------------|-----------------|
| **Private token transfers** | Transfer amounts are hidden; only sender and receiver know the value |
| **Dark pool trading** | Orders are matched without revealing prices or quantities |
| **Private lending** | Collateral ratios and loan amounts are confidential |
| **MEV protection** | Transaction details are encrypted, preventing front-running |
| **Private yield farming** | Strategy positions are hidden from competitors |

### 9.2 Private Voting

On-chain governance currently has a fundamental flaw: votes are public as they are cast, enabling:
- Social pressure and coercion
- Vote buying
- Strategic last-minute voting

With FHE:
- Each vote is encrypted. Nobody can see individual votes during the voting period.
- The smart contract tallies encrypted votes homomorphically.
- Only the final result is decrypted after the voting period ends.
- True secret ballot on-chain.

### 9.3 Sealed-Bid Auctions

In a traditional on-chain auction, all bids are visible. With FHE:
- Bidders submit encrypted bids.
- The contract compares encrypted bids to determine the winner.
- Only the winning bid amount is revealed.
- Losing bids remain confidential.

### 9.4 Confidential Gaming

| Game Type | Privacy Benefit |
|-----------|----------------|
| **Card games** | Players' hands are encrypted; the contract deals and evaluates hands without seeing them |
| **Strategy games** | Fog-of-war: players cannot see opponents' hidden units or resources |
| **Lottery/RNG** | Random numbers can be generated and used without revealing them prematurely |

### 9.5 Identity and Compliance

- **Private KYC:** A contract can verify "this user is over 18" or "this user is not on a sanctions list" without revealing the user's identity.
- **Soulbound tokens:** Credentials and attestations that are verifiable but not publicly readable.
- **Selective disclosure:** Users control exactly which attributes they reveal to which contracts.

### 9.6 Healthcare and Data Markets

- **Medical records:** Encrypted patient data can be processed by smart contracts for insurance, research, or referrals without exposing sensitive information.
- **Data marketplaces:** Buyers can verify data quality (by running computations on encrypted samples) before purchasing, without the seller revealing the data.

---

## 10. Real-World Milestones: FHE in Production

The concepts taught in this bootcamp are not just theoretical -- they are already powering production systems on Ethereum mainnet. This section covers the most significant real-world FHE milestones to date.

### 10.1 The \$ZAMA Token and Encrypted ICO (January 2026)

In January 2026, Zama conducted the **first encrypted ICO on Ethereum** -- a confidential sealed-bid Dutch auction where bid amounts were encrypted using FHE. This was the first production-scale demonstration of FHE on Ethereum mainnet.

**How it worked (technically):**

The auction used a sealed-bid Dutch auction mechanism where:
1. Participants submitted bids with **public price** but **encrypted amounts**
2. The clearing price was calculated **homomorphically, directly on encrypted data**
3. No participant, bot, or organizer could see individual bid amounts
4. After the auction closed, only the aggregate results were decrypted

This is exactly the pattern you will learn in **Module 13 (Sealed-Bid Auctions)** -- but deployed at Ethereum mainnet scale.

**Auction Results (January 21-24, 2026):**

| Metric | Value |
|--------|-------|
| Total Value Shielded | \$121.3M |
| Total Committed | \$118.5M |
| Unique Bidders | 11,103 |
| Total Bids Executed | 24,697 |
| Clearing Price | \$0.05 per ZAMA |
| Oversubscription | 218% (2.8B tokens demanded, 880M available) |
| Refund Ratio | 62.89% |

**Key achievement:** The Zama auction app became the **most-used application on Ethereum on January 24th** -- surpassing USDT, USDC, and Uniswap in transaction volume. It took only 3 days to reach \$100M+ in Total Value Shielded, a milestone that took other privacy protocols years.

### 10.2 The \$ZAMA Token

The \$ZAMA token launched on **February 2, 2026** across major exchanges (Kraken, OKX, KuCoin, with Coinbase support pending).

**Token utility:**
- Pay for **encryption and decryption** operations on the Zama Protocol
- Reward **operators and stakers** for running and securing the network
- All fees are **burned**, while rewards follow a yearly emission schedule

**Contract addresses:**
- Ethereum: \`0xa12cc123ba206d4031d1c7f6223d1c2ec249f4f3\`

**Key resources:**
- Staking: staking.zama.org
- Bridge: bridge.zama.org

### 10.3 First Confidential USDT Transfer on Ethereum

With the mainnet launch, Zama completed the **first confidential USDT (cUSDT) transfer** on Ethereum -- proving that FHE can handle real-world token transfers at production scale. The protocol maintained zero downtime and kept up with Ethereum's throughput, proving FHE is production-ready for financial applications.

### 10.4 Zama Developer Program

The Zama Developer Program launched in **September 2025** and distributes **\$20,000 monthly** across two competitive tracks plus a startup track. As of February 2026, the program has entered **Mainnet Season 1**.

**Program structure:**

| Track | Monthly Prize | Format |
|-------|--------------|--------|
| **Builder Track** | up to \$5,000 | Build complete demo apps (smart contract + frontend + tests + docs) |
| **Bounty Track** | up to \$5,000 | Build Hardhat-based fhEVM example repositories and educational resources |
| **Startup Track** | Rolling | Year of free premium support, VC introductions, 1:1 mentoring with CEO Rand Hindi |

**Bounty Track winners (September 2025):**

| Place | Project | Creator | Prize |
|-------|---------|---------|-------|
| 1st | **Zama School** | MadeleineAguil | \$5,000 |
| 2nd | **Hello FHE Tutorial** | realchriswilder | \$3,000 |
| 3rd | **FHE Guessing Game** | NecipAkgz | \$2,000 |

**Builder Track projects (August 2025 - December 2025):**

| Project | Creator | Season | Category |
|---------|---------|--------|----------|
| **Agora** | ElioMargiotta | Nov 2025 | Confidential governance |
| **AlphaEngine** | Nilay27 | Oct 2025 | Privacy-preserving DeFi (Uniswap V4 hook) |
| **Aruvi** | ramakrishnanhulk20 | Dec 2025 | Privacy payment gateway |
| **CAMM** | 6ygb | Sep 2025 | Confidential AMM (Uniswap V2-based) |
| **EmelMarket** | devEMEL | Aug 2025 | Confidential NFT auction marketplace |
| **FHE GeoGuessr** | kocaemre | Oct 2025 | Privacy-preserving location guessing game |
| **FHERatings** | dordunu1 | Oct 2025 | Private rating platform (only averages public) |
| **FHEZmail** | NarutoLab | Aug 2025 | Decentralized encrypted email |
| **FHElings** | victorsampereira | Nov 2025 | Interactive CLI learning tool for confidential dApps |
| **Fhedback** | erzawansyah | Oct 2025 | Private survey platform with aggregated results |
| **Filez** | Femtech-web | Nov 2025 | End-to-end encrypted file sharing |
| **Legacy Vault** | 00Xchriswilder | Dec 2025 | Self-custody inheritance management |
| **OBOL** | 6ygb | Oct 2025 | Encrypted lending market |
| **OTC With FHE** | tasneemtoolba | Sep 2025 | Confidential OTC marketplace |
| **Orion Finance** | OrionFinanceAI | Aug 2025 | Private portfolio management |
| **PayProof** | mintychan | Oct 2025 | Privacy-preserving payroll streaming |
| **Pendex** | Himess | Dec 2025 | FHE-powered dark pool for pre-IPO leveraged trading |
| **Privacy Pad** | huyminh1115 | — | Private token sale launchpad |
| **Privacy Pool** | tomi204 | Sep 2025 | Privacy AMM with confidential tokens (ERC7984) |
| **Private Uniswap Intents** | tomi204 | Nov 2025 | Uniswap V4 hook for private swaps via encrypted intents |
| **Shadow Voting** | hadieskandari | Nov 2025 | Premium confidential voting dApp |
| **Siphon Protocol** | undefinedlab | Dec 2025 | DeFi privacy layer with FHE + ZK proofs |
| **Uniquity** | Femtech-web | Dec 2025 | Privacy-first identity verification |
| **UpDown60** | huaigu | Dec 2025 | Privacy-preserving BTC prediction game |
| **Zamabelief** | dordunu1 | Sep 2025 | Confidential conviction market |
| **Zentity** | gustavovalverde | Dec 2025 | Privacy-first KYC with FHE attestations |
| **Zolymarket** | Farukest | Oct 2025 | Decentralized prediction market (private bets) |
| **z-payment** | 0xethll | Nov 2025 | Confidential ERC20 token wrapping |

**Bounty Track projects:**

| Project | Creator | Season | Description |
|---------|---------|--------|-------------|
| **FHEVM Example Factory** | NecipAkgz | Dec 2025 | 28+ contract examples with full toolkit |
| **FHE Hub** | tomi204 | Dec 2025 | Comprehensive FHEVM example collection |
| **fhEVM Hub** | gustavovalverde | Dec 2025 | Example library with multiple categories |
| **FHEVM-SDK** | 0xAleksaOpacic | Oct 2025 | TypeScript SDK for confidential dApps |
| **jobjab-fhevm-sdk** | jobjab-dev | Oct 2025 | Framework-agnostic universal FHEVM SDK |

**Other notable projects:**

| Project | Creator | Season | Description |
|---------|---------|--------|-------------|
| **Cibon** | SwineCoder101 | Oct 2025 | Trustless carbon credit verification |
| **FHESplit** | Wagalidoom | Oct 2025 | Private expense splitting |
| **Graze** | nicolas-takimo | Nov 2025 | Encrypted auctions for agricultural assets |
| **RescueDao** | armsves | Nov 2025 | Verified donations with privacy + cross-chain |
| **SecSanta** | batikanor | Oct 2025 | Anonymous gift pooling platform |
| **FHEVesting** | thiagorochatr | Nov 2025 | Cross-chain confidential vesting with ZK proofs |

**Progression pathway:** Builder/Bounty participation → Certified Zama Developer (interview-based, paid contractor access) → Zama Startup Program (VC intros, protocol fee subsidies)

Learn more and apply: [zama.org/developer-hub](https://www.zama.org/developer-hub)

### 10.5 Why This Matters for You

Every concept in this bootcamp maps directly to what was used in production:

| Bootcamp Module | Production Usage |
|-----------------|-----------------|
| Module 03: Encrypted Types | Encrypted bid amounts in the auction |
| Module 05: ACL | Controlling who can see bid data |
| Module 06: Encrypted Inputs | Users submitting encrypted bids |
| Module 08: Conditional Logic | Homomorphic clearing price calculation |
| Module 11: Confidential ERC-20 | Confidential USDT (cUSDT) transfers |
| Module 12: Private Voting | Sealed-bid mechanism (encrypted tallies) |
| Module 13: Sealed-Bid Auction | The entire auction mechanism |

By completing this bootcamp, you will have the skills to build applications like the ones that processed \$121M in encrypted value on Ethereum mainnet.

### 10.6 Zaiffer Protocol and the ERC-7984 Standard

One of the most significant ecosystem developments is **Zaiffer**, a joint venture between Zama and PyratzLabs backed by €2 million (announced November 2025). Zaiffer builds on the fhEVM to convert standard ERC-20 tokens into **confidential ERC-7984 tokens** (cTokens) with fully encrypted balances and transfer amounts.

**ERC-7984** is a new token standard co-developed by Zama and OpenZeppelin that defines a confidential fungible token interface. Where ERC-20 stores balances as plaintext \`uint256\`, ERC-7984 stores them as encrypted \`euint64\` ciphertext handles — exactly the pattern taught in **Module 11** of this bootcamp. The OpenZeppelin security audit was completed in November 2025.

**Zaiffer Products:**
- **ZaifferPay** — Confidential payment tools for individuals and businesses
- **ZaifferSwaps** — MEV-protected token trading (encrypted order amounts prevent front-running)
- **ZaifferYields** — Confidential yield vaults integrated with DeFi protocols

Zaiffer is currently on Ethereum Sepolia testnet with mainnet launch planned.

> **Bootcamp Connection:** Module 11 (Confidential ERC-20) and Module 13 (Sealed-Bid Auction) teach the core patterns that Zaiffer uses in production — encrypted balances, silent-fail transfers, and MEV-resistant encrypted order matching.

### 10.7 Zama 2026 Roadmap

Zama has published an aggressive roadmap for 2026:

| Timeline | Milestone |
|----------|-----------|
| H1 2026 | Confidential DeFi Yield — cUSDT/cUSDC/cETH staking on AAVE, Morpho |
| H1 2026 | Cross-chain expansion to additional EVM chains |
| H2 2026 | Solana support — confidential SVM applications |
| End 2026 | GPU migration — 500-1000 TPS per chain (currently ~20 TPS on CPU) |

The protocol's north star metric is **Total Value Shielded (TVS)** — the total amount of encrypted assets in the system. The \$ZAMA token auction demonstrated \$121.3M TVS within just 3 days, proving market demand for on-chain confidentiality.

> **What this means for bootcamp graduates:** The skills taught here — encrypted types, ACL management, FHE operations, confidential DeFi patterns — will be directly applicable across multiple chains and ecosystems as Zama expands beyond Ethereum.

---

## 11. Summary

### Key Concepts

| Concept | Definition |
|---------|-----------|
| **Homomorphic Encryption** | Encryption that allows computation on ciphertext |
| **PHE** | Supports one operation (add OR multiply), unlimited times |
| **SHE** | Supports both operations, limited number of times |
| **FHE** | Supports both operations, unlimited times (via bootstrapping) |
| **TFHE** | A specific FHE scheme based on torus math, used by Zama |
| **Bootstrapping** | Technique to reduce noise in ciphertexts, enabling unlimited operations |
| **fhEVM** | Zama's framework bringing FHE to the EVM via Solidity |
| **Coprocessor** | Performs the actual FHE computations off-chain |
| **Gateway** | Enforces access control for decryption requests |
| **KMS** | Distributed threshold decryption service |

### The Big Picture

Public blockchains solved the problem of **trust** -- you do not need to trust a central authority. But they created a problem of **privacy** -- everyone can see everything. FHE solves the privacy problem without sacrificing the trustlessness that makes blockchain valuable.

With fhEVM, Solidity developers can build applications that were previously impossible:
- Private DeFi that protects users from MEV
- True secret ballot voting
- Sealed-bid auctions
- Confidential identity verification
- Private gaming with hidden information

And they can do all of this using familiar Solidity syntax, deploying to an EVM-compatible chain.

---

**Next:** [Module 02 - fhEVM Development Setup](../02-development-setup/README.md)
`,
  "02-development-setup": `# Module 02: FHEVM Development Setup — Lesson

## Introduction

Before you can write confidential smart contracts, you need a proper development environment. This module walks you through every step — from installing Node.js and Hardhat to deploying and testing your first FHEVM contract.

---

## 1. Prerequisites & Tooling

### Required Software

| Tool | Version | Purpose |
|------|---------|---------|
| Node.js | >= 20.x | JavaScript runtime |
| npm / pnpm | Latest | Package manager |
| Hardhat | Latest | Smart contract framework |
| Git | Latest | Version control |

### Install Node.js

Download from [nodejs.org](https://nodejs.org) or use a version manager:

\`\`\`bash
# Using nvm (recommended)
nvm install 20
nvm use 20
node --version  # Should print v20.x.x
\`\`\`

---

## 2. Project Initialization

### Create a New Hardhat Project

\`\`\`bash
mkdir my-fhevm-project
cd my-fhevm-project
npm init -y
npm install --save-dev hardhat
npx hardhat init
\`\`\`

Select **"Create a TypeScript project"** when prompted.

### Install FHEVM Dependencies

\`\`\`bash
npm install @fhevm/solidity
npm install --save-dev @nomicfoundation/hardhat-toolbox
npm install --save-dev @fhevm/hardhat-plugin @fhevm/mock-utils
\`\`\`

---

## 3. Hardhat Configuration

Your \`hardhat.config.ts\` needs to be configured for FHEVM development:

\`\`\`typescript
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "@fhevm/hardhat-plugin";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.27",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  networks: {
    localfhevm: {
      url: "http://localhost:8545",
      accounts: {
        mnemonic: "test test test test test test test test test test test junk",
      },
    },
  },
};

export default config;
\`\`\`

---

## 4. Understanding \`ZamaEthereumConfig\`

Every FHEVM contract must inherit from a configuration contract that sets up the FHE environment. Zama provides a ready-made config:

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract MyContract is ZamaEthereumConfig {
    // Your contract code here
}
\`\`\`

**What \`ZamaEthereumConfig\` does:**
- Configures the FHE co-processor address
- Sets up the ACL (Access Control List) contract address
- Initializes the KMS (Key Management Service) verifier
- Provides the decryption oracle address for public decryption operations

> **Important:** You do NOT need to manually configure these addresses. \`ZamaEthereumConfig\` handles everything.

---

## 5. Your First Encrypted Contract

We will build up in two stages: first a simplified version to understand the basics, then the real-world pattern used in production contracts.

### Stage 1: Simplified Version (for learning)

This stripped-down counter initializes from a plaintext value and increments by a hardcoded encrypted \`1\`. It is useful for understanding the core FHE operations in isolation:

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract SimpleCounterBasic is ZamaEthereumConfig {
    euint32 private counter;

    constructor() {
        // Initialize counter to encrypted zero (plaintext -> ciphertext on-chain)
        counter = FHE.asEuint32(0);
        FHE.allowThis(counter);
    }

    function increment() public {
        counter = FHE.add(counter, FHE.asEuint32(1));
        FHE.allowThis(counter);
    }

    function getCounter() public view returns (euint32) {
        return counter;
    }
}
\`\`\`

**Key observations:**

1. **Named imports** -- \`{FHE, euint32}\` and \`{ZamaEthereumConfig}\` instead of bare \`import "..."\`. Named imports are the standard pattern in all FHEVM contracts.
2. **\`euint32\`** -- An encrypted 32-bit unsigned integer type.
3. **\`FHE.asEuint32(0)\`** -- Converts a plaintext value to a ciphertext on-chain.
4. **\`FHE.add()\`** -- Adds two encrypted values homomorphically.
5. **\`FHE.allowThis()\`** -- Grants the contract itself permission to use the ciphertext.

### Stage 2: Production Version (how real contracts work)

In a real contract, users do **not** send plaintext values. Instead, they encrypt input on the client side and pass the ciphertext handle plus a proof to the contract. This is the actual \`HelloFHEVM.sol\` pattern from this bootcamp:

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract HelloFHEVM is ZamaEthereumConfig {
    euint32 private _counter;
    address public owner;

    event CounterIncremented(address indexed by);

    constructor() {
        owner = msg.sender;
    }

    function increment(externalEuint32 encryptedValue, bytes calldata inputProof) external {
        // Convert external ciphertext handle + proof into a usable euint32
        euint32 value = FHE.fromExternal(encryptedValue, inputProof);
        _counter = FHE.add(_counter, value);
        FHE.allowThis(_counter);
        FHE.allow(_counter, msg.sender);
        emit CounterIncremented(msg.sender);
    }

    function getCounter() external view returns (euint32) {
        return _counter;
    }
}
\`\`\`

### What changed from Stage 1 to Stage 2?

| Aspect | Simplified (Stage 1) | Production (Stage 2) |
|--------|----------------------|----------------------|
| **Imports** | \`{FHE, euint32}\` | \`{FHE, euint32, externalEuint32}\` -- adds the external input type |
| **User input** | None -- hardcoded \`FHE.asEuint32(1)\` | \`externalEuint32 encryptedValue, bytes calldata inputProof\` -- user sends encrypted data |
| **Input conversion** | \`FHE.asEuint32()\` from plaintext | \`FHE.fromExternal(encryptedValue, inputProof)\` -- validates and converts client-encrypted input |
| **Access control** | Only \`FHE.allowThis()\` | \`FHE.allowThis()\` **and** \`FHE.allow(_counter, msg.sender)\` -- grants the caller permission to read the ciphertext |
| **Events** | None | \`CounterIncremented\` -- emits an event for off-chain indexing |
| **Visibility** | \`public\` | \`external\` -- more gas-efficient for functions only called externally |

> **Key takeaway:** In production FHEVM contracts, encrypted values always arrive from the client via \`externalEuint32\` + \`inputProof\`. The contract calls \`FHE.fromExternal()\` to validate and unwrap them, then uses \`FHE.allow()\` to grant specific addresses permission to access the result.

---

## 6. Compiling the Contract

\`\`\`bash
npx hardhat compile
\`\`\`

If everything is configured correctly, you should see:

\`\`\`
Compiled 1 Solidity file successfully
\`\`\`

### Common Compilation Errors

| Error | Solution |
|-------|----------|
| \`Source not found: @fhevm/solidity\` | Run \`npm install @fhevm/solidity\` |
| \`ParserError: pragma solidity\` | Ensure Solidity version matches (^0.8.24 or later) |

---

## 7. Writing a Basic Test

Create a test file at \`test/HelloFHEVM.test.ts\`. The \`@fhevm/hardhat-plugin\` provides a \`fhevm\` helper that lets you create encrypted inputs for testing:

\`\`\`typescript
import { expect } from "chai";
import { ethers, fhevm } from "hardhat";
describe("HelloFHEVM", function () {
  it("should deploy successfully", async function () {
    const factory = await ethers.getContractFactory("HelloFHEVM");
    const contract = await factory.deploy();
    await contract.waitForDeployment();
    expect(await contract.getAddress()).to.be.properAddress;
  });

  it("should increment with encrypted value", async function () {
    const [deployer] = await ethers.getSigners();
    const factory = await ethers.getContractFactory("HelloFHEVM");
    const contract = await factory.deploy();
    await contract.waitForDeployment();
    const addr = await contract.getAddress();

    const encrypted = await fhevm
      .createEncryptedInput(addr, deployer.address)
      .add32(5)
      .encrypt();
    await (await contract.increment(encrypted.handles[0], encrypted.inputProof)).wait();
  });
});
\`\`\`

**What is happening in the test:**

1. \`fhevm.createEncryptedInput(contractAddr, signerAddr)\` -- creates an encrypted input builder bound to a specific contract and sender.
2. \`.add32(5)\` -- adds a 32-bit unsigned integer with plaintext value \`5\` to be encrypted.
3. \`.encrypt()\` -- produces \`handles\` (the ciphertext references) and \`inputProof\` (the ZK proof that the ciphertext is valid).
4. \`contract.increment(encrypted.handles[0], encrypted.inputProof)\` -- calls the contract exactly as a real user would.

Run tests:

\`\`\`bash
npx hardhat test
\`\`\`

---

## 8. Project Structure

After setup, your project should look like this:

\`\`\`
my-fhevm-project/
├── contracts/
│   └── HelloFHEVM.sol
├── test/
│   └── HelloFHEVM.test.ts
├── hardhat.config.ts
├── package.json
├── tsconfig.json
└── node_modules/
    └── @fhevm/
        ├── solidity/
        │   ├── lib/
        │   │   └── FHE.sol
        │   └── config/
        │       └── ZamaConfig.sol
        ├── hardhat-plugin/
        └── mock-utils/
\`\`\`

---

## Summary

| Step | Command / Action |
|------|-----------------|
| Initialize project | \`npx hardhat init\` |
| Install FHEVM | \`npm install @fhevm/solidity\` |
| Install dev tools | \`npm install --save-dev @fhevm/hardhat-plugin @fhevm/mock-utils\` |
| Import FHE library | \`import {FHE, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";\` |
| Import config | \`import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";\` |
| Inherit config | \`contract X is ZamaEthereumConfig { }\` |
| Compile | \`npx hardhat compile\` |
| Test | \`npx hardhat test\` |

You now have a fully functional FHEVM development environment. In the next module, we will explore all the encrypted types available to you.
`,
  "03-encrypted-types": `# Module 03: Encrypted Types Deep Dive — Lesson

## Introduction

FHEVM provides a rich set of encrypted data types that mirror familiar Solidity types. Understanding these types — their sizes, capabilities, gas costs, and storage behavior — is fundamental to writing effective confidential smart contracts.

---

## 1. Overview of Encrypted Types

FHEVM offers the following encrypted types:

| Encrypted Type | Plaintext Equivalent | Bit Width | Typical Use Case |
|---------------|---------------------|-----------|-----------------|
| \`ebool\` | \`bool\` | 2 bits | Flags, conditions |
| \`euint8\` | \`uint8\` | 8 bits | Small counters, scores |
| \`euint16\` | \`uint16\` | 16 bits | Moderate ranges |
| \`euint32\` | \`uint32\` | 32 bits | General purpose integers |
| \`euint64\` | \`uint64\` | 64 bits | Balances, timestamps |
| \`euint128\` | \`uint128\` | 128 bits | Large numbers |
| \`euint256\` | \`uint256\` | 256 bits | Hashes, full-range values |
| \`eaddress\` | \`address\` | 160 bits | Encrypted addresses |

---

## 2. Handles: How Encrypted Data Lives On-Chain

### What is a Handle?

When you create an encrypted value, the actual ciphertext is stored in the FHE co-processor. On the EVM side, your contract only holds a **handle** — a \`uint256\` reference that points to the ciphertext.

\`\`\`
┌─────────────────────┐     ┌──────────────────────────┐
│   EVM Storage        │     │   FHE Co-processor       │
│                      │     │                          │
│  euint32 balance ────┼────►│  Ciphertext #0x1a2b...   │
│  (handle: 0x1a2b..)  │     │  (encrypted 32-bit value)│
└─────────────────────┘     └──────────────────────────┘
\`\`\`

### Key Implications

1. **Storage cost** — Storing an encrypted value costs the same as storing a \`uint256\` (one storage slot).
2. **No on-chain inspection** — You cannot read or log the plaintext value from within the contract.
3. **Handle reuse** — The same plaintext encrypted twice will produce different handles (different ciphertexts).
4. **Null handle** — An uninitialized encrypted variable has handle \`0\`, which is invalid for operations.

---

## 3. Boolean Type: \`ebool\`

### Declaration and Initialization

\`\`\`solidity
ebool private _isActive;

constructor() {
    _isActive = FHE.asEbool(true);
    FHE.allowThis(_isActive);
}
\`\`\`

### Use Cases

- Encrypted flags (is a user verified? is an account frozen?)
- Results of encrypted comparisons
- Conditional logic with \`FHE.select()\`

### Creating from Comparisons

\`\`\`solidity
euint32 a = FHE.asEuint32(10);
euint32 b = FHE.asEuint32(20);
ebool isGreater = FHE.gt(a, b);  // encrypted false
\`\`\`

---

## 4. Unsigned Integer Types: \`euint8\` to \`euint256\`

### \`euint8\` — 8-bit Encrypted Integer

\`\`\`solidity
euint8 private _score;

function setScore(uint8 score) public {
    _score = FHE.asEuint8(score);
    FHE.allowThis(_score);
}
\`\`\`

Range: 0 to 255.

### \`euint16\` — 16-bit Encrypted Integer

\`\`\`solidity
euint16 private _itemCount;

function addItem() public {
    _itemCount = FHE.add(_itemCount, FHE.asEuint16(1));
    FHE.allowThis(_itemCount);
}
\`\`\`

Range: 0 to 65,535.

### \`euint32\` — 32-bit Encrypted Integer

The most commonly used type. Good balance between range and gas cost.

\`\`\`solidity
euint32 private _balance;

function deposit(uint32 amount) public {
    _balance = FHE.add(_balance, FHE.asEuint32(amount));
    FHE.allowThis(_balance);
}
\`\`\`

Range: 0 to 4,294,967,295.

### \`euint64\` — 64-bit Encrypted Integer

\`\`\`solidity
euint64 private _totalSupply;

function mint(uint64 amount) public {
    _totalSupply = FHE.add(_totalSupply, FHE.asEuint64(amount));
    FHE.allowThis(_totalSupply);
}
\`\`\`

Range: 0 to 18,446,744,073,709,551,615. Suitable for token balances and timestamps.

### \`euint128\` and \`euint256\`

For very large numbers. Note that larger types consume more gas for operations.

\`\`\`solidity
euint128 private _largeValue;
euint256 private _hash;
\`\`\`

> **Important Limitation:** \`euint256\` does NOT support arithmetic operations (add, sub, mul, min, max) or ordering comparisons (le, lt, ge, gt). It supports:
> - Bitwise: \`FHE.and()\`, \`FHE.or()\`, \`FHE.xor()\`
> - Equality: \`FHE.eq()\`, \`FHE.ne()\`
> - Shift/Rotate: \`FHE.shl()\`, \`FHE.shr()\`, \`FHE.rotl()\`, \`FHE.rotr()\`
> - Conditional: \`FHE.select()\`
>
> Use \`euint128\` or smaller for arithmetic operations.

---

## 5. Encrypted Address: \`eaddress\`

### Declaration and Usage

\`\`\`solidity
eaddress private _secretRecipient;

function setRecipient(address recipient) public {
    _secretRecipient = FHE.asEaddress(recipient);
    FHE.allowThis(_secretRecipient);
}
\`\`\`

### Use Cases

- Hidden recipients in transfer protocols
- Anonymous voting (hiding voter addresses)
- Sealed-bid auctions (hiding bidder identity)

### Comparing Encrypted Addresses

\`\`\`solidity
ebool isSame = FHE.eq(_secretRecipient, FHE.asEaddress(msg.sender));
\`\`\`

---

## 6. Type Conversion Functions

All conversions go through \`FHE.asXXX()\`:

| Function | Input | Output |
|----------|-------|--------|
| \`FHE.asEbool(bool)\` | \`bool\` | \`ebool\` |
| \`FHE.asEuint8(uint8)\` | \`uint8\` | \`euint8\` |
| \`FHE.asEuint16(uint16)\` | \`uint16\` | \`euint16\` |
| \`FHE.asEuint32(uint32)\` | \`uint32\` | \`euint32\` |
| \`FHE.asEuint64(uint64)\` | \`uint64\` | \`euint64\` |
| \`FHE.asEuint128(uint128)\` | \`uint128\` | \`euint128\` |
| \`FHE.asEuint256(uint256)\` | \`uint256\` | \`euint256\` |
| \`FHE.asEaddress(address)\` | \`address\` | \`eaddress\` |

> **Important:** These functions encrypt plaintext values **on-chain**. The plaintext is visible in the transaction calldata. For truly private inputs from users, use \`externalEuintXX\` and \`FHE.fromExternal()\` (covered in Module 06).

### Encrypted-to-Encrypted Casting (Type Conversion)

fhEVM supports casting between encrypted types:

#### Upcasting (safe, no data loss):
\`\`\`solidity
euint8 small = FHE.asEuint8(42);
euint32 bigger = FHE.asEuint32(small);  // 42 as euint32
\`\`\`

#### Downcasting (may truncate):
\`\`\`solidity
euint32 big = FHE.asEuint32(300);
euint8 truncated = FHE.asEuint8(big);  // 300 mod 256 = 44
\`\`\`

> **Warning:** Downcasting silently truncates. There is no overflow check on encrypted values!

#### Bool-Integer conversion:
\`\`\`solidity
ebool flag = FHE.asEbool(true);
euint8 asInt = FHE.asEuint8(flag);     // true -> 1
ebool backToBool = FHE.asEbool(asInt); // non-zero -> true
\`\`\`

#### Supported casting chain:
\`ebool <-> euint8 <-> euint16 <-> euint32 <-> euint64 <-> euint128 <-> euint256\`

---

## 7. Storage Patterns

### Pattern 1: Initialize in Constructor

\`\`\`solidity
euint32 private _value;

constructor() {
    _value = FHE.asEuint32(0);
    FHE.allowThis(_value);
}
\`\`\`

### Pattern 2: Lazy Initialization

\`\`\`solidity
euint32 private _value;
bool private _initialized;

function initialize(uint32 val) public {
    require(!_initialized, "Already initialized");
    _value = FHE.asEuint32(val);
    FHE.allowThis(_value);
    _initialized = true;
}
\`\`\`

### Pattern 3: Mapping with Encrypted Values

\`\`\`solidity
mapping(address => euint32) private _balances;

function setBalance(address user, uint32 amount) internal {
    _balances[user] = FHE.asEuint32(amount);
    FHE.allowThis(_balances[user]);
    FHE.allow(_balances[user], user);
}
\`\`\`

### Pattern 4: Array of Encrypted Values

\`\`\`solidity
euint32[] private _values;

function addValue(uint32 val) public {
    euint32 encrypted = FHE.asEuint32(val);
    FHE.allowThis(encrypted);
    _values.push(encrypted);
}
\`\`\`

---

## 8. ACL Basics: Who Can Use Encrypted Values?

When you create or update an encrypted value, you must explicitly grant access to it:

- **\`FHE.allowThis(handle)\`** — Allows **this contract** to use the value in future transactions
- **\`FHE.allow(handle, address)\`** — Allows a **specific address** to request decryption/reencryption of the value

**Always call both after creating/updating an encrypted value:**

\`\`\`solidity
_secretValue = FHE.asEuint32(42);
FHE.allowThis(_secretValue);          // Contract can use it in later txs
FHE.allow(_secretValue, msg.sender);   // Caller can decrypt/view it
\`\`\`

### Why Two Separate Permissions?

- \`allowThis\` is needed because even the contract that created the ciphertext cannot use it in a *subsequent* transaction without permission
- \`allow\` is needed so users can request reencryption (off-chain viewing) of their data

> **Deep dive:** Module 05 covers the full ACL system in detail, including \`allowTransient\` and multi-party access patterns.

---

## 9. Gas Considerations

Larger types cost more gas for operations:

| Type | Relative Gas Cost |
|------|------------------|
| \`ebool\` | Lowest |
| \`euint8\` | Low |
| \`euint16\` | Low-Medium |
| \`euint32\` | Medium |
| \`euint64\` | Medium-High |
| \`euint128\` | High |
| \`euint256\` | Highest |

**Rule of thumb:** Always use the smallest type that fits your data range.

---

## 10. Common Mistakes

### Mistake 1: Using Uninitialized Encrypted Variables

\`\`\`solidity
euint32 private _value; // Handle is 0 — INVALID!

function bad() public {
    // This will revert — _value has no valid ciphertext
    _value = FHE.add(_value, FHE.asEuint32(1));
}
\`\`\`

**Fix:** Always initialize in the constructor.

### Mistake 2: Forgetting \`FHE.allowThis()\`

\`\`\`solidity
function bad() public {
    _value = FHE.asEuint32(42);
    // Missing FHE.allowThis(_value)!
    // Later operations on _value will fail
}
\`\`\`

### Mistake 3: Exposing Plaintext via \`FHE.asEuintXX()\`

\`\`\`solidity
// The value 42 is visible in transaction calldata!
function setSecret(uint32 val) public {
    _secret = FHE.asEuint32(val);
}
\`\`\`

**Fix:** For user-provided secrets, use encrypted inputs (Module 06).

---

## Summary

- FHEVM provides **8 core encrypted types** covering booleans, integers (8-256 bit), and addresses.
- Encrypted values are stored as **handles** (uint256 references) pointing to ciphertexts in the co-processor.
- Use \`FHE.asXXX()\` to convert plaintext to encrypted (but note the plaintext is visible on-chain).
- Always **initialize** encrypted variables and call \`FHE.allowThis()\` after updates.
- Use **\`FHE.allowThis()\`** for contract access and **\`FHE.allow()\`** for user access -- both are required after every update.
- Choose the **smallest type** that fits your data to minimize gas costs.
`,
  "04-operations": `# Module 04: Operations on Encrypted Data — Lesson

## Introduction

The power of FHE lies in performing computations directly on encrypted data. FHEVM exposes a comprehensive set of operations through the \`FHE\` library. This module covers every operation category: arithmetic, bitwise, and comparison.

---

## 1. Arithmetic Operations

### Addition: \`FHE.add()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(10);
euint32 b = FHE.asEuint32(20);
euint32 sum = FHE.add(a, b); // encrypted 30
\`\`\`

You can also add an encrypted value with a plaintext:

\`\`\`solidity
euint32 result = FHE.add(a, 5); // encrypted 15
\`\`\`

### Subtraction: \`FHE.sub()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(20);
euint32 b = FHE.asEuint32(5);
euint32 diff = FHE.sub(a, b); // encrypted 15
\`\`\`

> **Overflow behavior:** If \`b > a\`, the result wraps around (unsigned underflow). There is no revert. You must handle this in your logic using comparisons.

### Multiplication: \`FHE.mul()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(6);
euint32 b = FHE.asEuint32(7);
euint32 product = FHE.mul(a, b); // encrypted 42
\`\`\`

> **Warning:** Multiplication is the most gas-expensive arithmetic operation. Use sparingly and prefer smaller types.

### Division: \`FHE.div()\`

Division is only supported with a **plaintext** divisor:

\`\`\`solidity
euint32 a = FHE.asEuint32(100);
euint32 result = FHE.div(a, 3); // encrypted 33 (integer division)
\`\`\`

> **Note:** You cannot divide two encrypted values. The divisor must be plaintext. Division by zero returns 0 (no revert in FHE).

### Remainder: \`FHE.rem()\`

Like division, remainder requires a **plaintext** operand:

\`\`\`solidity
euint32 a = FHE.asEuint32(100);
euint32 result = FHE.rem(a, 3); // encrypted 1
\`\`\`

### Negation: \`FHE.neg()\`

Returns the two's complement negation:

\`\`\`solidity
euint32 a = FHE.asEuint32(5);
euint32 negA = FHE.neg(a); // encrypted (2^32 - 5)
\`\`\`

---

## 2. Arithmetic Operations Summary Table

| Operation | Function | Operands | Notes |
|-----------|----------|----------|-------|
| Addition | \`FHE.add(a, b)\` | enc + enc, enc + plain | Wraps on overflow |
| Subtraction | \`FHE.sub(a, b)\` | enc - enc, enc - plain | Wraps on underflow |
| Multiplication | \`FHE.mul(a, b)\` | enc * enc, enc * plain | High gas cost |
| Division | \`FHE.div(a, b)\` | enc / plain only | No enc/enc division |
| Remainder | \`FHE.rem(a, b)\` | enc % plain only | No enc/enc remainder |
| Negation | \`FHE.neg(a)\` | enc | Two's complement |

---

## 3. Bitwise Operations

### AND: \`FHE.and()\`

\`\`\`solidity
euint8 a = FHE.asEuint8(0b11001100);
euint8 b = FHE.asEuint8(0b10101010);
euint8 result = FHE.and(a, b); // encrypted 0b10001000 = 136
\`\`\`

### OR: \`FHE.or()\`

\`\`\`solidity
euint8 result = FHE.or(a, b); // encrypted 0b11101110 = 238
\`\`\`

### XOR: \`FHE.xor()\`

\`\`\`solidity
euint8 result = FHE.xor(a, b); // encrypted 0b01100110 = 102
\`\`\`

### NOT: \`FHE.not()\`

\`\`\`solidity
euint8 a = FHE.asEuint8(0b11001100);
euint8 result = FHE.not(a); // encrypted 0b00110011 = 51
\`\`\`

### Shift and Rotate Operations

Shift and rotate operations are available for \`euint8\` through \`euint128\`. The shift amount is **always** \`euint8\` or \`uint8\`, regardless of the value type being shifted.

\`\`\`solidity
euint32 value = FHE.asEuint32(16);

// Shift left by 2: 16 << 2 = 64
euint32 shifted = FHE.shl(value, FHE.asEuint8(2));
// OR with plaintext shift amount:
euint32 shifted2 = FHE.shl(value, 2);  // uint8 literal

// Shift right by 1: 16 >> 1 = 8
euint32 rightShifted = FHE.shr(value, 1);
\`\`\`

> ⚠️ **Important:** The shift amount (second parameter) must ALWAYS be \`euint8\` or \`uint8\`, regardless of the first operand's type.

> **Shift Modulo:** The shift amount is taken modulo the bit width of the type. For example, \`FHE.shl(euint8_val, 10)\` is equivalent to \`FHE.shl(euint8_val, 2)\` because \`10 mod 8 = 2\`. This applies to \`shl\`, \`shr\`, \`rotl\`, and \`rotr\`.

### Shift Left: \`FHE.shl()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(1);
euint32 result = FHE.shl(a, 3); // 1 << 3 = 8
\`\`\`

### Shift Right: \`FHE.shr()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(16);
euint32 result = FHE.shr(a, 2); // 16 >> 2 = 4
\`\`\`

### Rotate Left: \`FHE.rotl()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(0x80000001);
euint32 result = FHE.rotl(a, 1); // 0x00000003 (circular shift)
\`\`\`

### Rotate Right: \`FHE.rotr()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(1);
euint32 result = FHE.rotr(a, 1); // 0x80000000 (circular shift)
\`\`\`

---

## 4. Bitwise Operations Summary Table

| Operation | Function | Operands |
|-----------|----------|----------|
| AND | \`FHE.and(a, b)\` | enc & enc, enc & plain |
| OR | \`FHE.or(a, b)\` | enc \\| enc, enc \\| plain |
| XOR | \`FHE.xor(a, b)\` | enc ^ enc, enc ^ plain |
| NOT | \`FHE.not(a)\` | ~enc |
| Shift Left | \`FHE.shl(a, b)\` | enc, shift amount: euint8/uint8 |
| Shift Right | \`FHE.shr(a, b)\` | enc, shift amount: euint8/uint8 |
| Rotate Left | \`FHE.rotl(a, b)\` | enc, shift amount: euint8/uint8 |
| Rotate Right | \`FHE.rotr(a, b)\` | enc, shift amount: euint8/uint8 |

---

## 5. Comparison Operations

All comparison operations return an \`ebool\` (encrypted boolean).

### Equal: \`FHE.eq()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(42);
euint32 b = FHE.asEuint32(42);
ebool isEqual = FHE.eq(a, b); // encrypted true
\`\`\`

### Not Equal: \`FHE.ne()\`

\`\`\`solidity
ebool isNotEqual = FHE.ne(a, b); // encrypted false
\`\`\`

### Greater Than: \`FHE.gt()\`

\`\`\`solidity
euint32 a = FHE.asEuint32(10);
euint32 b = FHE.asEuint32(5);
ebool result = FHE.gt(a, b); // encrypted true
\`\`\`

### Greater Than or Equal: \`FHE.ge()\`

\`\`\`solidity
ebool result = FHE.ge(a, b); // encrypted true
\`\`\`

### Less Than: \`FHE.lt()\`

\`\`\`solidity
ebool result = FHE.lt(a, b); // encrypted false
\`\`\`

### Less Than or Equal: \`FHE.le()\`

\`\`\`solidity
ebool result = FHE.le(a, b); // encrypted false
\`\`\`

---

## 6. Comparison Operations Summary Table

| Operation | Function | Returns |
|-----------|----------|---------|
| Equal | \`FHE.eq(a, b)\` | \`ebool\` |
| Not Equal | \`FHE.ne(a, b)\` | \`ebool\` |
| Greater Than | \`FHE.gt(a, b)\` | \`ebool\` |
| Greater or Equal | \`FHE.ge(a, b)\` | \`ebool\` |
| Less Than | \`FHE.lt(a, b)\` | \`ebool\` |
| Less or Equal | \`FHE.le(a, b)\` | \`ebool\` |

All comparisons support encrypted-encrypted and encrypted-plaintext operands.

---

## 7. Min and Max

\`\`\`solidity
euint32 a = FHE.asEuint32(10);
euint32 b = FHE.asEuint32(20);

euint32 smaller = FHE.min(a, b); // encrypted 10
euint32 larger  = FHE.max(a, b); // encrypted 20
\`\`\`

These are extremely useful for clamping values:

\`\`\`solidity
// Clamp to maximum of 100
euint32 clamped = FHE.min(value, FHE.asEuint32(100));

// Clamp to minimum of 10
euint32 atLeast10 = FHE.max(value, FHE.asEuint32(10));
\`\`\`

---

## 8. Cross-Type Operation Support

### Automatic Type Upcasting

fhEVM supports operations between different encrypted types! The result is automatically upcast to the larger type:

\`\`\`solidity
euint8 small = FHE.asEuint8(10);
euint32 big = FHE.asEuint32(1000);

// Cross-type addition: result is euint32
euint32 sum = FHE.add(small, big);  // ✅ Works! Result: 1010 as euint32

// Cross-type comparison: result is ebool
ebool isLess = FHE.lt(small, big);  // ✅ Works!
\`\`\`

> **Rule:** When mixing types, the result type is always the LARGER of the two operand types.
> **Supported combinations:** All pairs of euint8, euint16, euint32, euint64, euint128.

### Encrypted + Plaintext

Many operations accept one encrypted and one plaintext operand:

\`\`\`solidity
euint32 a = FHE.asEuint32(10);

// These are valid:
FHE.add(a, 5);       // euint32 + plaintext
FHE.mul(a, 3);       // euint32 * plaintext
FHE.eq(a, 10);       // euint32 == plaintext
FHE.shl(a, 2);       // euint32 << 2 (shift amount always uint8)
\`\`\`

The plaintext is automatically encrypted to match the encrypted operand's type.

---

## 9. Operation Support by Type

Not all operations are available for all encrypted types:

| Operation | euint8-128 | euint256 | eaddress | ebool |
|-----------|-----------|----------|----------|-------|
| add, sub, mul | ✅ | ❌ | ❌ | ❌ |
| div, rem (scalar) | ✅ | ❌ | ❌ | ❌ |
| min, max | ✅ | ❌ | ❌ | ❌ |
| le, lt, ge, gt | ✅ | ❌ | ❌ | ❌ |
| eq, ne | ✅ | ✅ | ✅ | ✅ |
| and, or, xor | ✅ | ✅ | ❌ | ✅ |
| not, neg | ✅ | ✅ | ❌ | ✅ (not) |
| shl, shr, rotl, rotr | ✅ | ✅ | ❌ | ❌ |
| select | ✅ | ✅ | ✅ | ✅ |

> 💡 \`euint256\` is primarily useful for storing large hashes/IDs with equality checks.
> For arithmetic, use \`euint128\` or smaller.

---

## 10. Overflow and Underflow Behavior

FHEVM uses **wrapping arithmetic** (modular arithmetic):

\`\`\`solidity
euint8 a = FHE.asEuint8(250);
euint8 b = FHE.asEuint8(10);

// 250 + 10 = 260, but euint8 max is 255
// Result wraps: 260 % 256 = 4
euint8 sum = FHE.add(a, b); // encrypted 4

// 5 - 10 = -5, wraps to 256 - 5 = 251
euint8 c = FHE.asEuint8(5);
euint8 diff = FHE.sub(c, b); // encrypted 251
\`\`\`

> **Important:** There are NO overflow reverts in FHE. You must check bounds yourself if needed.

### Safe Subtraction Pattern

\`\`\`solidity
function safeSub(euint32 a, euint32 b) internal returns (euint32) {
    // Only subtract if a >= b, otherwise return 0
    ebool isValid = FHE.ge(a, b);
    euint32 diff = FHE.sub(a, b);
    euint32 zero = FHE.asEuint32(0);
    return FHE.select(isValid, diff, zero);
}
\`\`\`

---

## 11. Practical Example: Encrypted Calculator

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedCalculator is ZamaEthereumConfig {
    euint32 private _result;

    constructor() {
        _result = FHE.asEuint32(0);
        FHE.allowThis(_result);
    }

    function add(uint32 value) public {
        _result = FHE.add(_result, FHE.asEuint32(value));
        FHE.allowThis(_result);
    }

    function subtract(uint32 value) public {
        // Safe subtraction: clamp at 0
        euint32 val = FHE.asEuint32(value);
        ebool canSubtract = FHE.ge(_result, val);
        euint32 diff = FHE.sub(_result, val);
        _result = FHE.select(canSubtract, diff, FHE.asEuint32(0));
        FHE.allowThis(_result);
    }

    function multiply(uint32 value) public {
        _result = FHE.mul(_result, FHE.asEuint32(value));
        FHE.allowThis(_result);
    }

    function clamp(uint32 minVal, uint32 maxVal) public {
        _result = FHE.max(_result, FHE.asEuint32(minVal));
        _result = FHE.min(_result, FHE.asEuint32(maxVal));
        FHE.allowThis(_result);
    }

    function getResult() public view returns (euint32) {
        return _result;
    }
}
\`\`\`

---

## 12. Gas Cost Comparison

Operations ordered by approximate gas cost (lowest to highest):

1. **NOT** — Cheapest (single operand)
2. **AND, OR, XOR** — Bitwise is efficient
3. **ADD, SUB** — Standard arithmetic
4. **SHL, SHR, ROTL, ROTR** — Medium (shift operations)
5. **EQ, NE** — Equality checks
6. **GT, GE, LT, LE** — Ordering comparisons
7. **MIN, MAX** — Comparison + select
8. **MUL** — Most expensive arithmetic
9. **DIV, REM** — Expensive (plaintext divisor only)

---

## Summary

- **Arithmetic:** \`add\`, \`sub\`, \`mul\` (enc+enc), \`div\`, \`rem\` (enc+plain only), \`neg\`
- **Bitwise:** \`and\`, \`or\`, \`xor\`, \`not\`, \`shl\`, \`shr\`, \`rotl\`, \`rotr\` (shift amount always \`euint8\`/\`uint8\`)
- **Comparison:** \`eq\`, \`ne\`, \`gt\`, \`ge\`, \`lt\`, \`le\` — all return \`ebool\`
- **Min/Max:** \`FHE.min()\`, \`FHE.max()\` for clamping
- Cross-type operations are supported — result is automatically upcast to the larger type
- Arithmetic uses **wrapping** (no overflow reverts) — handle bounds manually
- Use \`FHE.select()\` for safe conditional patterns (covered in Module 08)
`,
  "05-access-control": `# Module 05: Access Control (ACL) — Lesson

## Introduction

In a public blockchain, all state is readable by everyone. With FHE, the data is encrypted — but who decides who can **operate** on it or **decrypt** it? The FHEVM Access Control List (ACL) system answers this question.

Every ciphertext has an associated ACL that tracks which addresses (EOAs or contracts) are authorized to use it. Without proper ACL management, even the contract that created the ciphertext cannot use it in subsequent transactions.

---

## 1. Why ACL is Necessary

### The Problem

Consider a token contract that stores encrypted balances:

\`\`\`solidity
mapping(address => euint64) private _balances;
\`\`\`

Without ACL:
- The contract itself could not read its own stored ciphertexts in future transactions
- Users could not request decryption of their own balances
- Other contracts could not interact with the ciphertexts

### The Solution

The ACL system provides **granular, per-ciphertext permissions**. Each time you create or update a ciphertext, you must explicitly grant access to the entities that need it.

---

## 2. \`FHE.allowThis(handle)\` — Self-Permission

The most common ACL call. Grants the **current contract** permission to use a ciphertext.

\`\`\`solidity
euint32 private _value;

constructor() {
    _value = FHE.asEuint32(0);
    FHE.allowThis(_value);  // Contract can use _value later
}

function increment() public {
    _value = FHE.add(_value, FHE.asEuint32(1));
    // _value is a NEW ciphertext — need to re-grant access
    FHE.allowThis(_value);
}
\`\`\`

### Why is This Needed Every Time?

Every FHE operation produces a **new ciphertext** with a **new handle**. The ACL entry for the old handle does not carry over to the new one. You must call \`FHE.allowThis()\` after every assignment to a state variable.

\`\`\`
Operation: _value = FHE.add(_value, FHE.asEuint32(1))

Before: _value -> handle 0xAAA (ACL: [this contract])
After:  _value -> handle 0xBBB (ACL: [empty!])
                                 ↑ Must call FHE.allowThis()
\`\`\`

---

## 3. \`FHE.allow(handle, address)\` — Grant to Specific Address

Grants a specific address (EOA or contract) persistent access to a ciphertext.

\`\`\`solidity
mapping(address => euint64) private _balances;

function _updateBalance(address user, euint64 newBalance) internal {
    _balances[user] = newBalance;
    FHE.allowThis(newBalance);      // Contract can use it
    FHE.allow(newBalance, user);     // User can decrypt it
}
\`\`\`

### Common Pattern: Allow Owner + Contract

\`\`\`solidity
function deposit(uint64 amount) public {
    euint64 newBalance = FHE.add(_balances[msg.sender], FHE.asEuint64(amount));
    _balances[msg.sender] = newBalance;
    FHE.allowThis(newBalance);           // Contract access
    FHE.allow(newBalance, msg.sender);   // User access
}
\`\`\`

### Granting Access to Another Contract

\`\`\`solidity
function shareWith(address otherContract) public {
    FHE.allow(_balances[msg.sender], otherContract);
}
\`\`\`

This enables composability between FHEVM contracts.

---

## 4. \`FHE.allowTransient(handle, address)\` — Temporary Permission

Grants access that lasts only for the **current transaction**. This is useful when:
- A contract needs to pass ciphertexts to another contract within a single transaction
- You want to avoid persisting unnecessary ACL entries (saves gas on storage)

\`\`\`solidity
function processAndForward(address processor) public {
    euint32 result = FHE.add(_value, FHE.asEuint32(1));

    // Only valid during this transaction
    FHE.allowTransient(result, processor);

    // processor contract can use \`result\` in this same tx
    IProcessor(processor).handle(result);
    // After the transaction, processor loses access
}
\`\`\`

### Transient vs Persistent

| Feature | \`FHE.allow()\` | \`FHE.allowTransient()\` |
|---------|---------------|----------------------|
| Duration | Permanent | Transaction only |
| Storage cost | Higher (persistent) | Lower (transient) |
| Use case | User access, long-term | Inter-contract calls |

---

## 5. \`FHE.makePubliclyDecryptable(handle)\` — Public Reveal

Makes an encrypted value decryptable by **any** address. Use this when you want to reveal a result publicly — for example, the outcome of a vote or the winner of an auction.

\`\`\`solidity
// After tallying votes, reveal the result publicly
function revealResult() external onlyOwner {
    FHE.makePubliclyDecryptable(_totalYesVotes);
    FHE.makePubliclyDecryptable(_totalNoVotes);
}
\`\`\`

> ⚠️ **Warning:** Once made publicly decryptable, ANYONE can see the plaintext value. This is irreversible for that handle. Use only for values meant to be public.

**When to use each ACL function:**

| Function | Use Case |
|----------|----------|
| \`FHE.allowThis(handle)\` | Contract needs to use the value in future transactions |
| \`FHE.allow(handle, addr)\` | Grant a specific user access to decrypt |
| \`FHE.allowTransient(handle, addr)\` | Temporary access within the same transaction (inter-contract calls) |
| \`FHE.makePubliclyDecryptable(handle)\` | Reveal result to everyone (vote outcomes, auction winners, etc.) |
| \`FHE.isSenderAllowed(handle)\` | Check if caller has access (for view function guards) |

---

## 6. \`FHE.isSenderAllowed(handle)\` — Permission Check

Returns \`true\` if \`msg.sender\` is authorized to use the given ciphertext.

\`\`\`solidity
function viewMyBalance() public view returns (euint64) {
    require(FHE.isSenderAllowed(_balances[msg.sender]), "Not authorized");
    return _balances[msg.sender];
}
\`\`\`

### Use Cases

- Guard functions that return encrypted handles
- Verify authorization before processing ciphertexts from external callers
- Implement role-based access to encrypted data

---

## 7. ACL Patterns

### Pattern 1: Token Balance ACL

\`\`\`solidity
contract EncryptedToken is ZamaEthereumConfig {
    mapping(address => euint64) private _balances;

    function transfer(address to, uint64 amount) public {
        euint64 amt = FHE.asEuint64(amount);

        // Check sender has enough (encrypted comparison)
        ebool hasEnough = FHE.ge(_balances[msg.sender], amt);

        // Compute new balances
        euint64 newSenderBal = FHE.sub(_balances[msg.sender], amt);
        euint64 newReceiverBal = FHE.add(_balances[to], amt);

        // Conditional update (only if hasEnough)
        _balances[msg.sender] = FHE.select(hasEnough, newSenderBal, _balances[msg.sender]);
        _balances[to] = FHE.select(hasEnough, newReceiverBal, _balances[to]);

        // ACL: contract + sender
        FHE.allowThis(_balances[msg.sender]);
        FHE.allow(_balances[msg.sender], msg.sender);

        // ACL: contract + receiver
        FHE.allowThis(_balances[to]);
        FHE.allow(_balances[to], to);
    }
}
\`\`\`

### Pattern 2: Multi-Contract Composability

\`\`\`solidity
contract Vault is ZamaEthereumConfig {
    euint64 private _totalDeposits;

    function getTotalForAudit(address auditor) public {
        // Give auditor temporary access
        FHE.allowTransient(_totalDeposits, auditor);
    }
}

contract Auditor is ZamaEthereumConfig {
    function audit(Vault vault) public {
        vault.getTotalForAudit(address(this));
        // Now this contract can use the ciphertext within this tx
    }
}
\`\`\`

### Pattern 3: Gated Access with Roles

\`\`\`solidity
contract GatedData is ZamaEthereumConfig {
    euint32 private _secretData;
    mapping(address => bool) public authorized;

    function grantAccess(address user) public onlyOwner {
        authorized[user] = true;
        FHE.allow(_secretData, user);
    }

    function revokeAccess(address user) public onlyOwner {
        authorized[user] = false;
        // Note: ACL revocation requires re-encrypting with a new handle
        // The old handle remains accessible. Best practice: rotate the data.
    }
}
\`\`\`

---

## 8. Important ACL Rules

### Rule 1: New Handle = New ACL

Every FHE operation creates a new ciphertext with a fresh handle. The new handle has an **empty ACL**.

\`\`\`solidity
euint32 a = FHE.asEuint32(10);
FHE.allowThis(a);  // handle_A is allowed

euint32 b = FHE.add(a, FHE.asEuint32(1));
// b has handle_B — NOT in the ACL yet!
FHE.allowThis(b);  // Now handle_B is allowed
\`\`\`

### Rule 2: The Creator Gets No Automatic Access

Even the contract that creates a ciphertext does not automatically have access to it. You must always call \`FHE.allowThis()\`.

### Rule 3: ACL is Per-Handle, Not Per-Variable

\`\`\`solidity
euint32 private _x;

// Transaction 1
_x = FHE.asEuint32(10);  // handle_A
FHE.allowThis(_x);        // ACL[handle_A] = [this]

// Transaction 2
_x = FHE.asEuint32(20);  // handle_B (different handle!)
// ACL[handle_B] is empty — _x is now unusable!
FHE.allowThis(_x);        // Fix: ACL[handle_B] = [this]
\`\`\`

### Rule 4: Revocation is Not Direct

There is no \`FHE.revoke()\`. Once an address has access to a handle, it retains access. To "revoke," you must create a new ciphertext (new handle) and only grant access to the still-authorized parties.

---

## 9. Common Mistakes

### Mistake 1: Forgetting \`FHE.allowThis()\` After Update

\`\`\`solidity
function update() public {
    _value = FHE.add(_value, FHE.asEuint32(1));
    // MISSING: FHE.allowThis(_value);
    // Next transaction using _value WILL FAIL
}
\`\`\`

### Mistake 2: Not Granting User Access

\`\`\`solidity
function setBalance(address user, uint64 amount) public {
    _balances[user] = FHE.asEuint64(amount);
    FHE.allowThis(_balances[user]);
    // MISSING: FHE.allow(_balances[user], user);
    // User cannot decrypt their own balance!
}
\`\`\`

### Mistake 3: Using \`allow\` Instead of \`allowTransient\` for Temporary Needs

\`\`\`solidity
// Wasteful — persists unnecessary ACL entry
FHE.allow(tempResult, helperContract);

// Better — access expires after transaction
FHE.allowTransient(tempResult, helperContract);
\`\`\`

---

## Summary

| Function | Purpose | Duration |
|----------|---------|----------|
| \`FHE.allowThis(handle)\` | Grant current contract access | Persistent |
| \`FHE.allow(handle, addr)\` | Grant specific address access | Persistent |
| \`FHE.allowTransient(handle, addr)\` | Grant temporary access | Transaction only |
| \`FHE.makePubliclyDecryptable(handle)\` | Reveal to everyone | Persistent (irreversible) |
| \`FHE.isSenderAllowed(handle)\` | Check if msg.sender has access | N/A (view) |

**Key rules (5 ACL functions):**
1. Every new ciphertext has an empty ACL
2. Always \`FHE.allowThis()\` after every state update
3. Use \`FHE.allow()\` for users who need to decrypt
4. Use \`FHE.allowTransient()\` for inter-contract calls within one transaction
5. Use \`FHE.makePubliclyDecryptable()\` to reveal values to everyone (irreversible)
6. No direct revocation — rotate data instead
`,
  "06-encrypted-inputs": `# Module 06: Encrypted Inputs & ZK Proofs — Lesson

## Introduction

In previous modules, we used \`FHE.asEuint32(plaintext)\` to create encrypted values. While this encrypts the value on-chain, the **plaintext is visible in the transaction calldata**. Anyone monitoring the mempool or reading the blockchain can see the original value.

For truly private inputs, FHEVM provides a mechanism where users **encrypt their data client-side** before submitting it to the blockchain. The contract receives the pre-encrypted data as \`externalEuintXX\` types and converts them using \`FHE.fromExternal(input, proof)\`.

---

## 1. The Privacy Problem with On-Chain Encryption

### What Happens with \`FHE.asEuint32()\`

\`\`\`solidity
// The user calls: contract.setBid(1000)
function setBid(uint32 amount) public {
    _bid = FHE.asEuint32(amount);  // Encrypted on-chain
}
\`\`\`

The transaction calldata contains:
\`\`\`
Function selector: 0x12345678
Argument:         0x00000000000000000000000000000000000000000000000000000000000003e8
                  ↑ This is plaintext 1000 — visible to everyone!
\`\`\`

### The Solution: Client-Side Encryption

\`\`\`
┌──────────────┐    encrypted blob     ┌──────────────────┐
│   User's     │ ─────────────────────►│   Smart Contract  │
│   Browser    │    (+ ZK proof)       │                   │
│              │                       │   externalEuint32 │
│  plaintext   │                       │   FHE.fromExternal│
│  → encrypt() │                       │   → euint32       │
└──────────────┘                       └──────────────────┘
\`\`\`

The plaintext **never appears** on-chain.

---

## 2. External Encrypted Types

FHEVM provides special types for receiving client-encrypted data:

| External Type | On-Chain Type | Description |
|--------------|---------------|-------------|
| \`externalEbool\` | \`ebool\` | Encrypted boolean input |
| \`externalEuint8\` | \`euint8\` | Encrypted 8-bit input |
| \`externalEuint16\` | \`euint16\` | Encrypted 16-bit input |
| \`externalEuint32\` | \`euint32\` | Encrypted 32-bit input |
| \`externalEuint64\` | \`euint64\` | Encrypted 64-bit input |
| \`externalEuint128\` | \`euint128\` | Encrypted 128-bit input |
| \`externalEuint256\` | \`euint256\` | Encrypted 256-bit input |
| \`externalEaddress\` | \`eaddress\` | Encrypted address input |

These types represent **already encrypted** data coming from the client, bundled with a ZK proof of correctness.

---

## 3. \`FHE.fromExternal(input, proof)\` — Converting External Inputs

Once the contract receives an \`externalEuintXX\`, it must convert it to the corresponding on-chain encrypted type:

\`\`\`solidity
function setSecret(externalEuint32 encValue, bytes calldata inputProof) external {
    euint32 value = FHE.fromExternal(encValue, inputProof);
    _secret = value;
    FHE.allowThis(_secret);
    FHE.allow(_secret, msg.sender);
}
\`\`\`

### What \`FHE.fromExternal(input, proof)\` Does

1. **Validates the ZK proof** — Ensures the ciphertext is well-formed and encrypts a valid value within the type's range
2. **Registers the ciphertext** — Stores it in the FHE co-processor
3. **Returns a handle** — The on-chain \`euintXX\` handle for further operations

### Function Signature Pattern

\`\`\`solidity
// Single encrypted input
function myFunction(externalEuint32 encValue, bytes calldata inputProof) external {
    euint32 value = FHE.fromExternal(encValue, inputProof);
    // ... use value
}

// Multiple encrypted inputs
function myFunction(
    externalEuint64 encAmount,
    externalEaddress encRecipient,
    bytes calldata inputProof
) external {
    euint64 amt = FHE.fromExternal(encAmount, inputProof);
    eaddress rec = FHE.fromExternal(encRecipient, inputProof);
    // ... use amt and rec
}
\`\`\`

> **Important:** The \`bytes calldata inputProof\` parameter carries the ZK proof and must be passed to every \`FHE.fromExternal(input, inputProof)\` call. Prefer \`external\` visibility for functions that accept encrypted inputs.

---

## 4. Client-Side Encryption Flow

### Step 1: Get the FHE Public Key

The client first retrieves the network's FHE public key:

\`\`\`javascript
import { createInstance } from "@zama-fhe/relayer-sdk/web";

const provider = new BrowserProvider(window.ethereum);
const instance = await createInstance({
  network: await provider.send("eth_chainId", []),
  relayerUrl: "https://gateway.zama.ai",
});
\`\`\`

### Step 2: Encrypt the Value

\`\`\`javascript
// Encrypt a uint32 value
const encryptedAmount = await instance.input.createEncryptedInput(
  contractAddress,
  userAddress
);
encryptedAmount.add32(1000); // The plaintext value to encrypt
const encrypted = await encryptedAmount.encrypt();

// encrypted contains:
// - encrypted.handles[0]: the ciphertext handle
// - encrypted.inputProof: the ZK proof
\`\`\`

### Step 3: Send the Transaction

\`\`\`javascript
const tx = await contract.setSecret(encrypted.handles[0], encrypted.inputProof);
await tx.wait();
\`\`\`

### Step 4: Contract Receives and Converts

\`\`\`solidity
function setSecret(externalEuint32 encValue, bytes calldata inputProof) external {
    euint32 value = FHE.fromExternal(encValue, inputProof);
    // Now \`value\` is a usable on-chain encrypted value
}
\`\`\`

---

## 5. Complete Example: Sealed-Bid Auction

### Contract

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract SealedBidAuction is ZamaEthereumConfig {
    address public owner;
    mapping(address => euint64) private _bids;
    mapping(address => bool) private _hasBid;
    euint64 private _highestBid;
    bool public auctionOpen;

    constructor() {
        owner = msg.sender;
        auctionOpen = true;
        _highestBid = FHE.asEuint64(0);
        FHE.allowThis(_highestBid);
    }

    /// @notice Submit a sealed bid using client-side encryption
    /// @param encryptedBid The encrypted bid amount from the client
    /// @param inputProof The ZK proof for the encrypted input
    function submitBid(externalEuint64 encryptedBid, bytes calldata inputProof) external {
        require(auctionOpen, "Auction closed");
        require(!_hasBid[msg.sender], "Already bid");

        // Convert external encrypted input to on-chain type
        euint64 bid = FHE.fromExternal(encryptedBid, inputProof);

        // Store the bid
        _bids[msg.sender] = bid;
        _hasBid[msg.sender] = true;

        // Update highest bid
        _highestBid = FHE.max(_highestBid, bid);

        // ACL
        FHE.allowThis(_bids[msg.sender]);
        FHE.allow(_bids[msg.sender], msg.sender);
        FHE.allowThis(_highestBid);
    }

    function closeAuction() public {
        require(msg.sender == owner, "Not owner");
        auctionOpen = false;
    }

    function getMyBid() public view returns (euint64) {
        require(_hasBid[msg.sender], "No bid");
        require(FHE.isSenderAllowed(_bids[msg.sender]), "Not authorized");
        return _bids[msg.sender];
    }
}
\`\`\`

### Client Code

\`\`\`javascript
import { createInstance } from "@zama-fhe/relayer-sdk/web";
import { ethers } from "ethers";

async function submitBid(contractAddress, bidAmount) {
    const provider = new ethers.BrowserProvider(window.ethereum);
    const signer = await provider.getSigner();
    const userAddress = await signer.getAddress();

    // Create FHEVM instance
    const instance = await createInstance({
        network: provider,
    });

    // Encrypt the bid
    const input = await instance.input.createEncryptedInput(
        contractAddress,
        userAddress
    );
    input.add64(bidAmount);
    const encrypted = await input.encrypt();

    // Submit to contract
    const contract = new ethers.Contract(contractAddress, ABI, signer);
    const tx = await contract.submitBid(
        encrypted.handles[0],
        encrypted.inputProof
    );
    await tx.wait();
    console.log("Bid submitted successfully!");
}
\`\`\`

---

## 6. The Role of ZK Proofs

### Why ZK Proofs Are Needed

Without ZK proofs, a malicious user could submit:
- Invalid ciphertexts that cause FHE operations to fail
- Ciphertexts encoding values outside the valid range (e.g., a value > 2^32 for \`euint32\`)
- Ciphertexts not encrypted under the correct FHE public key

### What the ZK Proof Guarantees

1. **Well-formedness** — The ciphertext is a valid encryption under the network's FHE public key
2. **Range proof** — The encrypted value fits within the declared type's range
3. **Knowledge proof** — The submitter actually knows the plaintext value

### How It Works

\`\`\`
Client Side:
  plaintext value → FHE.encrypt(value, publicKey) → (ciphertext, zkProof)

On-Chain (FHE.fromExternal(input, proof)):
  1. Verify zkProof against ciphertext     ✓ Well-formed
  2. Check range constraints               ✓ Valid value
  3. Register ciphertext in co-processor   ✓ Ready to use
  4. Return handle                         → euintXX
\`\`\`

The ZK proof verification happens automatically inside \`FHE.fromExternal(input, proof)\`. You do not need to verify it manually.

---

## 7. Multiple Encrypted Inputs

You can accept multiple encrypted inputs in a single function:

\`\`\`solidity
function createOrder(
    externalEuint64 encryptedPrice,
    externalEuint32 encryptedQuantity,
    externalEaddress encryptedRecipient,
    bytes calldata inputProof
) external {
    euint64 price = FHE.fromExternal(encryptedPrice, inputProof);
    euint32 quantity = FHE.fromExternal(encryptedQuantity, inputProof);
    eaddress recipient = FHE.fromExternal(encryptedRecipient, inputProof);

    // Store order details
    _prices[msg.sender] = price;
    _quantities[msg.sender] = quantity;
    _recipients[msg.sender] = recipient;

    // ACL for all values
    FHE.allowThis(price);
    FHE.allow(price, msg.sender);
    FHE.allowThis(quantity);
    FHE.allow(quantity, msg.sender);
    FHE.allowThis(recipient);
    FHE.allow(recipient, msg.sender);
}
\`\`\`

Client-side:

\`\`\`javascript
const input = await instance.input.createEncryptedInput(contractAddress, userAddress);
input.add64(priceValue);
input.add32(quantityValue);
input.addAddress(recipientAddress);
const encrypted = await input.encrypt();

const tx = await contract.createOrder(
    encrypted.handles[0],  // price
    encrypted.handles[1],  // quantity
    encrypted.handles[2],  // recipient
    encrypted.inputProof
);
\`\`\`

---

## 8. Common Mistakes

### Mistake 1: Forgetting the \`bytes calldata inputProof\` Parameter

\`\`\`solidity
// WRONG — missing proof parameter
function bad(externalEuint32 encValue) public { }

// CORRECT
function good(externalEuint32 encValue, bytes calldata inputProof) external { }
\`\`\`

### Mistake 2: Forgetting to Call \`FHE.fromExternal(input, inputProof)\`

\`\`\`solidity
// WRONG — cannot use externalEuint32 directly in operations
function bad(externalEuint32 encValue, bytes calldata inputProof) external {
    _value = FHE.add(_value, encValue); // ERROR
}

// CORRECT
function good(externalEuint32 encValue, bytes calldata inputProof) external {
    euint32 val = FHE.fromExternal(encValue, inputProof);
    _value = FHE.add(_value, val);
    FHE.allowThis(_value);
}
\`\`\`

### Mistake 3: Not Using Encrypted Inputs for Private Data

\`\`\`solidity
// BAD — user's vote is visible in calldata
function vote(uint8 candidate) public {
    _votes[msg.sender] = FHE.asEuint8(candidate);
}

// GOOD — user's vote is encrypted before submission
function vote(externalEuint8 encryptedVote, bytes calldata inputProof) external {
    euint8 v = FHE.fromExternal(encryptedVote, inputProof);
    _votes[msg.sender] = v;
    FHE.allowThis(_votes[msg.sender]);
}
\`\`\`

---

## 9. Hardhat Test Environment vs Browser

The API is functionally identical but differs slightly between environments:

| Environment | API |
|-------------|-----|
| Browser (Relayer SDK) | \`instance.input.createEncryptedInput(contractAddr, userAddr)\` |
| Hardhat Tests | \`fhevm.createEncryptedInput(contractAddr, signerAddr)\` |

The \`fhevm\` object in Hardhat is provided by \`@fhevm/hardhat-plugin\`. Both produce the same \`{ handles, inputProof }\` output.

\`\`\`javascript
// Hardhat test
const encrypted = await fhevm
  .createEncryptedInput(contractAddress, deployer.address)
  .add32(42)
  .encrypt();
await contract.myFunction(encrypted.handles[0], encrypted.inputProof);

// Browser (Relayer SDK)
const input = await instance.input.createEncryptedInput(contractAddress, userAddress);
input.add32(42);
const encrypted = await input.encrypt();
await contract.myFunction(encrypted.handles[0], encrypted.inputProof);
\`\`\`

> Both environments produce the same encrypted output format. The only difference is how the encryption instance is created.

---

## Summary

| Concept | Details |
|---------|---------|
| **Problem** | \`FHE.asEuintXX(plaintext)\` exposes the value in calldata |
| **Solution** | Client encrypts data before sending; contract receives \`externalEuintXX\` |
| **Conversion** | \`FHE.fromExternal(input, inputProof)\` validates ZK proof and returns \`euintXX\` |
| **Parameters** | Function must accept both \`externalEuintXX\` and \`bytes calldata inputProof\` |
| **ZK proof** | Automatically verified — ensures well-formedness and range validity |
| **Client library** | Relayer SDK (\`@zama-fhe/relayer-sdk\`) handles encryption and proof generation |

**Rule of thumb:** If the plaintext value should be private, always use \`externalEuintXX\` + \`bytes calldata inputProof\` + \`FHE.fromExternal(input, inputProof)\`. Reserve \`FHE.asEuintXX()\` for non-sensitive constants and contract-internal values.
`,
  "07-decryption": `# Module 07: Decryption Patterns — Lesson

## Introduction

Encrypted data is only useful if you can eventually act on the plaintext. FHEVM provides two primary decryption approaches:

1. **Public decryption** — Make the encrypted value decryptable by everyone using \`FHE.makePubliclyDecryptable()\`
2. **User-specific decryption (Reencryption)** — Grant individual users access via ACL, they decrypt client-side

---

## 1. Why Decrypt?

Encrypted values are useful for computation, but eventually results need to be revealed:
- **Vote outcomes** — After tallying, the results should be public
- **Auction winners** — The winning bid needs to be announced
- **Private balances** — Users need to see their own balance
- **Game results** — The outcome must eventually be known

The key question is: **Who should see the decrypted value?**

---

## 2. Approach 1: Public Decryption — FHE.makePubliclyDecryptable()

When a result should be visible to **everyone**, use \`FHE.makePubliclyDecryptable()\`:

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import {FHE, euint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract VoteRevealer is ZamaEthereumConfig {
    euint32 private _yesVotes;
    euint32 private _noVotes;
    bool public isRevealed;

    function revealResults() external {
        require(!isRevealed, "Already revealed");
        FHE.makePubliclyDecryptable(_yesVotes);
        FHE.makePubliclyDecryptable(_noVotes);
        isRevealed = true;
    }
}
\`\`\`

### When to Use
- Vote results that should become public
- Auction outcomes (winning bid, winner)
- Game results and scores
- Any value that should be visible to ALL users

### Important Notes
- **Irreversible** — Once made publicly decryptable, anyone can see the plaintext. You cannot undo this.
- **Works for all types** — euint8, euint32, euint64, euint128, euint256, ebool, eaddress
- **Synchronous** — The value is immediately marked for public decryption (no callback needed)

---

## 3. Approach 2: User-Specific Decryption (Reencryption)

When only a **specific user** should see their data, use the ACL + reencryption pattern:

### Step 1: Grant ACL Access (Contract Side)

\`\`\`solidity
function storeBalance(address user, euint64 balance) internal {
    _balances[user] = balance;
    FHE.allowThis(_balances[user]);    // Contract can use it
    FHE.allow(_balances[user], user);  // User can decrypt it
}

function getMyBalance() public view returns (euint64) {
    require(FHE.isSenderAllowed(_balances[msg.sender]), "No access");
    return _balances[msg.sender];
}
\`\`\`

### Step 2: Decrypt (Client Side)

**In Hardhat Tests:**
\`\`\`typescript
import { fhevm } from "hardhat";
import { FhevmType } from "@fhevm/hardhat-plugin";

const handle = await contract.getMyBalance();
const plaintext = await fhevm.userDecryptEuint(
    FhevmType.euint64,
    handle,
    contractAddress,
    signer
);
expect(plaintext).to.equal(1000n);

// For ebool:
const boolHandle = await contract.getFlag();
const boolValue = await fhevm.userDecryptEbool(
    boolHandle,
    contractAddress,
    signer
);
expect(boolValue).to.equal(true);
\`\`\`

**In Browser (Relayer SDK):**
\`\`\`javascript
const { publicKey, privateKey } = instance.generateKeypair();
const eip712 = instance.createEIP712(publicKey, contractAddress);
const signature = await signer.signTypedData(
    eip712.domain,
    { Reencrypt: eip712.types.Reencrypt },
    eip712.message
);

const handle = await contract.getMyBalance();
const plaintext = await instance.reencrypt(
    handle, privateKey, publicKey, signature,
    contractAddress, await signer.getAddress()
);
\`\`\`

### When to Use
- Private balances — only the owner should see
- Personal data — medical records, scores
- Individual secrets — bids before reveal
- Any value that should be visible to ONLY ONE user

---

## 4. Comparing the Two Approaches

| Feature | makePubliclyDecryptable | User Reencryption |
|---------|------------------------|-------------------|
| Who sees plaintext? | Everyone | Only the authorized user |
| On-chain call | \`FHE.makePubliclyDecryptable(handle)\` | \`FHE.allow(handle, user)\` |
| Client-side | Anyone can read | User calls reencrypt |
| Reversible? | No | ACL can be revoked (new handle) |
| Use case | Vote results, auction outcomes | Private balances, secrets |
| Async? | No (immediate) | No (immediate ACL grant) |
| Hardhat test | \`fhevm.userDecryptEuint()\` | \`fhevm.userDecryptEuint()\` |

---

## 5. Practical Example: PublicDecrypt.sol Walkthrough

The bootcamp includes \`contracts/PublicDecrypt.sol\` which demonstrates both patterns:

\`\`\`solidity
contract PublicDecrypt is ZamaEthereumConfig {
    euint32 private _encryptedValue;
    bool public hasValue;
    bool public isPubliclyDecryptable;

    // Store a value — grant ACL to sender (user-specific decrypt)
    function setValue(uint32 value) external {
        _encryptedValue = FHE.asEuint32(value);
        FHE.allowThis(_encryptedValue);
        FHE.allow(_encryptedValue, msg.sender);  // User can decrypt
        hasValue = true;
    }

    // Make it public — anyone can decrypt
    function makePublic() external {
        require(hasValue, "No value set");
        FHE.makePubliclyDecryptable(_encryptedValue);
        isPubliclyDecryptable = true;
    }

    // Return handle for off-chain decryption
    function getEncryptedValue() external view returns (euint32) {
        return _encryptedValue;
    }
}
\`\`\`

### Flow:
1. User calls \`setValue(42)\` → value is encrypted, only they can decrypt
2. User calls \`makePublic()\` → now ANYONE can decrypt the value
3. Any user calls \`getEncryptedValue()\` → gets the handle → decrypts off-chain

---

## 6. Practical Example: UserDecrypt.sol Walkthrough

The \`contracts/UserDecrypt.sol\` demonstrates per-user secrets with sharing:

\`\`\`solidity
contract UserDecrypt is ZamaEthereumConfig {
    mapping(address => euint32) private _userSecrets;

    // Store own encrypted secret
    function storeSecret(externalEuint32 encValue, bytes calldata inputProof) external {
        _userSecrets[msg.sender] = FHE.fromExternal(encValue, inputProof);
        FHE.allowThis(_userSecrets[msg.sender]);
        FHE.allow(_userSecrets[msg.sender], msg.sender);
    }

    // Get own secret handle (for decryption)
    function getMySecret() external view returns (euint32) {
        return _userSecrets[msg.sender];
    }

    // Share secret with another address
    function shareSecret(address to) external {
        FHE.allow(_userSecrets[msg.sender], to);
    }
}
\`\`\`

### Key Pattern: Secret Sharing
- Alice stores a secret → only Alice can decrypt
- Alice calls \`shareSecret(bob)\` → now Bob can also decrypt Alice's secret
- Bob uses \`fhevm.userDecryptEuint()\` to see the value

---

## 7. Hardhat Test Patterns

### Testing Public Decryption
\`\`\`typescript
it("should make value publicly decryptable", async function () {
    await contract.setValue(42);
    await contract.makePublic();

    // After makePubliclyDecryptable, the value can be decrypted
    const handle = await contract.getEncryptedValue();
    const value = await fhevm.userDecryptEuint(
        FhevmType.euint32, handle, contractAddress, deployer
    );
    expect(value).to.equal(42n);
});
\`\`\`

### Testing User-Specific Decryption
\`\`\`typescript
it("should decrypt own secret", async function () {
    const enc = await fhevm
        .createEncryptedInput(contractAddress, alice.address)
        .add32(999)
        .encrypt();
    await contract.connect(alice).storeSecret(enc.handles[0], enc.inputProof);

    const handle = await contract.connect(alice).getMySecret();
    const value = await fhevm.userDecryptEuint(
        FhevmType.euint32, handle, contractAddress, alice
    );
    expect(value).to.equal(999n);
});
\`\`\`

### Testing ACL-Protected Access
\`\`\`typescript
it("should deny unauthorized access", async function () {
    // Bob tries to decrypt Alice's secret without ACL
    const handle = await contract.connect(bob).getMySecret();
    // Bob has no secret stored, so handle is zero/empty
});
\`\`\`

---

## 8. Security Considerations

### Do Not Decrypt Unnecessarily

Every decryption reveals information. Minimize decryptions to preserve privacy:

\`\`\`solidity
// BAD: Making value public just to compare
function isRichBad() public {
    FHE.makePubliclyDecryptable(_balance);  // Reveals exact balance!
}

// GOOD: Keep the comparison encrypted
function isRich() public view returns (ebool) {
    return FHE.gt(_balance, FHE.asEuint64(1000));  // No value revealed
}
\`\`\`

### Information Leakage

- \`makePubliclyDecryptable\` reveals the EXACT value — use only when necessary
- Even partial information (e.g., "balance > 1000") reveals something
- Consider whether you really need to decrypt, or can keep working with encrypted values

### Timing Considerations

- Design your contract so all game-changing state updates happen BEFORE decryption
- A random value should be committed (stored, used in logic) before any party can request its decryption

---

## 9. Advanced: Legacy Gateway Pattern (Pre-v0.9)

> ⚠️ **WARNING:** The Gateway callback pattern shown below was used in fhEVM v0.8 and earlier.
> In the current version (v0.9+), use \`FHE.makePubliclyDecryptable()\` as shown in Section 5.
> This section is included for historical reference only — do NOT use this pattern in new contracts.

In production fhEVM networks, a **Gateway** service coordinates decryption between the blockchain and the KMS (Key Management Service). This uses an **asynchronous callback pattern**:

\`\`\`solidity
// LEGACY — v0.8 only
// PRODUCTION ONLY — Gateway not available in Hardhat development environment
import {GatewayConfig} from "@fhevm/solidity/gateway/GatewayConfig.sol";

contract ProductionDecrypt is ZamaEthereumConfig, GatewayConfig {
    uint64 public revealedValue;

    function requestReveal() public {
        // In production, the Gateway handles converting encrypted handles
        // to uint256[] and coordinating decryption with the KMS.
        // FHE.toUint256() does not exist — the Gateway manages handle conversion.
        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(_encryptedValue);

        Gateway.requestDecryption(
            cts,
            this.revealCallback.selector,
            0,
            block.timestamp + 100,
            false
        );
    }

    function revealCallback(uint256 requestId, uint64 value) public onlyGateway {
        revealedValue = value;
    }
}
\`\`\`

### Key Points About the Gateway Pattern:
- **Asynchronous** — Request in one tx, result arrives in a callback tx
- **KMS** holds shares of the FHE secret key for threshold decryption
- **onlyGateway** modifier ensures only the Gateway can call the callback
- The local Hardhat environment simulates decryption synchronously via \`userDecryptEuint()\`, so you don't need the Gateway for development and testing
- Use \`makePubliclyDecryptable()\` + \`userDecryptEuint()\` for development; switch to Gateway for production if needed

---

## 10. Common Mistakes

### Mistake 1: Forgetting ACL Before Decryption
\`\`\`solidity
// BUG: User can't decrypt — no ACL granted
function storeValue(uint32 val) external {
    _value = FHE.asEuint32(val);
    FHE.allowThis(_value);
    // MISSING: FHE.allow(_value, msg.sender);
}
\`\`\`

### Mistake 2: Making Sensitive Data Public
\`\`\`solidity
// DANGEROUS: Reveals everyone's balance!
function revealAllBalances() external {
    for (...) {
        FHE.makePubliclyDecryptable(_balances[user]); // Privacy violation!
    }
}
\`\`\`

### Mistake 3: Not Checking isSenderAllowed in Getters
\`\`\`solidity
// BAD: Returns handle without access check
function getBalance() view returns (euint64) {
    return _balances[msg.sender]; // No ACL check!
}

// GOOD: Check access first
function getBalance() view returns (euint64) {
    require(FHE.isSenderAllowed(_balances[msg.sender]), "No access");
    return _balances[msg.sender];
}
\`\`\`

### Mistake 4: Forgetting ACL Reset After Operations
\`\`\`solidity
// BUG: After FHE.add, a NEW handle is created — old ACL doesn't apply
_balance = FHE.add(_balance, amount);
// MISSING: FHE.allowThis(_balance); FHE.allow(_balance, user);
\`\`\`

---

## Summary

| Pattern | When to Use | How |
|---------|-------------|-----|
| **Public decryption** | Result should be visible to all | \`FHE.makePubliclyDecryptable(handle)\` |
| **User reencryption** | Only the user should see | \`FHE.allow(handle, user)\` + client-side decrypt |

**Key principles:**
1. Use \`FHE.makePubliclyDecryptable()\` for values everyone should see (vote results, auction winners)
2. Use \`FHE.allow()\` + reencryption for private values (balances, secrets)
3. Always check \`FHE.isSenderAllowed()\` in view functions that return encrypted handles
4. Minimize decryptions — keep data encrypted as long as possible
5. Remember: ACL must be reset after every FHE operation (new handle = empty ACL)
6. In Hardhat tests: \`fhevm.userDecryptEuint()\` and \`fhevm.userDecryptEbool()\` for testing both patterns
`,
  "08-conditional-logic": `# Module 08: Conditional Logic — Lesson

## Introduction

In standard Solidity, you write \`if (balance >= amount) { ... }\` to branch on a condition. With encrypted values, this is **impossible** — you cannot branch on an encrypted boolean because the EVM does not know whether it is true or false.

FHEVM solves this with \`FHE.select()\`, an encrypted ternary operator that evaluates **both** branches and picks the correct result — all while keeping the condition encrypted.

---

## 1. Why Branching Fails with Encrypted Data

### The Problem

\`\`\`solidity
// THIS DOES NOT WORK with encrypted values
ebool hasEnough = FHE.ge(balance, amount);

if (hasEnough) {  // ERROR: Cannot convert ebool to bool
    balance = FHE.sub(balance, amount);
}
\`\`\`

The EVM needs a plaintext \`bool\` for \`if\` statements. An \`ebool\` is an encrypted value — the EVM cannot read it without decryption.

### The Solution: Compute Both Branches

Instead of choosing which code path to execute, you **execute both paths** and use \`FHE.select()\` to pick the correct result:

\`\`\`solidity
ebool hasEnough = FHE.ge(balance, amount);

euint64 newBalance = FHE.sub(balance, amount);    // Path A: deduct
// Path B: keep original balance (no code needed)

balance = FHE.select(hasEnough, newBalance, balance);
// If hasEnough: balance = newBalance
// If !hasEnough: balance = balance (unchanged)
\`\`\`

---

## 1.5 Comparison Operators Reference

All encrypted comparison operators return \`ebool\`:

| Operator | Description | Example | Returns |
|----------|-------------|---------|---------|
| \`FHE.eq(a, b)\` | Equal | \`FHE.eq(encAge, FHE.asEuint32(18))\` | \`ebool\` |
| \`FHE.ne(a, b)\` | Not equal | \`FHE.ne(encStatus, FHE.asEuint8(0))\` | \`ebool\` |
| \`FHE.lt(a, b)\` | Less than | \`FHE.lt(encBid, encReserve)\` | \`ebool\` |
| \`FHE.le(a, b)\` | Less than or equal | \`FHE.le(encAge, FHE.asEuint32(65))\` | \`ebool\` |
| \`FHE.gt(a, b)\` | Greater than | \`FHE.gt(encBalance, encCost)\` | \`ebool\` |
| \`FHE.ge(a, b)\` | Greater than or equal | \`FHE.ge(encBalance, encPrice)\` | \`ebool\` |

> **Type restrictions:**
> - \`euint256\` only supports \`FHE.eq()\` and \`FHE.ne()\` — NO ordering comparisons (\`lt\`/\`le\`/\`gt\`/\`ge\`)
> - \`eaddress\` only supports \`FHE.eq()\` and \`FHE.ne()\`
> - Cross-type comparisons are supported with auto-upcast (e.g., \`FHE.gt(euint32, euint64)\` → result is \`ebool\`)

---

## 2. \`FHE.select()\` — The Encrypted Ternary

### Syntax

\`\`\`solidity
FHE.select(condition, valueIfTrue, valueIfFalse)
\`\`\`

| Parameter | Type | Description |
|-----------|------|-------------|
| \`condition\` | \`ebool\` | Encrypted boolean condition |
| \`valueIfTrue\` | \`euintXX\` / \`ebool\` / \`eaddress\` | Value returned when condition is true |
| \`valueIfFalse\` | \`euintXX\` / \`ebool\` / \`eaddress\` | Value returned when condition is false |
| **Returns** | Same as value types | The selected encrypted value |

### Type Rules

- \`valueIfTrue\` and \`valueIfFalse\` must be the **same type**
- The return type matches the value types
- The condition must be an \`ebool\`
- Works with **all** encrypted types: \`euint8\`, \`euint16\`, \`euint32\`, \`euint64\`, \`euint128\`, \`euint256\`, \`ebool\`, \`eaddress\`

### Basic Examples

\`\`\`solidity
// Ternary: result = (a > b) ? a : b
ebool aIsLarger = FHE.gt(a, b);
euint32 result = FHE.select(aIsLarger, a, b);  // max(a, b)

// Ternary: flag = (x == 0) ? true : false
ebool isZero = FHE.eq(x, FHE.asEuint32(0));
ebool flag = FHE.select(isZero, FHE.asEbool(true), FHE.asEbool(false));

// Select encrypted address
eaddress winner = FHE.select(aWins, playerA, playerB);
\`\`\`

---

## 3. Common Patterns

### Pattern 1: Safe Subtraction (No Underflow)

\`\`\`solidity
function safeSub(euint32 a, euint32 b) internal returns (euint32) {
    ebool canSub = FHE.ge(a, b);
    euint32 diff = FHE.sub(a, b);
    euint32 zero = FHE.asEuint32(0);
    euint32 result = FHE.select(canSub, diff, zero);
    FHE.allowThis(result);
    return result;
}
\`\`\`

### Pattern 2: Clamp (Min and Max Bound)

\`\`\`solidity
function clamp(euint32 value, uint32 minVal, uint32 maxVal) internal returns (euint32) {
    euint32 atLeastMin = FHE.max(value, FHE.asEuint32(minVal));
    euint32 clamped = FHE.min(atLeastMin, FHE.asEuint32(maxVal));
    FHE.allowThis(clamped);
    return clamped;
}
\`\`\`

Note: \`FHE.min()\` and \`FHE.max()\` are built-in and internally use \`FHE.select()\`. You can also write them manually:

\`\`\`solidity
// Manual min
ebool isSmaller = FHE.lt(a, b);
euint32 minVal = FHE.select(isSmaller, a, b);

// Manual max
ebool isLarger = FHE.gt(a, b);
euint32 maxVal = FHE.select(isLarger, a, b);
\`\`\`

### Pattern 3: Conditional Transfer

\`\`\`solidity
function transfer(address to, uint64 amount) public {
    euint64 amt = FHE.asEuint64(amount);
    ebool hasEnough = FHE.ge(_balances[msg.sender], amt);

    // Compute both outcomes
    euint64 senderAfter = FHE.sub(_balances[msg.sender], amt);
    euint64 receiverAfter = FHE.add(_balances[to], amt);

    // Select based on condition
    _balances[msg.sender] = FHE.select(hasEnough, senderAfter, _balances[msg.sender]);
    _balances[to] = FHE.select(hasEnough, receiverAfter, _balances[to]);

    // ACL
    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);
}
\`\`\`

### Pattern 4: Increment with Cap

\`\`\`solidity
function incrementCapped(euint32 value, uint32 cap) internal returns (euint32) {
    euint32 incremented = FHE.add(value, FHE.asEuint32(1));
    ebool belowCap = FHE.lt(value, FHE.asEuint32(cap));
    euint32 result = FHE.select(belowCap, incremented, value);
    FHE.allowThis(result);
    return result;
}
\`\`\`

---

## 4. Nested Selects: Multi-Way Conditions

For multi-way branching (like switch/case), nest multiple \`FHE.select()\` calls:

### Example: Tiered Pricing

\`\`\`solidity
// Price tiers:
// quantity >= 100 -> price = 5
// quantity >= 50  -> price = 8
// quantity >= 10  -> price = 10
// quantity < 10   -> price = 15

function getPrice(euint32 quantity) internal returns (euint32) {
    euint32 price = FHE.asEuint32(15);  // default: < 10

    price = FHE.select(FHE.ge(quantity, FHE.asEuint32(10)), FHE.asEuint32(10), price);
    price = FHE.select(FHE.ge(quantity, FHE.asEuint32(50)), FHE.asEuint32(8), price);
    price = FHE.select(FHE.ge(quantity, FHE.asEuint32(100)), FHE.asEuint32(5), price);

    FHE.allowThis(price);
    return price;
}
\`\`\`

### Example: Category Assignment

\`\`\`solidity
// Assign category: 0-25=0, 26-50=1, 51-75=2, 76+=3
function categorize(euint8 score) internal returns (euint8) {
    euint8 cat = FHE.asEuint8(0);
    cat = FHE.select(FHE.gt(score, FHE.asEuint8(25)), FHE.asEuint8(1), cat);
    cat = FHE.select(FHE.gt(score, FHE.asEuint8(50)), FHE.asEuint8(2), cat);
    cat = FHE.select(FHE.gt(score, FHE.asEuint8(75)), FHE.asEuint8(3), cat);
    FHE.allowThis(cat);
    return cat;
}
\`\`\`

---

## 5. Boolean Logic with Encrypted Conditions

You can combine multiple encrypted conditions:

### Encrypted AND

\`\`\`solidity
ebool encAnd = FHE.and(condA, condB);
\`\`\`

### Encrypted OR

\`\`\`solidity
ebool encOr = FHE.or(condA, condB);
\`\`\`

### Encrypted NOT

\`\`\`solidity
ebool encNot = FHE.not(condition);
\`\`\`

### Complex Condition Example

\`\`\`solidity
// Transfer allowed if: sender has enough AND recipient is not blacklisted
ebool hasEnough = FHE.ge(_balances[msg.sender], amount);
ebool notBlacklisted = FHE.ne(_status[to], FHE.asEuint8(BLACKLISTED));
ebool canTransfer = FHE.and(hasEnough, notBlacklisted);

_balances[msg.sender] = FHE.select(canTransfer, newSenderBal, _balances[msg.sender]);
_balances[to] = FHE.select(canTransfer, newReceiverBal, _balances[to]);
\`\`\`

---

## 6. Gas Optimization Tips

### Tip 1: Reuse Encrypted Constants

\`\`\`solidity
// BAD: Creates a new ciphertext each time
result = FHE.select(cond1, FHE.asEuint32(0), result);
result = FHE.select(cond2, FHE.asEuint32(0), result);

// GOOD: Create once, reuse
euint32 zero = FHE.asEuint32(0);
result = FHE.select(cond1, zero, result);
result = FHE.select(cond2, zero, result);
\`\`\`

### Tip 2: Use Built-in Min/Max

\`\`\`solidity
// Use the built-in instead of manual select:
value = FHE.min(value, maxEnc);
\`\`\`

### Tip 3: Minimize the Number of Selects

Each \`FHE.select()\` has a gas cost. Restructure logic to use fewer selects when possible.

---

## 7. Practical Example: Encrypted Auction Bid Validation

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract BidValidator is ZamaEthereumConfig {
    euint64 private _minBid;
    euint64 private _maxBid;
    euint64 private _currentHighest;

    constructor(uint64 minBid, uint64 maxBid) {
        _minBid = FHE.asEuint64(minBid);
        _maxBid = FHE.asEuint64(maxBid);
        _currentHighest = FHE.asEuint64(0);
        FHE.allowThis(_minBid);
        FHE.allowThis(_maxBid);
        FHE.allowThis(_currentHighest);
    }

    function validateAndSubmitBid(externalEuint64 encBid, bytes calldata inputProof) external {
        euint64 bid = FHE.fromExternal(encBid, inputProof);

        ebool aboveMin = FHE.ge(bid, _minBid);
        ebool belowMax = FHE.le(bid, _maxBid);
        ebool beatsHighest = FHE.gt(bid, _currentHighest);

        ebool valid = FHE.and(aboveMin, FHE.and(belowMax, beatsHighest));

        _currentHighest = FHE.select(valid, bid, _currentHighest);
        FHE.allowThis(_currentHighest);
    }
}
\`\`\`

---

## 8. Common Mistakes

### Mistake 1: Trying to Use \`if\` with \`ebool\`

\`\`\`solidity
// WRONG
if (FHE.gt(a, b)) { ... }  // Compilation error

// CORRECT
result = FHE.select(FHE.gt(a, b), valueA, valueB);
\`\`\`

### Mistake 2: Forgetting Both Branches Execute

Both branches are **always** computed. Gas cost is the sum of both.

### Mistake 3: Type Mismatch in Select

\`\`\`solidity
// WRONG — different types
FHE.select(cond, euint32_val, euint64_val);  // ERROR

// CORRECT — same types
FHE.select(cond, euint32_a, euint32_b);  // OK
\`\`\`

---

## Summary

| Concept | Details |
|---------|---------|
| **\`FHE.select(cond, a, b)\`** | Returns \`a\` if cond is true, \`b\` if false |
| **Both branches execute** | Gas = cost of both paths combined |
| **Types must match** | \`a\` and \`b\` must be the same encrypted type |
| **Nested selects** | Chain for multi-way conditions |
| **Boolean logic** | Use \`FHE.and()\`, \`FHE.or()\`, \`FHE.not()\` to combine conditions |
| **Built-in helpers** | \`FHE.min()\`, \`FHE.max()\` use select internally |

**Key principle:** In FHE, you never branch — you always compute all paths and **select** the correct result.
`,
  "09-random": `# Module 09: On-Chain Encrypted Randomness — Lesson

## Introduction

Randomness is a fundamental building block for many blockchain applications: lotteries, games, NFT minting, random selection, shuffling, and more. However, generating truly unpredictable and manipulation-resistant randomness on a public, deterministic blockchain is one of the hardest unsolved problems in smart contract development.

FHEVM introduces a powerful solution: **encrypted on-chain randomness**. Using FHE (Fully Homomorphic Encryption), the blockchain can generate random values that are encrypted at creation time — nobody can see the random value, not even the block producer, the sequencer, or the contract itself. This makes front-running and manipulation mathematically impossible.

---

## 1. The Problem with On-Chain Randomness

### Why Is Randomness Hard on Blockchain?

Blockchains are **deterministic state machines**. Every node must compute the same result for the same input. This fundamental property conflicts with randomness — if everyone can compute the same "random" value, it is not random at all.

### Common (Broken) Approaches

#### \`block.timestamp\`

\`\`\`solidity
// INSECURE: Miners/validators can manipulate the timestamp
uint256 random = uint256(keccak256(abi.encodePacked(block.timestamp)));
\`\`\`

- Block producers can adjust \`block.timestamp\` within allowed bounds (typically ~15 seconds)
- The value is known before the transaction is mined
- Anyone watching the mempool can predict the outcome

#### \`block.prevrandao\` (formerly \`block.difficulty\`)

\`\`\`solidity
// INSECURE: Known before block execution
uint256 random = uint256(keccak256(abi.encodePacked(block.prevrandao)));
\`\`\`

- Validators know \`prevrandao\` before they propose the block
- They can choose to include or exclude transactions based on the outcome
- Searchers and MEV bots can front-run transactions that depend on it

#### Blockhash-Based Randomness

\`\`\`solidity
// INSECURE: Predictable within the same block
uint256 random = uint256(blockhash(block.number - 1));
\`\`\`

- The blockhash is known to all participants before the next block
- Block producers can withhold blocks if the hash produces an unfavorable result

### Chainlink VRF: Better But Not Perfect

Chainlink VRF (Verifiable Random Function) provides cryptographically provable randomness:

| Feature | Chainlink VRF | FHE Randomness |
|---------|--------------|----------------|
| **Randomness quality** | Cryptographically secure | Cryptographically secure |
| **Latency** | 2+ blocks (async callback) | Same transaction (synchronous) |
| **Cost** | LINK token + gas | Gas only |
| **Privacy** | Random value is public once delivered | Random value is **encrypted** |
| **Front-running** | Value visible in callback tx | Value never visible |
| **External dependency** | Requires Chainlink oracle network | Built into the chain |

The critical difference: Chainlink VRF generates a random value that becomes **public** when delivered. FHE randomness generates a random value that remains **encrypted** — it can be used in computations without ever being revealed.

---

## 2. FHE-Based Randomness

### How It Works

FHEVM generates randomness through the TFHE (Torus Fully Homomorphic Encryption) cryptosystem built into the blockchain's execution environment. When you call a random function:

1. The FHE coprocessor generates a cryptographically secure random value
2. The value is immediately encrypted under the network's FHE public key
3. The encrypted ciphertext is returned to your contract
4. Nobody — not the validator, not the contract, not any observer — can see the plaintext value

\`\`\`
┌──────────────┐     randEuint32()     ┌──────────────────┐
│   Contract    │ ────────────────────► │  FHE Coprocessor  │
│               │                       │                    │
│               │  ◄── encrypted ────── │  1. Generate random│
│   euint32     │      ciphertext       │  2. Encrypt it     │
│   (opaque)    │                       │  3. Return handle  │
└──────────────┘                       └──────────────────┘
\`\`\`

### Why It Is Manipulation-Proof

- **Block producers** cannot see the random value because it is encrypted
- **Validators** cannot choose to include/exclude transactions based on the random outcome — the outcome is hidden
- **MEV bots** cannot front-run because the value is never exposed in the mempool or on-chain
- **The contract itself** cannot read the value — it can only perform encrypted operations on it
- **Observers** see only an opaque ciphertext handle, not the actual number

This is the strongest form of on-chain randomness available: the random value exists, can be used in computations, but is never visible to any party until explicitly decrypted.

---

## 3. Available Random Functions

FHEVM provides random generation functions for all major encrypted types:

### Function Reference

| Function | Return Type | Range | Description |
|----------|-------------|-------|-------------|
| \`FHE.randEbool()\` | \`ebool\` | true/false | Encrypted random boolean |
| \`FHE.randEuint8()\` | \`euint8\` | 0 – 255 | Encrypted random 8-bit integer |
| \`FHE.randEuint16()\` | \`euint16\` | 0 – 65,535 | Encrypted random 16-bit integer |
| \`FHE.randEuint32()\` | \`euint32\` | 0 – 4,294,967,295 | Encrypted random 32-bit integer |
| \`FHE.randEuint64()\` | \`euint64\` | 0 – 18,446,744,073,709,551,615 | Encrypted random 64-bit integer |
| \`FHE.randEuint128()\` | \`euint128\` | 0 – 2^128 - 1 | Encrypted random 128-bit integer |
| \`FHE.randEuint256()\` | \`euint256\` | 0 – 2^256 - 1 | Encrypted random 256-bit integer |

### Basic Usage

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint8, euint16, euint32, euint64, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract RandomDemo is ZamaEthereumConfig {
    euint8 private _rand8;
    euint16 private _rand16;
    euint32 private _rand32;
    euint64 private _rand64;
    ebool private _randBool;

    /// @notice Generate an encrypted random 8-bit value
    function generateRandom8() public {
        _rand8 = FHE.randEuint8();
        FHE.allowThis(_rand8);
        FHE.allow(_rand8, msg.sender);
    }

    /// @notice Generate an encrypted random 16-bit value
    function generateRandom16() public {
        _rand16 = FHE.randEuint16();
        FHE.allowThis(_rand16);
        FHE.allow(_rand16, msg.sender);
    }

    /// @notice Generate an encrypted random 32-bit value
    function generateRandom32() public {
        _rand32 = FHE.randEuint32();
        FHE.allowThis(_rand32);
        FHE.allow(_rand32, msg.sender);
    }

    /// @notice Generate an encrypted random 64-bit value
    function generateRandom64() public {
        _rand64 = FHE.randEuint64();
        FHE.allowThis(_rand64);
        FHE.allow(_rand64, msg.sender);
    }

    /// @notice Generate an encrypted random boolean
    function generateRandomBool() public {
        _randBool = FHE.randEbool();
        FHE.allowThis(_randBool);
        FHE.allow(_randBool, msg.sender);
    }
}
\`\`\`

### Important Notes

- Each call to a \`rand\` function produces a **new independent random value**
- The returned value is an encrypted ciphertext handle — the contract cannot read it
- You **must** set ACL permissions after generation (covered in Section 5)
- Random generation is **synchronous** — the value is available in the same transaction

---

## 4. Random in Range

Raw random values span the full range of their type. In most applications, you need a value within a specific range (e.g., 1–6 for a die, 0–51 for a card deck, 0–N for an array index).

### Using \`FHE.rem()\` to Bound Values

The \`FHE.rem()\` function computes the encrypted modulo (remainder), bounding the random value:

\`\`\`solidity
// Random value in range [0, max)
euint32 bounded = FHE.rem(FHE.randEuint32(), max);
\`\`\`

### Common Patterns

#### Dice Roll (1–6)

\`\`\`solidity
function rollDice() public returns (euint8) {
    euint8 raw = FHE.randEuint8();          // 0-255
    euint8 zeroToFive = FHE.rem(raw, 6);    // 0-5
    euint8 oneToSix = FHE.add(zeroToFive, FHE.asEuint8(1));  // 1-6
    FHE.allowThis(oneToSix);
    return oneToSix;
}
\`\`\`

#### Card Draw (0–51)

\`\`\`solidity
function drawCard() public returns (euint8) {
    euint8 raw = FHE.randEuint8();         // 0-255
    euint8 card = FHE.rem(raw, 52);        // 0-51
    FHE.allowThis(card);
    return card;
}
\`\`\`

#### Random Index into an Array

\`\`\`solidity
function pickRandomPlayer(uint32 playerCount) public returns (euint32) {
    euint32 raw = FHE.randEuint32();
    euint32 index = FHE.rem(raw, playerCount);  // 0 to playerCount-1
    FHE.allowThis(index);
    return index;
}
\`\`\`

#### Random Percentage (0–99)

\`\`\`solidity
function randomPercentage() public returns (euint8) {
    euint8 raw = FHE.randEuint8();
    euint8 percent = FHE.rem(raw, 100);  // 0-99
    FHE.allowThis(percent);
    return percent;
}
\`\`\`

### Bounded Random Generation (Power-of-2 Ranges)

For ranges that are powers of 2, fhEVM provides more efficient overloaded functions:

\`\`\`solidity
// Generate random uint32 in [0, 16) — upperBound must be power of 2!
euint32 rand = FHE.randEuint32(16);

// Generate random uint8 in [0, 4)
euint8 direction = FHE.randEuint8(4);  // 0=North, 1=East, 2=South, 3=West
\`\`\`

**Available overloads:**

| Function | Range | Constraint |
|----------|-------|-----------|
| \`FHE.randEuint8(uint8 upperBound)\` | [0, upperBound) | upperBound must be power of 2 |
| \`FHE.randEuint16(uint16 upperBound)\` | [0, upperBound) | upperBound must be power of 2 |
| \`FHE.randEuint32(uint32 upperBound)\` | [0, upperBound) | upperBound must be power of 2 |
| \`FHE.randEuint64(uint64 upperBound)\` | [0, upperBound) | upperBound must be power of 2 |
| \`FHE.randEuint128(uint128 upperBound)\` | [0, upperBound) | upperBound must be power of 2 |
| \`FHE.randEuint256(uint256 upperBound)\` | [0, upperBound) | upperBound must be power of 2 |

> 💡 **When to use which?**
> - Power-of-2 range (2, 4, 8, 16, 32...) → Use \`randEuintXX(upperBound)\` (more efficient)
> - Arbitrary range (e.g., 1-6 for dice) → Use \`FHE.rem(FHE.randEuintXX(), max)\` then add offset

### Uniformity Considerations (Modulo Bias)

When the range does not evenly divide the source range, \`FHE.rem()\` introduces a slight **modulo bias**. For example:

- \`FHE.randEuint8()\` produces values 0–255 (256 possible values)
- \`FHE.rem(value, 6)\` maps 256 values to 6 buckets
- 256 / 6 = 42 remainder 4, so values 0–3 are slightly more likely than 4–5

| Practical impact | Details |
|-----------------|---------|
| **Small ranges (2–16)** | Bias is negligible for most applications |
| **Large ranges** | Use a larger source type (e.g., \`euint32\` for ranges up to ~1000) |
| **Critical fairness** | Use \`euint64\` as the source to minimize bias to near-zero |

**Rule of thumb:** Use a random type that is significantly larger than your target range. For a 6-sided die, \`euint8\` (256 values) is acceptable. For ranges above 100, prefer \`euint32\` or \`euint64\`.

---

## 5. ACL for Random Values

Like all encrypted values in FHEVM, randomly generated ciphertexts start with an **empty ACL**. You must explicitly grant permissions after generation.

### Mandatory Pattern

\`\`\`solidity
euint32 random = FHE.randEuint32();
FHE.allowThis(random);           // Contract can use it in future transactions
FHE.allow(random, msg.sender);   // Caller can request decryption
\`\`\`

### Why This Matters

Without \`FHE.allowThis()\`, the contract cannot use the random value in a subsequent transaction — any attempt to operate on it will revert. Without \`FHE.allow(random, user)\`, the user cannot request reencryption or decryption of the value.

### Common ACL Pattern for Random Values

\`\`\`solidity
function generateAndStore() public {
    euint32 value = FHE.randEuint32();

    // Store it
    _storedValues[msg.sender] = value;

    // Grant permissions
    FHE.allowThis(value);               // Contract can use it
    FHE.allow(value, msg.sender);       // User can decrypt it
}
\`\`\`

### After Operations on Random Values

If you perform operations on a random value (e.g., \`FHE.rem()\`, \`FHE.add()\`), the result is a **new ciphertext** that needs its own ACL:

\`\`\`solidity
euint8 raw = FHE.randEuint8();
euint8 bounded = FHE.rem(raw, 6);
euint8 result = FHE.add(bounded, FHE.asEuint8(1));

// Only the final result needs ACL (intermediate values are transient)
FHE.allowThis(result);
FHE.allow(result, msg.sender);
\`\`\`

You do not need to set ACL on intermediate values (\`raw\`, \`bounded\`) unless you store them or need them later.

---

## 6. Practical Example: Encrypted Dice Roller

A complete contract implementing a fair, manipulation-proof dice roller:

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint8} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title EncryptedDiceRoller - Fair, front-running-proof dice
/// @notice Each player rolls an encrypted die. The result is hidden until decrypted.
contract EncryptedDiceRoller is ZamaEthereumConfig {

    /// @notice Stores the last dice roll for each player
    mapping(address => euint8) private _lastRoll;

    /// @notice Tracks total rolls per player
    mapping(address => uint256) public rollCount;

    /// @notice Emitted when a player rolls the dice
    event DiceRolled(address indexed player, uint256 rollNumber);

    /// @notice Roll a 6-sided die (result: 1-6, encrypted)
    function roll() external {
        // Step 1: Generate encrypted random value (0-255)
        euint8 raw = FHE.randEuint8();

        // Step 2: Bound to 0-5 using modulo
        euint8 zeroToFive = FHE.rem(raw, 6);

        // Step 3: Shift to 1-6 by adding 1
        euint8 diceResult = FHE.add(zeroToFive, FHE.asEuint8(1));

        // Step 4: Store the result
        _lastRoll[msg.sender] = diceResult;

        // Step 5: Set ACL permissions
        FHE.allowThis(diceResult);
        FHE.allow(diceResult, msg.sender);

        // Step 6: Track the roll
        rollCount[msg.sender]++;
        emit DiceRolled(msg.sender, rollCount[msg.sender]);
    }

    /// @notice Get the encrypted dice result handle (for reencryption)
    /// @dev Caller must have ACL permission (only the roller)
    function getLastRoll() external view returns (euint8) {
        require(FHE.isSenderAllowed(_lastRoll[msg.sender]), "No roll found");
        return _lastRoll[msg.sender];
    }
}
\`\`\`

### How It Works

1. **\`FHE.randEuint8()\`** generates a random encrypted 8-bit value (0–255)
2. **\`FHE.rem(raw, 6)\`** reduces it to the range 0–5 (encrypted modulo)
3. **\`FHE.add(..., 1)\`** shifts the range to 1–6
4. The result is stored and ACL permissions are set
5. The player can later decrypt their roll via reencryption (client-side) or the contract can call \`FHE.makePubliclyDecryptable()\` for public reveal

Nobody — not the contract, not the validator, not other players — can see the dice result until it is explicitly decrypted.

---

## 7. Practical Example: Encrypted Lottery

The bootcamp includes a complete \`EncryptedLottery.sol\` contract at \`contracts/EncryptedLottery.sol\`. Here is how it uses encrypted randomness:

### Key Design

\`\`\`solidity
/// @notice Draw a winner using encrypted randomness
function drawWinner() external onlyOwner {
    require(block.timestamp > deadline, "Lottery still open");
    require(!drawn, "Already drawn");
    require(players.length > 0, "No players");

    // Generate encrypted random index
    _winnerIndex = FHE.rem(FHE.randEuint32(), uint32(players.length));
    FHE.allowThis(_winnerIndex);
    FHE.allow(_winnerIndex, owner);

    drawn = true;
}
\`\`\`

### Lottery Flow

\`\`\`
1. Players buy tickets          → buyTicket() (payable)
2. Deadline passes              → No more ticket sales
3. Owner draws winner           → drawWinner() generates encrypted random index
4. Owner decrypts index         → makePubliclyDecryptable() reveals winner index
5. Owner reveals winner         → revealWinner(index) stores winner address
6. Winner claims prize          → claimPrize() sends ETH balance
\`\`\`

### Why This Is Secure

| Attack Vector | Protection |
|---------------|-----------|
| Owner sees random before committing | Random is encrypted — owner cannot see it |
| Owner redraws until favorable | \`drawn\` flag prevents redrawing |
| Player front-runs the draw | Random is generated in the draw tx, not predictable |
| Miner/validator manipulation | Encrypted value is hidden from block producers |

The owner must commit to the draw before knowing the outcome. The encrypted random index is only revealed through \`makePubliclyDecryptable()\` after the draw is finalized.

---

## 8. Use Cases

### Lottery and Raffle

Select winners fairly without any party knowing the outcome until the reveal:

\`\`\`solidity
euint32 winnerIndex = FHE.rem(FHE.randEuint32(), uint32(participantCount));
\`\`\`

### Gaming: Dice and Cards

Generate game outcomes that cannot be predicted or manipulated:

\`\`\`solidity
// Dice roll (1-6)
euint8 die = FHE.add(FHE.rem(FHE.randEuint8(), 6), FHE.asEuint8(1));

// Card draw (0-51)
euint8 card = FHE.rem(FHE.randEuint8(), 52);

// Coin flip
ebool heads = FHE.randEbool();
\`\`\`

### NFT Trait Randomization

Assign random traits at mint time without revealing them until the owner chooses:

\`\`\`solidity
function mint(address to) external {
    uint256 tokenId = _nextTokenId++;

    // Random traits, encrypted
    _strength[tokenId] = FHE.rem(FHE.randEuint8(), 100);    // 0-99
    _agility[tokenId] = FHE.rem(FHE.randEuint8(), 100);     // 0-99
    _rarity[tokenId] = FHE.rem(FHE.randEuint8(), 5);        // 0-4 (tiers)

    FHE.allowThis(_strength[tokenId]);
    FHE.allowThis(_agility[tokenId]);
    FHE.allowThis(_rarity[tokenId]);
    FHE.allow(_strength[tokenId], to);
    FHE.allow(_agility[tokenId], to);
    FHE.allow(_rarity[tokenId], to);
}
\`\`\`

### Encrypted Random Selection

Pick a random participant from a group without revealing who is selected until needed:

\`\`\`solidity
function selectRandomCommitteeMember(uint32 memberCount) external returns (euint32) {
    euint32 selected = FHE.rem(FHE.randEuint32(), memberCount);
    FHE.allowThis(selected);
    return selected;
}
\`\`\`

### Shuffling (Fisher-Yates Style)

While a full encrypted shuffle is expensive, you can generate random swap indices:

\`\`\`solidity
// Generate N random indices for a Fisher-Yates shuffle
function generateShuffleIndices(uint32 n) external {
    for (uint32 i = 0; i < n; i++) {
        _shuffleIndices[i] = FHE.rem(FHE.randEuint32(), n - i);
        FHE.allowThis(_shuffleIndices[i]);
    }
}
\`\`\`

---

## 9. Gas Considerations

FHE operations are significantly more expensive than standard Solidity operations. Random generation is no exception.

### Relative Gas Costs by Type

| Function | Relative Cost | Recommendation |
|----------|--------------|----------------|
| \`FHE.randEbool()\` | Lowest | Use for binary outcomes (coin flip) |
| \`FHE.randEuint8()\` | Low | Use for small ranges (dice, cards, percentages) |
| \`FHE.randEuint16()\` | Medium | Use for medium ranges (0–65535) |
| \`FHE.randEuint32()\` | Higher | Use for large ranges or array indexing |
| \`FHE.randEuint64()\` | Highest | Use only when you need the full 64-bit range |

### Optimization Tips

**Tip 1: Use the smallest type that fits your range**

\`\`\`solidity
// WASTEFUL: 64-bit random for a dice roll
euint64 die = FHE.rem(FHE.randEuint64(), 6);  // Expensive

// EFFICIENT: 8-bit random for a dice roll
euint8 die = FHE.rem(FHE.randEuint8(), 6);    // Much cheaper
\`\`\`

**Tip 2: Generate once, use multiple times**

If you need multiple bounded values from the same source type, consider whether a single random generation can be split (though this must be done carefully to maintain independence).

\`\`\`solidity
// Two independent rolls — two generations required
euint8 die1 = FHE.rem(FHE.randEuint8(), 6);
euint8 die2 = FHE.rem(FHE.randEuint8(), 6);
\`\`\`

**Tip 3: Minimize chained operations on random values**

Each FHE operation adds gas cost. Keep the chain short:

\`\`\`solidity
// Acceptable: 2 operations (rem + add)
euint8 result = FHE.add(FHE.rem(FHE.randEuint8(), 6), FHE.asEuint8(1));

// Avoid: unnecessary intermediate steps
euint8 raw = FHE.randEuint8();
euint8 temp1 = FHE.rem(raw, 12);
euint8 temp2 = FHE.div(temp1, 2);  // Extra operations (div is scalar-only)
\`\`\`

**Tip 4: Use \`FHE.randEbool()\` for binary decisions**

\`\`\`solidity
// WASTEFUL: Generating a number just to check even/odd
euint8 rand = FHE.randEuint8();
ebool isHeads = FHE.eq(FHE.rem(rand, 2), FHE.asEuint8(0));

// EFFICIENT: Direct boolean generation
ebool isHeads = FHE.randEbool();
\`\`\`

---

## 10. Security Considerations

### Front-Running Prevention

In traditional randomness schemes, the random value becomes public at some point during the transaction lifecycle. MEV bots and front-runners exploit this window. With FHE randomness:

- The random value is **never in the mempool** in plaintext
- The random value is **never in calldata** (it is generated on-chain)
- The random value is **never visible in the block** until explicitly decrypted
- There is **no window of opportunity** for front-running

### Manipulation Resistance

| Actor | Traditional Randomness | FHE Randomness |
|-------|----------------------|----------------|
| Block producer | Can see value, reorder/censor txs | Cannot see value |
| Validator | Knows prevrandao, can manipulate | Cannot see value |
| MEV bot | Can front-run based on visible outcome | Nothing to front-run |
| Contract owner | Can see value in callback | Value is encrypted until decrypted |
| Other users | Can read from chain/mempool | Cannot read encrypted value |

### Commit-Reveal No Longer Needed

Traditional fair randomness often requires a **commit-reveal** pattern:

1. Players commit hashed choices
2. Wait for all commits
3. Players reveal their choices
4. Combine reveals to produce randomness

This is complex, requires multiple rounds of interaction, and fails if any player refuses to reveal. FHE randomness eliminates the need for commit-reveal entirely — the randomness is fair in a single transaction.

### Decryption Timing

The random value remains encrypted until you explicitly make it publicly decryptable or grant ACL access. Design your contract so that:

- All game-changing state updates happen **before** decryption
- The random value cannot be used to gain an advantage between generation and reveal
- Decryption results are handled carefully after reveal

---

## 11. Common Pitfalls

### Pitfall 1: Forgetting ACL After Generation

\`\`\`solidity
// BUG: No ACL set — value is unusable
function broken() public {
    euint32 rand = FHE.randEuint32();
    _stored = rand;
    // Missing: FHE.allowThis(rand);
    // Next transaction using _stored will REVERT
}

// CORRECT: Always set ACL
function correct() public {
    euint32 rand = FHE.randEuint32();
    _stored = rand;
    FHE.allowThis(rand);
    FHE.allow(rand, msg.sender);
}
\`\`\`

### Pitfall 2: Using a Type Larger Than Needed

\`\`\`solidity
// WASTEFUL: euint64 for a coin flip
euint64 big = FHE.randEuint64();
ebool coin = FHE.ne(FHE.rem(big, 2), FHE.asEuint64(0));

// EFFICIENT: Use randEbool directly
ebool coin = FHE.randEbool();
\`\`\`

### Pitfall 3: Forgetting ACL After Operations on Random Values

Operations on random values produce **new ciphertexts** that need their own ACL:

\`\`\`solidity
// BUG: ACL is set on raw, not on result
euint8 raw = FHE.randEuint8();
FHE.allowThis(raw);  // ACL on the raw value

euint8 result = FHE.rem(raw, 6);
// result has a DIFFERENT handle — no ACL!
// Missing: FHE.allowThis(result);
\`\`\`

### Pitfall 4: Assuming the Contract Can Read Random Values

\`\`\`solidity
// IMPOSSIBLE: Contract cannot read encrypted values
function broken() public {
    euint32 rand = FHE.randEuint32();
    // You CANNOT do this:
    // uint32 value = decrypt(rand);  // No synchronous decrypt
    // if (value > 100) { ... }       // Cannot branch on encrypted values
}

// CORRECT: Use encrypted operations or makePubliclyDecryptable for reveal
function correct() public {
    euint32 rand = FHE.randEuint32();
    ebool isLarge = FHE.gt(rand, FHE.asEuint32(100));
    euint32 result = FHE.select(isLarge, rand, FHE.asEuint32(0));
    FHE.allowThis(result);
}
\`\`\`

### Pitfall 5: Modulo Bias with Small Source Types

\`\`\`solidity
// BIASED: 256 values mapped to 100 buckets (256 % 100 = 56)
// Values 0-55 are ~2.4% more likely than 56-99
euint8 percent = FHE.rem(FHE.randEuint8(), 100);

// BETTER: Use a larger source type for better uniformity
euint32 percent = FHE.rem(FHE.randEuint32(), 100);
// 4,294,967,296 values mapped to 100 buckets — bias is negligible
\`\`\`

### Pitfall 6: Using \`randomEuint32\` Instead of \`randEuint32\`

\`\`\`solidity
// WRONG: This function name does not exist
euint32 rand = FHE.randomEuint32();  // COMPILATION ERROR

// CORRECT: Use the 'rand' prefix
euint32 rand = FHE.randEuint32();
\`\`\`

---

## 12. Combining Randomness with Other FHE Patterns

### Random + Conditional Logic (Module 08)

Use \`FHE.select()\` with random values:

\`\`\`solidity
function randomReward() public {
    euint32 roll = FHE.rem(FHE.randEuint32(), 100);
    euint32 threshold = FHE.asEuint32(10);  // 10% chance

    ebool isRare = FHE.lt(roll, threshold);
    euint32 reward = FHE.select(isRare, FHE.asEuint32(1000), FHE.asEuint32(100));

    _rewards[msg.sender] = FHE.add(_rewards[msg.sender], reward);
    FHE.allowThis(_rewards[msg.sender]);
    FHE.allow(_rewards[msg.sender], msg.sender);
}
\`\`\`

### Random + Encrypted Input (Module 06)

Combine user input with randomness:

\`\`\`solidity
function playGame(externalEuint8 encryptedGuess, bytes calldata inputProof) external {
    euint8 guess = FHE.fromExternal(encryptedGuess, inputProof);
    euint8 target = FHE.rem(FHE.randEuint8(), 10);  // 0-9

    ebool correct = FHE.eq(guess, target);
    _results[msg.sender] = correct;
    FHE.allowThis(correct);
    FHE.allow(correct, msg.sender);
}
\`\`\`

### Random + Decryption (Module 07)

Make a random result publicly decryptable or share via ACL:

\`\`\`solidity
contract RevealableRandom is ZamaEthereumConfig {
    euint32 private _encryptedResult;
    bool public revealed;

    function generate() public {
        _encryptedResult = FHE.rem(FHE.randEuint32(), 100);
        FHE.allowThis(_encryptedResult);
        FHE.allow(_encryptedResult, msg.sender);
    }

    function revealPublicly() public {
        FHE.makePubliclyDecryptable(_encryptedResult);
        revealed = true;
    }
}
\`\`\`

After \`makePubliclyDecryptable()\`, any user can decrypt the result client-side via reencryption.

---

## Summary

| Concept | Details |
|---------|---------|
| **\`FHE.randEbool()\`** | Encrypted random boolean (true/false) |
| **\`FHE.randEuint8()\`** | Encrypted random 8-bit integer (0–255) |
| **\`FHE.randEuint16()\`** | Encrypted random 16-bit integer (0–65,535) |
| **\`FHE.randEuint32()\`** | Encrypted random 32-bit integer (0–4.29B) |
| **\`FHE.randEuint64()\`** | Encrypted random 64-bit integer (0–18.4Q) |
| **\`FHE.randEuint128()\`** | Encrypted random 128-bit integer (0–2^128-1) |
| **\`FHE.randEuint256()\`** | Encrypted random 256-bit integer (0–2^256-1) |
| **\`FHE.rem(value, max)\`** | Bound random to range [0, max) |
| **ACL required** | Always call \`FHE.allowThis()\` and \`FHE.allow()\` after generation |
| **Synchronous** | Random values available in the same transaction |
| **Encrypted** | Nobody can see the value until explicitly decrypted |
| **Manipulation-proof** | Block producers, validators, MEV bots cannot exploit the value |
| **Use smallest type** | \`euint8\` for small ranges, \`euint64\` only when needed |
| **Modulo bias** | Negligible when source type is much larger than the range |

**Key principles:**
1. FHE randomness is the strongest on-chain randomness — values are encrypted at creation
2. Use \`FHE.rem()\` to bound values to a specific range
3. Always set ACL permissions on generated random values
4. Choose the smallest type that fits your use case for gas efficiency
5. Operations on random values produce new ciphertexts — set ACL on the final result
6. Combine with \`FHE.select()\` for conditional logic and Gateway for decryption
`,
  "10-frontend-integration": `# Module 10: Frontend Integration -- Lesson

## Introduction

So far we have written and tested FHEVM contracts using Hardhat. In a real application, users interact through a web frontend. This module covers everything needed to connect a React + ethers.js dApp to FHEVM contracts using the **Relayer SDK (\`@zama-fhe/relayer-sdk\`)**.

The key challenges are:
1. The frontend must **encrypt** values before sending them as transaction parameters
2. The frontend must **request decryption** to display encrypted on-chain data to the user
3. External encrypted types (\`externalEuint32\`, etc.) bridge the gap between off-chain and on-chain

---

## 1. Architecture Overview

\`\`\`
Browser (React + Relayer SDK)
    |
    |-- 1. Initialize FHE instance (fetches public key from chain)
    |-- 2. Encrypt plaintext inputs client-side
    |-- 3. Send encrypted inputs as tx params (externalEuintXX)
    |
    v
FHEVM Contract
    |
    |-- 4. FHE.fromExternal(input, inputProof) converts to euintXX
    |-- 5. Perform FHE operations
    |-- 6. Store encrypted results with ACL
    |
    v
Gateway (for decryption)
    |
    |-- 7. User requests decryption via Relayer SDK
    |-- 8. Gateway re-encrypts for user's keypair
    |-- 9. Frontend decrypts and displays
\`\`\`

---

## 2. Installing the Relayer SDK

\`\`\`bash
npm install @zama-fhe/relayer-sdk ethers
\`\`\`

For a React project (Vite):

\`\`\`bash
npm create vite@latest my-fhevm-app -- --template react-ts
cd my-fhevm-app
npm install @zama-fhe/relayer-sdk ethers
\`\`\`

---

## 3. Initializing the FHE Instance

The FHE instance must be created once and reused. It fetches the network's FHE public key.

\`\`\`typescript
import { createInstance } from "@zama-fhe/relayer-sdk/web";
import { BrowserProvider } from "ethers";

let fheInstance: Awaited<ReturnType<typeof createInstance>> | null = null;

async function initFhevm(): Promise<typeof fheInstance> {
  if (fheInstance) return fheInstance;

  const provider = new BrowserProvider(window.ethereum);

  fheInstance = await createInstance({
    network: await provider.send("eth_chainId", []),
    relayerUrl: "https://gateway.zama.ai",
  });

  return fheInstance;
}
\`\`\`

> **Important:** The instance caches the FHE public key. You only need to initialize once per page load.

---

## 4. The SimpleCounter Contract

Here is the contract we will connect to from the frontend:

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract SimpleCounter is ZamaEthereumConfig {
    mapping(address => euint32) private _counts;

    event CountIncremented(address indexed user);

    function increment(externalEuint32 encValue, bytes calldata inputProof) external {
        euint32 value = FHE.fromExternal(encValue, inputProof);
        _counts[msg.sender] = FHE.add(_counts[msg.sender], value);
        FHE.allowThis(_counts[msg.sender]);
        FHE.allow(_counts[msg.sender], msg.sender);
        emit CountIncremented(msg.sender);
    }

    function getMyCount() external view returns (euint32) {
        return _counts[msg.sender];
    }
}
\`\`\`

Key points:
- The contract uses a per-user \`mapping(address => euint32)\` so each user has their own private counter
- The \`increment\` function accepts \`externalEuint32\` and \`bytes calldata inputProof\` -- these are the encrypted handle and input proof that come from the frontend
- \`FHE.fromExternal(encValue, inputProof)\` converts the external type to a usable \`euint32\`
- \`getMyCount()\` returns the caller's encrypted count handle (for re-encryption/decryption)
- ACL is set for both the contract (\`allowThis\`) and the user (\`allow\`)

---

## 5. Creating Encrypted Inputs

On the frontend, use the Relayer SDK to encrypt a plaintext value before sending it in a transaction:

\`\`\`typescript
async function encryptAmount(
  amount: number,
  contractAddress: string,
  userAddress: string
) {
  const instance = await initFhevm();

  // Create an encrypted input bound to this contract and user
  const input = instance.createEncryptedInput(contractAddress, userAddress);
  input.add32(amount); // add a 32-bit encrypted value

  const encrypted = await input.encrypt();
  // encrypted.handles[0] = the encrypted handle (bytes32)
  // encrypted.inputProof = the ZK proof (bytes)
  return encrypted;
}
\`\`\`

The \`createEncryptedInput\` method binds the encrypted value to a specific contract address and user address. This prevents replay attacks.

Available input methods:
- \`input.addBool(value)\` -- encrypt a boolean
- \`input.add8(value)\` -- encrypt a uint8
- \`input.add16(value)\` -- encrypt a uint16
- \`input.add32(value)\` -- encrypt a uint32
- \`input.add64(value)\` -- encrypt a uint64
- \`input.add128(value)\` -- encrypt a uint128
- \`input.add256(value)\` -- encrypt a uint256
- \`input.addAddress(value)\` -- encrypt an address

---

## 6. Sending Encrypted Transactions

\`\`\`typescript
import { Contract, BrowserProvider } from "ethers";

const COUNTER_ABI = [
  "function increment(bytes32 encValue, bytes calldata inputProof) external",
  "function getMyCount() external view returns (uint256)",
];

async function incrementCounter(amount: number) {
  const provider = new BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const userAddress = await signer.getAddress();

  const contract = new Contract(COUNTER_ADDRESS, COUNTER_ABI, signer);

  // Encrypt the amount
  const encrypted = await encryptAmount(amount, COUNTER_ADDRESS, userAddress);

  // Send the transaction with the encrypted handle and input proof
  const tx = await contract.increment(encrypted.handles[0], encrypted.inputProof);
  await tx.wait();

  console.log("Counter incremented!");
}
\`\`\`

> **Note:** On the ABI level, \`externalEuint32\` appears as \`bytes32\` (the handle), and the proof is \`bytes\`. The contract only has \`increment()\` -- there is no \`decrement()\` function. Each user has their own counter via a per-user mapping.

---

## 7. Requesting Decryption

To read an encrypted value, the user must request decryption through the relayer:

\`\`\`typescript
async function readCounter(): Promise<number> {
  const provider = new BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const userAddress = await signer.getAddress();

  const contract = new Contract(COUNTER_ADDRESS, COUNTER_ABI, signer);
  const instance = await initFhevm();

  // Get the encrypted handle from the contract
  const encryptedHandle = await contract.getMyCount();

  // Request re-encryption for this user
  // The user must sign a message to prove they have ACL access
  const { publicKey, privateKey } = instance.generateKeypair();
  const eip712 = instance.createEIP712(publicKey, COUNTER_ADDRESS);
  const signature = await signer.signTypedData(
    eip712.domain,
    eip712.types,
    eip712.message
  );

  const decryptedValue = await instance.reencrypt(
    encryptedHandle,
    privateKey,
    publicKey,
    signature,
    COUNTER_ADDRESS,
    userAddress
  );

  return Number(decryptedValue);
}
\`\`\`

The decryption flow:
1. The contract returns an encrypted handle (a \`uint256\` reference to the ciphertext)
2. The user generates a temporary keypair
3. The user signs an EIP-712 message to prove ACL access
4. The gateway re-encrypts the ciphertext with the user's temporary public key
5. The frontend decrypts with the temporary private key

---

## 8. React Component Pattern

Here is a complete React component that ties everything together:

\`\`\`tsx
import { useState, useEffect } from "react";

function CounterApp() {
  const [counter, setCounter] = useState<number | null>(null);
  const [amount, setAmount] = useState<number>(1);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    refreshCounter();
  }, []);

  async function refreshCounter() {
    try {
      const value = await readCounter();
      setCounter(value);
    } catch (err) {
      console.error("Failed to read counter:", err);
    }
  }

  async function handleIncrement() {
    setLoading(true);
    try {
      await incrementCounter(amount);
      await refreshCounter();
    } catch (err) {
      console.error("Increment failed:", err);
    }
    setLoading(false);
  }

  return (
    <div>
      <h1>Encrypted Counter</h1>
      <p>Your counter value: {counter !== null ? counter : "Loading..."}</p>
      <input
        type="number"
        value={amount}
        onChange={(e) => setAmount(Number(e.target.value))}
        min={1}
      />
      <button onClick={handleIncrement} disabled={loading}>
        + Increment
      </button>
      <button onClick={refreshCounter} disabled={loading}>
        Refresh
      </button>
    </div>
  );
}
\`\`\`

---

## 9. External Types: The Bridge

When encrypted data crosses the contract boundary (from frontend to contract), it uses **external types**:

| External Type | Internal Type | Conversion |
|--------------|---------------|------------|
| \`externalEbool\` | \`ebool\` | \`FHE.fromExternal(val, inputProof)\` |
| \`externalEuint8\` | \`euint8\` | \`FHE.fromExternal(val, inputProof)\` |
| \`externalEuint16\` | \`euint16\` | \`FHE.fromExternal(val, inputProof)\` |
| \`externalEuint32\` | \`euint32\` | \`FHE.fromExternal(val, inputProof)\` |
| \`externalEuint64\` | \`euint64\` | \`FHE.fromExternal(val, inputProof)\` |
| \`externalEuint128\` | \`euint128\` | \`FHE.fromExternal(val, inputProof)\` |
| \`externalEuint256\` | \`euint256\` | \`FHE.fromExternal(val, inputProof)\` |
| \`externalEaddress\` | \`eaddress\` | \`FHE.fromExternal(val, inputProof)\` |

The pattern is always:
1. Contract function parameters: \`externalEuintXX\` and \`bytes calldata inputProof\`
2. First line inside function: \`euintXX val = FHE.fromExternal(externalVal, inputProof);\`
3. Then use \`val\` normally with FHE operations

---

## 10. Error Handling and Best Practices

### Always Initialize Before Encrypting

\`\`\`typescript
// BAD: might fail if instance not ready
const encrypted = instance.createEncryptedInput(...);

// GOOD: ensure initialization
const instance = await initFhevm();
const encrypted = instance.createEncryptedInput(...);
\`\`\`

### Handle Wallet Connection

\`\`\`typescript
async function connectWallet(): Promise<string> {
  if (!window.ethereum) {
    throw new Error("MetaMask not detected");
  }
  const accounts = await window.ethereum.request({
    method: "eth_requestAccounts",
  });
  return accounts[0];
}
\`\`\`

### Cache Decrypted Values

Decryption requests go through the relayer and require a signature. Cache results when appropriate:

\`\`\`typescript
const decryptionCache = new Map<string, number>();

async function cachedDecrypt(handle: bigint): Promise<number> {
  const key = handle.toString();
  if (decryptionCache.has(key)) {
    return decryptionCache.get(key)!;
  }
  const value = await readCounter();
  decryptionCache.set(key, value);
  return value;
}
\`\`\`

### Clear Cache on State Changes

After any write transaction, invalidate cached values:

\`\`\`typescript
async function handleIncrement() {
  await incrementCounter(amount);
  decryptionCache.clear(); // Invalidate cache
  await refreshCounter();
}
\`\`\`

---

## Frontend vs. Hardhat Test: Decryption Differences

The encryption flow is the same in both environments, but **decryption differs**:

| Environment | SDK | Decrypt Method |
|-------------|-----|----------------|
| **Browser (Frontend)** | Relayer SDK (\`@zama-fhe/relayer-sdk\`) | \`instance.reencrypt()\` with keypair + EIP-712 signature |
| **Hardhat Tests** | \`@fhevm/hardhat-plugin\` | \`fhevm.userDecryptEuint(FhevmType.euint32, handle, contractAddr, signer)\` |

In Hardhat tests, the \`fhevm\` object is available via \`import { ethers, fhevm } from "hardhat"\` and provides a simpler API for testing purposes:

\`\`\`typescript
import { ethers, fhevm } from "hardhat";
import { FhevmType } from "@fhevm/hardhat-plugin";

// Decrypt in tests
const clear = await fhevm.userDecryptEuint(
  FhevmType.euint32,
  encryptedHandle,
  contractAddress,
  signer
);
\`\`\`

The \`FhevmType\` enum maps to the encrypted types: \`FhevmType.ebool\`, \`FhevmType.euint8\`, \`FhevmType.euint16\`, \`FhevmType.euint32\`, \`FhevmType.euint64\`, \`FhevmType.euint128\`, \`FhevmType.euint256\`, \`FhevmType.eaddress\`.

---

### Alternative: Public Decryption

For values that should be readable by **everyone** (e.g., auction results, vote tallies), use \`FHE.makePubliclyDecryptable()\` instead of the re-encryption flow:

\`\`\`solidity
// In the contract
FHE.makePubliclyDecryptable(encryptedResult);
\`\`\`

After calling \`makePubliclyDecryptable()\`, any user can decrypt the value without needing ACL access or the re-encryption protocol. This is simpler but removes privacy — use it only for values that should become public.

---

## Summary

- The **Relayer SDK (\`@zama-fhe/relayer-sdk\`)** provides the client-side tools for encrypting inputs and decrypting outputs
- Use \`createEncryptedInput()\` to encrypt values bound to a specific contract and user
- Contract parameters use \`externalEuintXX\` and \`bytes calldata inputProof\` types; convert with \`FHE.fromExternal(val, inputProof)\`
- Decryption requires EIP-712 signatures to prove ACL access
- The relayer re-encrypts ciphertexts for the user's temporary keypair
- Always initialize the FHE instance before performing any operations
- Cache decryption results and invalidate on state changes
`,
  "11-project-erc20": `# Module 11: Confidential ERC-20 -- Lesson

## Introduction

A standard ERC-20 token exposes all balances and transfer amounts publicly on-chain. Anyone can see how much every address holds and every transfer that occurs. With FHEVM, we can build an ERC-20 where **balances are encrypted** and **transfer amounts are hidden**, while still preserving the core ERC-20 functionality.

---

## 1. The Privacy Problem with Standard ERC-20

In a standard ERC-20:
- \`balanceOf(address)\` returns a plaintext \`uint256\` -- anyone can query any address
- \`Transfer\` events log the exact amount -- block explorers show everything
- Failed transfers revert with an error -- an attacker can binary-search balances

With a confidential ERC-20:
- Balances are stored as \`euint64\` -- only the owner can decrypt
- Transfer amounts are encrypted -- observers see nothing
- Failed transfers **do not revert** -- they silently transfer 0

---

## 2. Core Design: Encrypted Mapping

\`\`\`solidity
mapping(address => euint64) private _balances;
\`\`\`

Each balance is an encrypted 64-bit unsigned integer. Only the balance owner (and the contract itself) have ACL access.

---

## 3. The No-Revert Pattern

This is the most critical privacy pattern in FHEVM token design.

**Why can we not revert on insufficient balance?**

If \`transfer(to, amount)\` reverts when \`balance < amount\`, an attacker can:
1. Try transferring 1000 -- reverts (balance < 1000)
2. Try transferring 500 -- succeeds (balance >= 500)
3. Try transferring 750 -- reverts (balance < 750)
4. Binary search to find the exact balance

**Solution: Always succeed, but transfer 0 on failure.**

\`\`\`solidity
function _transfer(address from, address to, euint64 amount) internal {
    // Check if sender has enough
    ebool hasEnough = FHE.ge(_balances[from], amount);

    // If has enough, transfer \`amount\`. If not, transfer 0.
    euint64 transferAmount = FHE.select(hasEnough, amount, FHE.asEuint64(0));

    // Update balances
    _balances[from] = FHE.sub(_balances[from], transferAmount);
    _balances[to] = FHE.add(_balances[to], transferAmount);

    // Update ACL
    FHE.allowThis(_balances[from]);
    FHE.allow(_balances[from], from);
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);
}
\`\`\`

From the outside, the transaction always succeeds. Nobody can tell if the actual transfer was the requested amount or 0.

---

## 4. Complete ConfidentialERC20 Contract

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract ConfidentialERC20 is ZamaEthereumConfig {
    string public name;
    string public symbol;
    uint8 public constant decimals = 6;
    uint64 public totalSupply;

    mapping(address => euint64) private _balances;
    mapping(address => mapping(address => euint64)) private _allowances;
    mapping(address => bool) private _initialized;

    event Transfer(address indexed from, address indexed to);
    event Approval(address indexed owner, address indexed spender);

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function _initBalance(address account) internal {
        if (!_initialized[account]) {
            _balances[account] = FHE.asEuint64(0);
            FHE.allowThis(_balances[account]);
            FHE.allow(_balances[account], account);
            _initialized[account] = true;
        }
    }

    function balanceOf(address account) public view returns (euint64) {
        return _balances[account];
    }

    function transfer(externalEuint64 encryptedAmount, bytes calldata inputProof, address to) external {
        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);
        _transfer(msg.sender, to, amount);
        emit Transfer(msg.sender, to);
    }

    function _transfer(address from, address to, euint64 amount) internal {
        _initBalance(from);
        _initBalance(to);

        // Privacy-preserving: transfer amount or 0 (no revert)
        ebool hasEnough = FHE.ge(_balances[from], amount);
        euint64 transferAmount = FHE.select(hasEnough, amount, FHE.asEuint64(0));

        _balances[from] = FHE.sub(_balances[from], transferAmount);
        _balances[to] = FHE.add(_balances[to], transferAmount);

        FHE.allowThis(_balances[from]);
        FHE.allow(_balances[from], from);
        FHE.allowThis(_balances[to]);
        FHE.allow(_balances[to], to);
    }

    function approve(externalEuint64 encryptedAmount, bytes calldata inputProof, address spender) external {
        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);
        _allowances[msg.sender][spender] = amount;
        FHE.allowThis(_allowances[msg.sender][spender]);
        FHE.allow(_allowances[msg.sender][spender], msg.sender);
        FHE.allow(_allowances[msg.sender][spender], spender);
        emit Approval(msg.sender, spender);
    }

    function allowance(address owner) public view returns (euint64) {
        return _allowances[owner][msg.sender];
    }

    function transferFrom(address from, externalEuint64 encryptedAmount, bytes calldata inputProof, address to) external {
        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);

        // Check allowance
        euint64 currentAllowance = _allowances[from][msg.sender];
        ebool hasAllowance = FHE.ge(currentAllowance, amount);

        // Check balance
        ebool hasBalance = FHE.ge(_balances[from], amount);

        // Both conditions must be true
        ebool canTransfer = FHE.and(hasAllowance, hasBalance);
        euint64 transferAmount = FHE.select(canTransfer, amount, FHE.asEuint64(0));

        // Update allowance
        _allowances[from][msg.sender] = FHE.sub(currentAllowance, transferAmount);
        FHE.allowThis(_allowances[from][msg.sender]);
        FHE.allow(_allowances[from][msg.sender], from);
        FHE.allow(_allowances[from][msg.sender], msg.sender);

        // Perform transfer
        _transfer(from, to, transferAmount);
        emit Transfer(from, to);
    }
}
\`\`\`

---

## 5. Key Design Decisions Explained

### \`balanceOf(address)\` Returns an Encrypted Handle

Unlike a standard ERC-20 where \`balanceOf(address)\` returns a plaintext \`uint256\` anyone can read, the confidential version returns an \`euint64\` encrypted handle. The function takes an \`address account\` parameter, but only the account owner (who has ACL access) can decrypt the returned value. Anyone can call the function, but the returned ciphertext is useless without the decryption permission granted via \`FHE.allow()\`.

### Events Without Amounts

\`\`\`solidity
event Transfer(address indexed from, address indexed to);
// Note: no amount field!
\`\`\`

Standard ERC-20 events include the amount. We omit it because the amount is encrypted and should not be leaked.

### \`totalSupply\` is Public

The total supply is plaintext. This is a design choice -- you could encrypt it too, but most tokens benefit from a publicly verifiable supply.

### Why \`uint64\` Instead of \`uint256\`?

FHE operations on larger types are more expensive. \`euint64\` supports up to ~18.4 quintillion, which is sufficient for most token designs (especially with 6 decimals).

---

## 6. The Transfer Flow Step by Step

\`\`\`
1. User calls transfer(encryptedAmount, proof, to)
2. FHE.fromExternal() converts to euint64
3. FHE.ge(balance, amount) -> ebool hasEnough
4. FHE.select(hasEnough, amount, 0) -> transferAmount
5. balance[from] = balance[from] - transferAmount
6. balance[to] = balance[to] + transferAmount
7. ACL updated for both from and to
8. Transaction succeeds regardless of outcome
\`\`\`

An observer sees:
- That a transaction occurred between \`from\` and \`to\`
- That it succeeded
- Nothing about the amount or whether it was a "real" transfer or a 0-transfer

---

## 7. Allowance Pattern

The allowance system works similarly to standard ERC-20 but with encrypted amounts:

\`\`\`solidity
// Owner approves spender for encrypted amount
approve(encryptedAmount, proof, spender)

// Spender can check their allowance (only they can decrypt)
allowance(owner) -> euint64

// Spender transfers from owner's balance
transferFrom(from, encryptedAmount, proof, to)
\`\`\`

The \`transferFrom\` checks both:
1. \`allowance >= amount\` (encrypted comparison)
2. \`balance >= amount\` (encrypted comparison)

Both must pass (using \`FHE.and()\`), or the transfer sends 0.

> **Design Note:** Our simplified \`allowance(address owner)\` uses \`msg.sender\` as the implicit spender. An alternative design accepts both parameters: \`allowance(address owner, address spender)\`, which is closer to the ERC-20 standard but requires additional ACL considerations.

---

## 8. Minting Pattern

For initial distribution or minting:

\`\`\`solidity
function mint(address to, uint64 amount) public onlyOwner {
    _initBalance(to);
    _balances[to] = FHE.add(_balances[to], FHE.asEuint64(amount));
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);
    totalSupply += amount;
}
\`\`\`

Note that \`amount\` is plaintext here (the owner knows how much they are minting). If you want private minting, accept an \`externalEuint64\` instead.

---

## 9. Frontend Integration

On the frontend, transfers look like:

\`\`\`typescript
async function transfer(to: string, amount: number) {
  const instance = await initFhevm();
  const input = instance.createEncryptedInput(tokenAddress, userAddress);
  input.add64(amount);
  const encrypted = await input.encrypt();

  const tx = await contract.transfer(encrypted.handles[0], encrypted.inputProof, to);
  await tx.wait();
}
\`\`\`

Reading balance:

\`\`\`typescript
async function getBalance(account: string): Promise<number> {
  const handle = await contract.balanceOf(account);
  // ... EIP-712 signature + reencrypt flow
  return Number(decryptedValue);
}
\`\`\`

---

## ERC-20 Compatibility Tradeoffs

Our Confidential ERC-20 intentionally breaks standard ERC-20 compatibility:

| Feature | Standard ERC-20 | Confidential ERC-20 |
|---------|----------------|---------------------|
| \`balanceOf\` return | \`uint256\` | \`euint64\` |
| \`transfer\` amount param | \`uint256\` | \`externalEuint64 + proof\` |
| Transfer events | Include amount | No amount (would leak data) |
| Failed transfer | Reverts | Returns silently (0 transfer) |
| \`totalSupply\` | Public | Can be public or encrypted |

These changes are necessary for privacy but mean the contract cannot be used with existing ERC-20 tooling (DEX routers, block explorers, etc.) without adaptation.

> **Industry Standard:** The confidential ERC-20 pattern taught in this module is formalized as **ERC-7984** — a standard co-developed by Zama and OpenZeppelin for confidential fungible tokens. Zaiffer Protocol (a Zama + PyratzLabs joint venture, €2M backing) uses this exact pattern in production to convert standard ERC-20 tokens into confidential cTokens with encrypted balances. The OpenZeppelin audit was completed in November 2025.

---

## Summary

- Confidential ERC-20 stores balances as \`euint64\` in encrypted mappings
- The **no-revert pattern** is essential: failed transfers send 0 instead of reverting
- \`FHE.select()\` is the core primitive for conditional transfer logic
- Events omit amounts to prevent information leakage
- \`balanceOf(address)\` returns an encrypted handle -- only the account owner with ACL access can decrypt it
- Allowances are also encrypted, with ACL granted to both owner and spender
- \`FHE.and()\` combines multiple conditions (balance check + allowance check)
`,
  "12-project-voting": `# Module 12: Confidential Voting -- Lesson

## Introduction

Voting is one of the most compelling use cases for FHE on blockchain. In traditional on-chain voting (e.g., governance DAOs), every vote is publicly visible. This creates problems:
- **Voter coercion** -- someone can verify how you voted
- **Bandwagon effects** -- seeing partial results influences voters
- **Front-running** -- last-minute strategic voting based on current tallies

With FHEVM, we can build a voting system where **individual votes are never revealed** and **tallies remain encrypted** until the election ends.

---

## 1. Design Overview

\`\`\`
Voting Lifecycle:
1. Owner creates a proposal with a description and duration
2. Voting period opens immediately (deadline = now + duration)
3. Voters submit encrypted votes (0 = no, 1 = yes)
4. Nobody can see tallies during voting
5. Deadline passes -- voting closes
6. Results can be revealed (decrypted)
\`\`\`

---

## 2. The Vote Encoding

Each vote is an encrypted \`euint8\` value: \`1\` for yes, \`0\` for no. Inside the contract, we use \`FHE.eq()\` to compare the encrypted vote against \`1\`, producing an \`ebool\`. We then use \`FHE.select()\` to add 1 to the matching tally and 0 to the other.

**Why \`euint8\` instead of \`ebool\`?** Using \`euint8\` is more flexible -- it supports multi-option voting later (e.g., 0, 1, 2, 3 for four options) without changing the function signature.

\`\`\`solidity
// For a Yes/No vote:
// Vote value 1 (yes): yesCount += 1, noCount += 0
// Vote value 0 (no):  yesCount += 0, noCount += 1
\`\`\`

This approach ensures that no matter what the voter chooses, the same operations happen on all tallies -- an observer cannot tell which option was selected.

---

## 3. Duplicate Vote Prevention

We must prevent double voting. Since we cannot use encrypted data for this (the contract needs to know definitively who voted), we use a plaintext mapping:

\`\`\`solidity
mapping(uint256 => mapping(address => bool)) public hasVoted;
\`\`\`

This reveals **that** someone voted, but not **how** they voted. This is an acceptable trade-off -- in most voting systems, voter participation is public.

---

## 4. Complete ConfidentialVoting Contract

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, euint8, externalEuint8, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title ConfidentialVoting - Module 12: Private on-chain voting
/// @notice Vote tallies are encrypted until reveal. No one can see individual votes.
contract ConfidentialVoting is ZamaEthereumConfig {
    struct Proposal {
        string description;
        euint32 yesVotes;
        euint32 noVotes;
        uint256 deadline;
        bool revealed;
        uint32 yesResult;
        uint32 noResult;
    }

    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => mapping(address => bool)) public hasVoted;
    uint256 public proposalCount;
    address public owner;

    event ProposalCreated(uint256 indexed proposalId, string description, uint256 deadline);
    event VoteCast(uint256 indexed proposalId, address indexed voter);
    event ResultRevealed(uint256 indexed proposalId, uint32 yesVotes, uint32 noVotes);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    /// @notice Create a new proposal with a voting deadline
    function createProposal(string calldata description, uint256 duration) external onlyOwner {
        uint256 id = proposalCount++;
        proposals[id].description = description;
        proposals[id].yesVotes = FHE.asEuint32(0);
        proposals[id].noVotes = FHE.asEuint32(0);
        proposals[id].deadline = block.timestamp + duration;
        proposals[id].revealed = false;

        FHE.allowThis(proposals[id].yesVotes);
        FHE.allowThis(proposals[id].noVotes);

        emit ProposalCreated(id, description, proposals[id].deadline);
    }

    /// @notice Cast an encrypted vote (0 = no, 1 = yes)
    function vote(uint256 proposalId, externalEuint8 encVote, bytes calldata inputProof) external {
        require(proposalId < proposalCount, "Invalid proposal");
        require(block.timestamp <= proposals[proposalId].deadline, "Voting ended");
        require(!hasVoted[proposalId][msg.sender], "Already voted");

        euint8 voteValue = FHE.fromExternal(encVote, inputProof);
        ebool isYes = FHE.eq(voteValue, FHE.asEuint8(1));

        // Increment yes or no tally using select
        euint32 oneVote = FHE.asEuint32(1);
        euint32 zeroVote = FHE.asEuint32(0);

        proposals[proposalId].yesVotes = FHE.add(
            proposals[proposalId].yesVotes,
            FHE.select(isYes, oneVote, zeroVote)
        );
        proposals[proposalId].noVotes = FHE.add(
            proposals[proposalId].noVotes,
            FHE.select(isYes, zeroVote, oneVote)
        );

        FHE.allowThis(proposals[proposalId].yesVotes);
        FHE.allowThis(proposals[proposalId].noVotes);

        hasVoted[proposalId][msg.sender] = true;
        emit VoteCast(proposalId, msg.sender);
    }

    /// @notice Get encrypted yes vote count (for authorized viewers)
    function getYesVotes(uint256 proposalId) external view returns (euint32) {
        return proposals[proposalId].yesVotes;
    }

    /// @notice Get encrypted no vote count
    function getNoVotes(uint256 proposalId) external view returns (euint32) {
        return proposals[proposalId].noVotes;
    }

    /// @notice Check if voting deadline has passed
    function isVotingEnded(uint256 proposalId) external view returns (bool) {
        return block.timestamp > proposals[proposalId].deadline;
    }
}
\`\`\`

---

## 5. The Vote Function in Detail

\`\`\`solidity
function vote(uint256 proposalId, externalEuint8 encVote, bytes calldata inputProof) external {
\`\`\`

The voter sends an encrypted \`euint8\` value:
- \`1\` = Yes
- \`0\` = No

The encryption happens on the frontend:

\`\`\`typescript
const input = instance.createEncryptedInput(contractAddress, userAddress);
input.add8(1); // Vote YES (or 0 for NO)
const encrypted = await input.encrypt();
const tx = await contract.vote(proposalId, encrypted.handles[0], encrypted.inputProof);
\`\`\`

Inside the contract, the encrypted \`euint8\` is compared against \`1\` to produce an \`ebool\`:

\`\`\`solidity
euint8 voteValue = FHE.fromExternal(encVote, inputProof);
ebool isYes = FHE.eq(voteValue, FHE.asEuint8(1));

euint32 oneVote = FHE.asEuint32(1);
euint32 zeroVote = FHE.asEuint32(0);

// If isYes: yes += 1, no += 0
// If !isYes: yes += 0, no += 1
euint32 yesIncrement = FHE.select(isYes, oneVote, zeroVote);
euint32 noIncrement = FHE.select(isYes, zeroVote, oneVote);
\`\`\`

Both \`yesVotes\` and \`noVotes\` are always updated with an \`FHE.add()\`. The values added are encrypted 1 or 0, but nobody can tell which tally got the 1.

---

## 6. Why FHE.select() Instead of Branching

You might think of writing:

\`\`\`solidity
// BAD: this leaks information!
if (decryptedVote == 1) {
    p.yesVotes = FHE.add(p.yesVotes, one);
} else {
    p.noVotes = FHE.add(p.noVotes, one);
}
\`\`\`

This would require decrypting the vote, which defeats the purpose. With \`FHE.select()\`, the computation happens entirely on encrypted data.

---

## 7. Tallies and Result Viewing

During the voting period, nobody can decrypt the tallies -- the ACL for the tallies only grants access to the contract itself (via \`allowThis\`).

The contract provides view functions to access the encrypted tally handles:

\`\`\`solidity
function getYesVotes(uint256 proposalId) external view returns (euint32) {
    return proposals[proposalId].yesVotes;
}

function getNoVotes(uint256 proposalId) external view returns (euint32) {
    return proposals[proposalId].noVotes;
}
\`\`\`

These return encrypted handles. To actually read the values, the caller would need ACL access and would decrypt through the gateway. In the current contract, only the contract itself has ACL access during voting, so the tallies remain hidden.

**Note:** The contract does not yet include a \`finalize()\` function that grants ACL to the owner for decryption. The struct includes \`revealed\`, \`yesResult\`, and \`noResult\` fields that are prepared for a future reveal mechanism. This is a good exercise extension -- see the Bonus Challenges in the exercise.

---

## 8. Privacy Guarantees and Limitations

### What IS private:
- Individual vote choices (yes/no)
- Running tallies during the voting period
- The margin of victory (until results are revealed)

### What is NOT private:
- Whether an address voted (participation is public)
- When an address voted (timestamp is public)
- The final results (after reveal)

### Limitation: Vote Weight

In this basic design, every voter has equal weight (1 vote). For weighted voting (e.g., based on token holdings), you would need to integrate with a confidential ERC-20 (Module 11).

---

## 9. Multi-Option Voting Extension

For proposals with more than 2 options, extend the pattern. Since we already use \`euint8\` for the vote value, the function signature stays the same -- only the internal logic changes:

\`\`\`solidity
struct MultiProposal {
    euint32[] optionVotes; // Array of encrypted tallies
    uint8 optionCount;
}

function voteMulti(uint256 proposalId, externalEuint8 encChoice, bytes calldata inputProof) external {
    euint8 choice = FHE.fromExternal(encChoice, inputProof);

    for (uint8 i = 0; i < p.optionCount; i++) {
        ebool isThisOption = FHE.eq(choice, FHE.asEuint8(i));
        euint32 increment = FHE.select(isThisOption, oneVote, zeroVote);
        p.optionVotes[i] = FHE.add(p.optionVotes[i], increment);
        FHE.allowThis(p.optionVotes[i]);
    }
}
\`\`\`

The voter sends an encrypted option index. The contract loops through all options and adds 1 to the matching one and 0 to the rest. This is exactly why using \`euint8\` for the vote input is a better design choice than \`ebool\` -- it naturally extends to multi-option voting.

---

## Summary

- Encrypted voting keeps individual votes secret and tallies hidden during the election
- Votes are sent as encrypted \`euint8\` values (0 = no, 1 = yes) using \`input.add8()\` on the frontend
- \`FHE.eq()\` converts the \`euint8\` vote to an \`ebool\` for use with \`FHE.select()\`
- \`FHE.select()\` is the key primitive: add 1 or 0 to each tally based on the encrypted vote
- Tallies use \`euint32\` -- sufficient for vote counts and more gas-efficient than \`euint64\`
- Duplicate prevention uses a plaintext mapping (participation is public, choice is not)
- Both tallies are always updated with \`FHE.add()\` to prevent side-channel analysis
- The pattern extends to multi-option voting with encrypted option indices (same \`euint8\` input type)
`,
  "13-project-auction": `# Module 13: Sealed-Bid Auction -- Lesson

## Introduction

Auctions on public blockchains suffer from a fundamental problem: **all bids are visible**. This enables:
- **Front-running:** MEV bots can see a bid in the mempool and outbid it
- **Bid sniping:** Waiting until the last second to bid just above the current highest
- **Collusion:** Bidders can coordinate based on visible bid history

A sealed-bid auction using FHEVM solves these problems by keeping all bids encrypted until the auction ends.

---

## 1. Auction Design

\`\`\`
Auction Lifecycle:
1. Owner creates auction (item, duration, reserve price) via createAuction()
2. Bidding phase: bidders submit encrypted bids + ETH deposit
3. Each bid is compared against current highest (encrypted)
4. Bidding phase ends (deadline passes)
5. Owner calls endAuction() -- uses FHE.makePubliclyDecryptable()
6. Winner and winning bid are revealed on-chain
7. Losers call withdrawDeposit() to reclaim ETH
\`\`\`

---

## 2. Key Design Decisions

### Multi-Auction Support

The contract supports multiple auctions via an \`auctionId\` system. Each auction has its own state stored in mappings:

\`\`\`solidity
struct Auction {
    string item;
    uint256 deadline;
    uint64 reservePrice;
    bool ended;
    bool finalized;
    address[] bidders;
}

mapping(uint256 => Auction) public auctions;
mapping(uint256 => euint64) internal _highestBid;
mapping(uint256 => eaddress) internal _highestBidder;
\`\`\`

### ETH Deposits

Bidders must deposit ETH along with their encrypted bid. The deposit must be at least as large as the maximum possible bid. This ensures the winner can actually pay.

**Alternative:** Use a fixed deposit amount for all bidders, then settle the difference after the auction. This provides better privacy (deposit amount does not leak bid range).

### Encrypted Highest Bid Tracking

We maintain an \`euint64\` for the current highest bid per auction. On each new bid, we compare and update:

\`\`\`solidity
ebool isHigher = FHE.gt(newBid, _highestBid[auctionId]);
_highestBid[auctionId] = FHE.select(isHigher, newBid, _highestBid[auctionId]);
\`\`\`

### Winner Tracking with eaddress

We also track the highest bidder's address in encrypted form using \`eaddress\`:

\`\`\`solidity
_highestBidder[auctionId] = FHE.select(
    isHigher,
    FHE.asEaddress(msg.sender),
    _highestBidder[auctionId]
);
\`\`\`

This is a key pattern: \`FHE.asEaddress(msg.sender)\` converts a plaintext address into an encrypted \`eaddress\`, and \`FHE.select()\` conditionally picks between encrypted addresses based on the encrypted comparison result.

---

## 3. Complete SealedBidAuction Contract

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, externalEuint64, ebool, eaddress} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract SealedBidAuction is ZamaEthereumConfig {
    struct Auction {
        string item;
        uint256 deadline;
        uint64 reservePrice;
        bool ended;
        bool finalized;
        address[] bidders;
    }

    mapping(uint256 => Auction) public auctions;
    mapping(uint256 => mapping(address => euint64)) internal _bids;
    mapping(uint256 => mapping(address => bool)) public hasBid;
    mapping(uint256 => mapping(address => uint256)) public deposits;
    mapping(uint256 => euint64) internal _highestBid;
    mapping(uint256 => eaddress) internal _highestBidder;

    mapping(uint256 => address) public winner;
    mapping(uint256 => uint64) public winningBidAmount;

    uint256 public auctionCount;
    address public owner;

    event AuctionCreated(uint256 indexed auctionId, string item, uint256 deadline, uint64 reservePrice);
    event BidPlaced(uint256 indexed auctionId, address indexed bidder);
    event AuctionEnded(uint256 indexed auctionId);
    event DepositWithdrawn(uint256 indexed auctionId, address indexed bidder, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function createAuction(
        string calldata item,
        uint256 duration,
        uint64 reservePrice
    ) external onlyOwner {
        uint256 id = auctionCount++;
        auctions[id].item = item;
        auctions[id].deadline = block.timestamp + duration;
        auctions[id].reservePrice = reservePrice;
        auctions[id].ended = false;
        auctions[id].finalized = false;

        _highestBid[id] = FHE.asEuint64(0);
        FHE.allowThis(_highestBid[id]);

        _highestBidder[id] = FHE.asEaddress(address(0));
        FHE.allowThis(_highestBidder[id]);

        emit AuctionCreated(id, item, auctions[id].deadline, reservePrice);
    }

    function bid(uint256 auctionId, externalEuint64 encBid, bytes calldata inputProof) external payable {
        require(auctionId < auctionCount, "Invalid auction");
        require(block.timestamp <= auctions[auctionId].deadline, "Bidding ended");
        require(!auctions[auctionId].ended, "Auction ended");
        require(!hasBid[auctionId][msg.sender], "Already bid");
        require(msg.value > 0, "Must deposit ETH");

        euint64 newBid = FHE.fromExternal(encBid, inputProof);

        _bids[auctionId][msg.sender] = newBid;
        FHE.allowThis(_bids[auctionId][msg.sender]);
        FHE.allow(_bids[auctionId][msg.sender], msg.sender);

        deposits[auctionId][msg.sender] = msg.value;

        ebool isHigher = FHE.gt(newBid, _highestBid[auctionId]);
        _highestBid[auctionId] = FHE.select(isHigher, newBid, _highestBid[auctionId]);
        FHE.allowThis(_highestBid[auctionId]);

        _highestBidder[auctionId] = FHE.select(
            isHigher,
            FHE.asEaddress(msg.sender),
            _highestBidder[auctionId]
        );
        FHE.allowThis(_highestBidder[auctionId]);

        hasBid[auctionId][msg.sender] = true;
        auctions[auctionId].bidders.push(msg.sender);

        emit BidPlaced(auctionId, msg.sender);
    }

    function endAuction(uint256 auctionId) external onlyOwner {
        require(auctionId < auctionCount, "Invalid auction");
        require(block.timestamp > auctions[auctionId].deadline, "Not yet ended");
        require(!auctions[auctionId].ended, "Already ended");

        auctions[auctionId].ended = true;

        FHE.makePubliclyDecryptable(_highestBid[auctionId]);
        FHE.makePubliclyDecryptable(_highestBidder[auctionId]);

        emit AuctionEnded(auctionId);
    }

    function withdrawDeposit(uint256 auctionId) external {
        require(auctions[auctionId].ended, "Auction not ended");
        require(msg.sender != winner[auctionId], "Winner cannot withdraw");
        uint256 amount = deposits[auctionId][msg.sender];
        require(amount > 0, "No deposit");

        deposits[auctionId][msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit DepositWithdrawn(auctionId, msg.sender, amount);
    }

    function getHighestBid(uint256 auctionId) external view returns (euint64) {
        return _highestBid[auctionId];
    }

    function getMyBid(uint256 auctionId) external view returns (euint64) {
        return _bids[auctionId][msg.sender];
    }

    function getBidderCount(uint256 auctionId) external view returns (uint256) {
        return auctions[auctionId].bidders.length;
    }

    function getHighestBidder(uint256 auctionId) external view returns (eaddress) {
        return _highestBidder[auctionId];
    }
}
\`\`\`

---

## 4. The createAuction Function

The owner creates auctions dynamically rather than setting parameters in the constructor:

\`\`\`solidity
function createAuction(
    string calldata item,
    uint256 duration,
    uint64 reservePrice
) external onlyOwner {
    uint256 id = auctionCount++;
    auctions[id].item = item;
    auctions[id].deadline = block.timestamp + duration;
    auctions[id].reservePrice = reservePrice;

    _highestBid[id] = FHE.asEuint64(0);
    FHE.allowThis(_highestBid[id]);

    _highestBidder[id] = FHE.asEaddress(address(0));
    FHE.allowThis(_highestBidder[id]);

    emit AuctionCreated(id, item, auctions[id].deadline, reservePrice);
}
\`\`\`

Key points:
- \`duration\` is relative (seconds from now), converted to an absolute \`deadline\`
- \`reservePrice\` is stored as plaintext \`uint64\` -- it is the minimum acceptable bid
- Both \`_highestBid\` and \`_highestBidder\` are initialized to encrypted zero/null values
- \`FHE.allowThis()\` grants the contract permission to operate on these encrypted values

---

## 5. The bid Function in Detail

The core logic of the auction is in the \`bid()\` function:

\`\`\`solidity
function bid(uint256 auctionId, externalEuint64 encBid, bytes calldata inputProof) external payable {
    require(msg.value > 0, "Must deposit ETH");
    require(!hasBid[auctionId][msg.sender], "Already bid");

    euint64 newBid = FHE.fromExternal(encBid, inputProof);

    // Compare: is this bid higher than the current highest?
    ebool isHigher = FHE.gt(newBid, _highestBid[auctionId]);

    // Update highest bid: pick the larger one
    _highestBid[auctionId] = FHE.select(isHigher, newBid, _highestBid[auctionId]);

    // Update highest bidder: pick the corresponding address
    _highestBidder[auctionId] = FHE.select(
        isHigher,
        FHE.asEaddress(msg.sender),
        _highestBidder[auctionId]
    );
}
\`\`\`

Key observations:
- \`FHE.fromExternal(encBid, inputProof)\` takes exactly 2 parameters (the encrypted handle and the proof)
- The comparison and selection happen entirely on encrypted data
- Neither the bidder nor observers know if their bid is currently the highest
- Both \`_highestBid\` and \`_highestBidder\` are updated atomically
- \`msg.value > 0\` ensures the bidder deposits ETH to back their bid
- One bid per user is enforced with \`hasBid\` mapping

---

## 6. Encrypted Address (eaddress)

This contract uses \`eaddress\` -- an encrypted Ethereum address:

\`\`\`solidity
eaddress private _highestBidder;

// Create from plaintext
_highestBidder[id] = FHE.asEaddress(msg.sender);

// Select between two encrypted addresses
_highestBidder[id] = FHE.select(isHigher,
    FHE.asEaddress(msg.sender), _highestBidder[id]);
\`\`\`

The \`eaddress\` pattern is central to this contract:
1. \`FHE.asEaddress(msg.sender)\` wraps a plaintext address into an encrypted value
2. \`FHE.select(condition, addrA, addrB)\` picks one of two encrypted addresses based on an encrypted boolean
3. The winner's identity stays encrypted until \`endAuction()\` is called

---

## 7. Deposit Handling

Bidders must send ETH with their bid:

\`\`\`solidity
require(msg.value > 0, "Must deposit ETH");
deposits[auctionId][msg.sender] = msg.value;
\`\`\`

After the auction ends:
- **Losers:** Can call \`withdrawDeposit(auctionId)\` to reclaim their ETH
- **Winner:** Their deposit covers the winning bid (or partial settlement)

\`\`\`solidity
function withdrawDeposit(uint256 auctionId) external {
    require(auctions[auctionId].ended, "Auction not ended");
    require(msg.sender != winner[auctionId], "Winner cannot withdraw");
    uint256 amount = deposits[auctionId][msg.sender];
    require(amount > 0, "No deposit");

    deposits[auctionId][msg.sender] = 0;
    payable(msg.sender).transfer(amount);
    emit DepositWithdrawn(auctionId, msg.sender, amount);
}
\`\`\`

**Privacy consideration:** The deposit amount is plaintext (ETH transfers are visible). For maximum privacy, all bidders should deposit the same fixed amount.

---

## 8. Ending the Auction: FHE.makePubliclyDecryptable()

Instead of using a Gateway for decryption, this contract uses \`FHE.makePubliclyDecryptable()\`:

\`\`\`solidity
function endAuction(uint256 auctionId) external onlyOwner {
    require(block.timestamp > auctions[auctionId].deadline, "Not yet ended");
    require(!auctions[auctionId].ended, "Already ended");

    auctions[auctionId].ended = true;

    // Make results publicly readable -- no Gateway needed
    FHE.makePubliclyDecryptable(_highestBid[auctionId]);
    FHE.makePubliclyDecryptable(_highestBidder[auctionId]);

    emit AuctionEnded(auctionId);
}
\`\`\`

Key points about public decryption:
- **\`makePubliclyDecryptable\` pattern:** The encrypted value is marked for public decryption — anyone can read the result once the decryption oracle processes it
- **Alternative (re-encryption):** Owner gets ACL access, then decrypts client-side via \`instance.userDecrypt()\` (Relayer SDK), then submits plaintext back on-chain
- \`makePubliclyDecryptable\` is simpler and removes the need for the owner to act as a trusted intermediary

---

## 9. Frontend: Placing a Bid

\`\`\`typescript
const instance = await initFhevm();
const input = instance.createEncryptedInput(
  auctionAddress, userAddress
);
input.add64(myBidAmount);
const encrypted = await input.encrypt();

const tx = await contract.bid(
  auctionId,
  encrypted.handles[0],
  encrypted.inputProof,
  { value: ethers.parseEther("1.0") } // ETH deposit
);
await tx.wait();
\`\`\`

Note the three contract parameters: \`auctionId\`, the encrypted handle, and the proof, plus the ETH value sent with the transaction.

---

## 10. Privacy Advantages Over Traditional Auctions

| Aspect | Open Auction | Commit-Reveal | FHE Sealed-Bid |
|--------|-------------|---------------|----------------|
| Bids visible during auction | Yes | No (committed hash) | No (encrypted) |
| Front-running possible | Yes | Partially | No |
| Requires reveal phase | No | Yes | No |
| Bidder can refuse to reveal | N/A | Yes (griefing) | N/A |
| On-chain comparison | Plaintext | After reveal | Encrypted |

The FHE approach eliminates the reveal phase entirely. There is no "commit-reveal" -- bids are compared on-chain while still encrypted.

---

## 11. Handling Ties

What if two bids are equal? With \`FHE.gt()\`, equal bids return \`false\`, so the earlier bidder keeps the lead:

\`\`\`solidity
ebool isHigher = FHE.gt(newBid, _highestBid[auctionId]);
// If equal, isHigher is false -> previous highest stays
\`\`\`

If you want ties to go to the later bidder, use \`FHE.ge()\`:

\`\`\`solidity
ebool isHigherOrEqual = FHE.ge(newBid, _highestBid[auctionId]);
\`\`\`

---

## 12. Security Considerations

### Bid Validity

The encrypted bid could be any value. A malicious bidder could bid \`type(uint64).max\` without having the funds. The deposit requirement mitigates this, but for a production system, you would need more sophisticated settlement logic.

### One Bid Per Address

\`\`\`solidity
require(!hasBid[auctionId][msg.sender], "Already bid");
\`\`\`

Allowing bid updates would reveal that the bidder changed their mind (a timing side-channel). One bid per address is simpler and more private.

### Reserve Price

The \`reservePrice\` is stored per auction. It can be checked against the decrypted winning bid after the auction ends to determine if the auction met its minimum.

---

## Summary

- Sealed-bid auctions with FHE eliminate front-running and bid sniping
- \`createAuction()\` sets up item, duration, and reserve price; supports multiple auctions
- \`bid()\` requires an ETH deposit and enforces one-bid-per-user
- \`FHE.fromExternal(encBid, inputProof)\` converts external encrypted input (2 parameters)
- \`FHE.gt()\` compares bids without revealing values
- \`FHE.select()\` updates the highest bid and bidder atomically
- \`eaddress\` keeps the winner's identity encrypted: \`FHE.select(isHigher, FHE.asEaddress(msg.sender), _highestBidder[auctionId])\`
- \`endAuction()\` uses \`FHE.makePubliclyDecryptable()\` instead of Gateway-based decryption
- \`withdrawDeposit(auctionId)\` lets losers reclaim ETH after the auction ends
- No reveal phase needed (unlike commit-reveal schemes)
- Privacy of deposit amounts requires fixed-deposit designs
`,
  "14-testing-debugging": `# Module 14: Testing & Debugging FHE Contracts -- Lesson

## Introduction: The Testing Challenge

Testing smart contracts that use Fully Homomorphic Encryption (FHE) is fundamentally different from testing standard Solidity contracts. In a normal contract, you can:

- Call a view function and immediately read a balance as a number
- Use \`require()\` to enforce conditions and test that they revert on failure
- Use \`console.log()\` in Hardhat to print intermediate values during execution
- Assert exact values returned from functions

With FHE contracts, **none of these work in the obvious way**:

- View functions return **encrypted handles**, not numbers
- \`require()\` cannot evaluate encrypted booleans -- \`ebool\` is not a \`bool\`
- \`console.log()\` will print a meaningless handle identifier, not the underlying value
- Function return values are opaque ciphertexts until decrypted

This creates a paradigm shift in how you write tests. Instead of "call and compare," you follow a cycle of **encrypt, act, decrypt, and assert**. Instead of relying on revert messages for error paths, you verify that **state did not change** after a failed encrypted operation (the "silent failure" pattern).

This module teaches you how to navigate these challenges systematically.

---

## 1. Setting Up the Test Environment

### The @fhevm/hardhat-plugin

The fhEVM testing stack centers on the \`@fhevm/hardhat-plugin\`. This plugin:

1. Provides a **mock FHE environment** that runs locally on Hardhat Network
2. Exposes a global \`fhevm\` object in your test files
3. Handles encrypted input creation and decryption for test assertions
4. Simulates the FHE computation pipeline using plaintext under the hood

The mock environment is **not** running real FHE. It stores plaintext values behind encrypted handles, which makes tests fast and deterministic. This is essential -- real FHE operations take significant time and compute.

### hardhat.config.ts Setup

Your Hardhat config must import the plugin:

\`\`\`typescript
import "@fhevm/hardhat-plugin";
\`\`\`

A typical config looks like:

\`\`\`typescript
import "@nomicfoundation/hardhat-ethers";
import "@fhevm/hardhat-plugin";
import type { HardhatUserConfig } from "hardhat/config";

const config: HardhatUserConfig = {
  defaultNetwork: "hardhat",
  networks: {
    hardhat: {
      accounts: {
        mnemonic: "test test test test test test test test test test test junk",
      },
      chainId: 31337,
    },
  },
  solidity: {
    version: "0.8.27",
    settings: {
      optimizer: { enabled: true, runs: 800 },
      evmVersion: "cancun",
    },
  },
};

export default config;
\`\`\`

Key points:
- The \`chainId: 31337\` is the standard Hardhat Network chain ID
- The mnemonic provides deterministic test accounts
- The \`@fhevm/hardhat-plugin\` import auto-registers the mock environment

### The fhevm Object

In every test file, you import \`fhevm\` from \`"hardhat"\`:

\`\`\`typescript
import { ethers, fhevm } from "hardhat";
\`\`\`

The \`fhevm\` object provides three critical methods:

| Method | Purpose |
|--------|---------|
| \`fhevm.createEncryptedInput(contractAddress, signerAddress)\` | Create encrypted inputs for contract calls |
| \`fhevm.userDecryptEuint(FhevmType, handle, contractAddress, signer)\` | Decrypt a numeric encrypted value |
| \`fhevm.userDecryptEbool(handle, contractAddress, signer)\` | Decrypt an encrypted boolean |

You also need the \`FhevmType\` enum:

\`\`\`typescript
import { FhevmType } from "@fhevm/hardhat-plugin";
\`\`\`

This enum maps to encrypted types:
- \`FhevmType.euint8\`
- \`FhevmType.euint16\`
- \`FhevmType.euint32\`
- \`FhevmType.euint64\`

---

## 2. Creating Encrypted Inputs in Tests

Every FHE contract function that accepts encrypted input requires two parameters: the encrypted handle and a proof. In the test environment, you create these using \`fhevm.createEncryptedInput()\`.

### Step-by-Step

\`\`\`typescript
// 1. Create the input builder
const encryptedInput = await fhevm.createEncryptedInput(
  contractAddress,  // The contract receiving the input
  signer.address    // The user sending the transaction
);

// 2. Add values (type-specific methods)
encryptedInput.add64(1000);  // Add a uint64 value

// 3. Encrypt and get the result
const enc = await encryptedInput.encrypt();

// 4. Use in a contract call
await contract.someFunction(enc.handles[0], enc.inputProof);
\`\`\`

### Adding Different Types

The input builder supports all FHE numeric types:

\`\`\`typescript
encryptedInput.addBool(true);   // ebool
encryptedInput.add8(255);       // euint8  (max: 255)
encryptedInput.add16(65535);    // euint16 (max: 65535)
encryptedInput.add32(1000000);  // euint32
encryptedInput.add64(1000000);  // euint64
\`\`\`

### Multiple Values in One Input

You can add multiple values in a single encrypted input:

\`\`\`typescript
const enc = await fhevm
  .createEncryptedInput(contractAddress, signer.address)
  .add64(amount)
  .add64(limit)
  .encrypt();

// First value: enc.handles[0]
// Second value: enc.handles[1]
// Shared proof: enc.inputProof
\`\`\`

All values share the same \`inputProof\`, but each gets its own \`handle\` at a different index.

### Common Mistake: Wrong Address Parameters

A frequent bug is passing the wrong addresses to \`createEncryptedInput\`:

\`\`\`typescript
// WRONG: Using alice's address when bob is calling the contract
const enc = await fhevm
  .createEncryptedInput(contractAddress, alice.address)  // alice
  .add64(100)
  .encrypt();
await contract.connect(bob).deposit(enc.handles[0], enc.inputProof);  // bob calls!
// This will fail -- the proof is bound to alice, not bob.

// CORRECT: Match the signer
const enc = await fhevm
  .createEncryptedInput(contractAddress, bob.address)  // bob
  .add64(100)
  .encrypt();
await contract.connect(bob).deposit(enc.handles[0], enc.inputProof);  // bob calls
\`\`\`

The encrypted input is **bound to a specific contract address and signer**. If you mismatch, the proof verification will fail.

---

## 3. Decrypting Values in Tests

After a contract operation, you need to read the encrypted result and verify it. This is the "decrypt" step in the encrypt-act-decrypt-assert cycle.

### Decrypting Numeric Types

\`\`\`typescript
import { FhevmType } from "@fhevm/hardhat-plugin";

// Get the encrypted handle from the contract
const handle = await contract.connect(alice).getBalance();

// Decrypt it in the test
const clearValue = await fhevm.userDecryptEuint(
  FhevmType.euint64,  // The type of the encrypted value
  handle,              // The handle returned by the contract
  contractAddress,     // The contract that owns the value
  alice                // The signer who has ACL permission
);

// Assert
expect(clearValue).to.equal(1000n);  // Always use BigInt (n suffix)
\`\`\`

### Decrypting Booleans

\`\`\`typescript
const handle = await contract.connect(alice).getIsActive();
const clearBool = await fhevm.userDecryptEbool(
  handle,
  contractAddress,
  alice
);
expect(clearBool).to.equal(true);
\`\`\`

### The FhevmType Enum

You must pass the correct type to \`userDecryptEuint\`:

| Contract return type | FhevmType parameter |
|---------------------|---------------------|
| \`euint8\` | \`FhevmType.euint8\` |
| \`euint16\` | \`FhevmType.euint16\` |
| \`euint32\` | \`FhevmType.euint32\` |
| \`euint64\` | \`FhevmType.euint64\` |
| \`ebool\` | Use \`userDecryptEbool()\` instead |

### When Decryption Fails

Decryption fails when the signer does not have ACL permission for the encrypted value. In a real FHE network, this means the signer was never granted \`FHE.allow()\`. In tests, you will see an error or get an unexpected result.

This is actually a useful testing mechanism: you can verify that ACL boundaries are working correctly by attempting to decrypt as an unauthorized user and expecting failure.

\`\`\`typescript
// Alice deposits, Bob tries to read Alice's balance
const handle = await contract.connect(alice).getBalance();

// Bob does NOT have ACL permission on Alice's balance
try {
  await fhevm.userDecryptEuint(FhevmType.euint64, handle, contractAddress, bob);
  expect.fail("Should have failed -- Bob lacks ACL permission");
} catch (error) {
  // Expected: Bob cannot decrypt Alice's balance
}
\`\`\`

---

## 4. Testing Patterns

### Pattern 1: Encrypt -- Act -- Decrypt -- Assert

This is the fundamental FHE testing pattern. Every test that involves encrypted values follows this structure:

\`\`\`typescript
it("should deposit and verify balance", async function () {
  // ENCRYPT: Create encrypted input
  const enc = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(1000)
    .encrypt();

  // ACT: Call the contract
  await (await contract.connect(alice).deposit(
    enc.handles[0], enc.inputProof
  )).wait();

  // DECRYPT: Read the encrypted result
  const handle = await contract.connect(alice).getBalance();
  const clear = await fhevm.userDecryptEuint(
    FhevmType.euint64, handle, contractAddress, alice
  );

  // ASSERT: Verify the decrypted value
  expect(clear).to.equal(1000n);
});
\`\`\`

### Pattern 2: Multi-User Scenarios

FHE contracts often involve multiple users whose data must be isolated. Test this by using different signers:

\`\`\`typescript
it("should isolate user balances", async function () {
  const [_, alice, bob] = await ethers.getSigners();

  // Alice deposits 1000
  const encAlice = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(1000)
    .encrypt();
  await (await contract.connect(alice).deposit(
    encAlice.handles[0], encAlice.inputProof
  )).wait();

  // Bob deposits 2000
  const encBob = await fhevm
    .createEncryptedInput(contractAddress, bob.address)
    .add64(2000)
    .encrypt();
  await (await contract.connect(bob).deposit(
    encBob.handles[0], encBob.inputProof
  )).wait();

  // Verify each user's balance independently
  const handleA = await contract.connect(alice).getBalance();
  const clearA = await fhevm.userDecryptEuint(
    FhevmType.euint64, handleA, contractAddress, alice
  );
  expect(clearA).to.equal(1000n);

  const handleB = await contract.connect(bob).getBalance();
  const clearB = await fhevm.userDecryptEuint(
    FhevmType.euint64, handleB, contractAddress, bob
  );
  expect(clearB).to.equal(2000n);
});
\`\`\`

### Pattern 3: Event Verification

Events are your primary debugging tool. Since you cannot inspect encrypted state mid-execution, events provide proof that certain code paths were reached:

\`\`\`typescript
it("should emit Deposited event", async function () {
  const enc = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(500)
    .encrypt();

  const tx = await contract.connect(alice).deposit(
    enc.handles[0], enc.inputProof
  );
  const receipt = await tx.wait();

  // Find the event in the receipt logs
  const event = receipt.logs.find(
    (log: any) => log.fragment?.name === "Deposited"
  );
  expect(event).to.not.be.undefined;
  expect(event.args[0]).to.equal(alice.address); // indexed user
});
\`\`\`

Events are especially useful for tracking:
- Which code path was taken (e.g., "did the transfer succeed or fall through to the silent failure path?")
- Operation counters and indices
- Addresses and plaintext metadata associated with the operation

### Pattern 4: Error Handling with try/catch

Custom errors and \`require()\` reverts work for **plaintext** conditions (like \`onlyOwner\` checks). Test them with try/catch:

\`\`\`typescript
it("should revert for non-owner", async function () {
  const enc = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(500)
    .encrypt();

  try {
    await contract.connect(alice).setWithdrawalLimit(
      enc.handles[0], enc.inputProof
    );
    expect.fail("Should have reverted");
  } catch (error: any) {
    expect(error.message).to.include("NotOwner");
  }
});
\`\`\`

**Important:** You cannot test revert conditions on encrypted values. If a withdraw fails because the encrypted balance is too low, the contract does **not** revert -- it withdraws 0 instead. You must verify this by checking that the balance is unchanged.

### Pattern 5: Sequential State Verification

Complex flows require verifying state at multiple checkpoints:

\`\`\`typescript
it("should handle deposit + deposit + withdraw", async function () {
  // Step 1: Deposit 500
  const enc1 = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(500)
    .encrypt();
  await (await contract.connect(alice).deposit(
    enc1.handles[0], enc1.inputProof
  )).wait();

  // Checkpoint 1: balance = 500
  let handle = await contract.connect(alice).getBalance();
  let clear = await fhevm.userDecryptEuint(
    FhevmType.euint64, handle, contractAddress, alice
  );
  expect(clear).to.equal(500n);

  // Step 2: Deposit 300
  const enc2 = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(300)
    .encrypt();
  await (await contract.connect(alice).deposit(
    enc2.handles[0], enc2.inputProof
  )).wait();

  // Checkpoint 2: balance = 800
  handle = await contract.connect(alice).getBalance();
  clear = await fhevm.userDecryptEuint(
    FhevmType.euint64, handle, contractAddress, alice
  );
  expect(clear).to.equal(800n);

  // Step 3: Withdraw 200
  const encW = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(200)
    .encrypt();
  await (await contract.connect(alice).withdraw(
    encW.handles[0], encW.inputProof
  )).wait();

  // Checkpoint 3: balance = 600
  handle = await contract.connect(alice).getBalance();
  clear = await fhevm.userDecryptEuint(
    FhevmType.euint64, handle, contractAddress, alice
  );
  expect(clear).to.equal(600n);
});
\`\`\`

### Pattern 6: ACL Boundary Testing

FHE contracts use \`FHE.allow()\` and \`FHE.allowThis()\` to control who can access encrypted data. Test these boundaries:

\`\`\`typescript
it("should prevent user B from decrypting user A's balance", async function () {
  // Alice deposits
  const enc = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(1000)
    .encrypt();
  await (await contract.connect(alice).deposit(
    enc.handles[0], enc.inputProof
  )).wait();

  // Alice can decrypt her own balance
  const handle = await contract.connect(alice).getBalance();
  const clear = await fhevm.userDecryptEuint(
    FhevmType.euint64, handle, contractAddress, alice
  );
  expect(clear).to.equal(1000n);

  // Bob CANNOT decrypt Alice's balance handle
  try {
    await fhevm.userDecryptEuint(
      FhevmType.euint64, handle, contractAddress, bob
    );
    expect.fail("Bob should not be able to decrypt Alice's balance");
  } catch (error) {
    // Expected failure: Bob lacks ACL permission
  }
});
\`\`\`

---

## 5. Debugging Techniques

### Events as Debug Output

Since you cannot \`console.log()\` encrypted values, events serve as your primary debugging mechanism. Design your contracts with generous event emissions:

\`\`\`solidity
// BAD: No visibility into what happened
function deposit(externalEuint64 encAmount, bytes calldata inputProof) external {
    euint64 amount = FHE.fromExternal(encAmount, inputProof);
    _balances[msg.sender] = FHE.add(_balances[msg.sender], amount);
    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
}

// GOOD: Events provide debugging signals
function deposit(externalEuint64 encAmount, bytes calldata inputProof) external {
    euint64 amount = FHE.fromExternal(encAmount, inputProof);
    _balances[msg.sender] = FHE.add(_balances[msg.sender], amount);
    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
    depositCount++;
    emit Deposited(msg.sender, depositCount);
}
\`\`\`

In your tests, verify the events:

\`\`\`typescript
const receipt = await tx.wait();
const event = receipt.logs.find(
  (log: any) => log.fragment?.name === "Deposited"
);
expect(event).to.not.be.undefined;
\`\`\`

### Public State Variables as Checkpoints

Add plaintext counters and status flags that you can read without decryption:

\`\`\`solidity
uint256 public depositCount;
uint256 public withdrawalCount;
bool public isPaused;
\`\`\`

These are instantly readable in tests without the encrypt/decrypt cycle:

\`\`\`typescript
expect(await vault.depositCount()).to.equal(3n);
\`\`\`

### Step-by-Step Operation Verification

When a test fails, break the operation into the smallest possible steps and verify state after each one:

\`\`\`typescript
// Instead of one big test, verify each step
it("debug: step 1 - deposit", async function () {
  const enc = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(1000)
    .encrypt();
  await (await contract.connect(alice).deposit(
    enc.handles[0], enc.inputProof
  )).wait();

  const handle = await contract.connect(alice).getBalance();
  const clear = await fhevm.userDecryptEuint(
    FhevmType.euint64, handle, contractAddress, alice
  );
  console.log("After deposit:", clear.toString());
  // If this prints "0" instead of "1000", the deposit logic is broken
});
\`\`\`

### Isolating Failing Operations

If a complex test fails, isolate the failing operation by writing a minimal reproduction:

\`\`\`typescript
it("debug: minimal reproduction of withdrawal bug", async function () {
  // Setup: deposit exactly 100
  const enc = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(100)
    .encrypt();
  await (await contract.connect(alice).deposit(
    enc.handles[0], enc.inputProof
  )).wait();

  // The suspected failing operation: withdraw 100
  const encW = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(100)
    .encrypt();
  await (await contract.connect(alice).withdraw(
    encW.handles[0], encW.inputProof
  )).wait();

  // Check
  const handle = await contract.connect(alice).getBalance();
  const clear = await fhevm.userDecryptEuint(
    FhevmType.euint64, handle, contractAddress, alice
  );
  console.log("After withdraw:", clear.toString());
});
\`\`\`

### Temporary Debug: FHE.makePubliclyDecryptable()

During development, you can temporarily mark encrypted values as publicly decryptable to inspect them:

\`\`\`solidity
function debugBalance(address user) external {
    // TEMPORARY -- remove before production!
    FHE.makePubliclyDecryptable(_balances[user]);
}
\`\`\`

This lets anyone read the value, bypassing ACL. **Always remove this before deploying to a real network.**

---

## 6. The Silent Failure Problem

This is the single most important concept in FHE testing.

### The Problem

In a standard ERC-20, if you try to transfer more tokens than you have:

\`\`\`solidity
// Standard ERC-20
require(balanceOf[msg.sender] >= amount, "Insufficient balance");
\`\`\`

The transaction **reverts**. Your test can check for the revert:

\`\`\`typescript
await expect(token.transfer(bob, 1000)).to.be.revertedWith("Insufficient balance");
\`\`\`

In an FHE contract, you **cannot** use \`require\` on encrypted values because \`ebool\` is not a native \`bool\`. Instead, the contract uses the select pattern:

\`\`\`solidity
// FHE contract
ebool hasEnough = FHE.ge(_balances[msg.sender], amount);
euint64 actualAmount = FHE.select(hasEnough, amount, FHE.asEuint64(0));
_balances[msg.sender] = FHE.sub(_balances[msg.sender], actualAmount);
\`\`\`

If the user does not have enough balance, \`actualAmount\` becomes 0, and the subtraction is \`balance - 0 = balance\`. The transaction **succeeds** but transfers nothing. There is no revert. There is no error. This is by design -- reverting would leak information about the encrypted balance.

### Testing Silent Failures

You cannot test for reverts. Instead, verify that state did not change:

\`\`\`typescript
it("should silently fail on overdraft (balance unchanged)", async function () {
  // Setup: Alice has 100
  // ...

  // Try to withdraw 9999
  const encW = await fhevm
    .createEncryptedInput(contractAddress, alice.address)
    .add64(9999)
    .encrypt();
  await (await contract.connect(alice).withdraw(
    encW.handles[0], encW.inputProof
  )).wait();

  // Verify: balance is STILL 100 (the withdrawal silently withdrew 0)
  const handle = await contract.connect(alice).getBalance();
  const clear = await fhevm.userDecryptEuint(
    FhevmType.euint64, handle, contractAddress, alice
  );
  expect(clear).to.equal(100n); // unchanged!
});
\`\`\`

### Implications for Test Design

1. **Always verify state after "failed" operations.** The tx will succeed (no revert), but the state should be unchanged.
2. **Use events to confirm the operation ran.** The event will fire even on silent failures (the tx still executes).
3. **Test both paths:** a withdrawal that succeeds (balance decreases) AND a withdrawal that silently fails (balance unchanged).
4. **Never use \`revertedWith\` for encrypted condition failures.** It will always pass because the tx does not revert.

---

## 7. Common Testing Mistakes

### Mistake 1: Forgetting .wait()

\`\`\`typescript
// WRONG: Not waiting for the transaction
await contract.connect(alice).deposit(enc.handles[0], enc.inputProof);
// Immediately tries to read balance before tx is mined

// CORRECT: Wait for transaction receipt
await (await contract.connect(alice).deposit(
  enc.handles[0], enc.inputProof
)).wait();
\`\`\`

The double-await pattern (\`await (await ...).wait()\`) is essential. The first \`await\` sends the transaction, the second \`await\` waits for it to be mined and included in a block.

### Mistake 2: Using equal(42) Instead of equal(42n)

\`\`\`typescript
// WRONG: JavaScript number comparison
expect(clear).to.equal(42);
// This may fail because clear is a BigInt

// CORRECT: BigInt comparison
expect(clear).to.equal(42n);
\`\`\`

All values decrypted from FHE are BigInts. Always use the \`n\` suffix for expected values.

### Mistake 3: Not Granting ACL Permissions Before Reading

If you forget \`FHE.allow()\` in the contract, the test decryption will fail:

\`\`\`solidity
// Contract -- WRONG: No ACL
function deposit(externalEuint64 encAmount, bytes calldata inputProof) external {
    euint64 amount = FHE.fromExternal(encAmount, inputProof);
    _balances[msg.sender] = FHE.add(_balances[msg.sender], amount);
    // Missing: FHE.allowThis() and FHE.allow()
}

// Contract -- CORRECT: With ACL
function deposit(externalEuint64 encAmount, bytes calldata inputProof) external {
    euint64 amount = FHE.fromExternal(encAmount, inputProof);
    _balances[msg.sender] = FHE.add(_balances[msg.sender], amount);
    FHE.allowThis(_balances[msg.sender]);           // Contract can operate on it
    FHE.allow(_balances[msg.sender], msg.sender);   // User can decrypt it
}
\`\`\`

### Mistake 4: Testing Encrypted Conditions with require

\`\`\`solidity
// WRONG: This will not compile or will not work as intended
function withdraw(externalEuint64 encAmount, bytes calldata inputProof) external {
    euint64 amount = FHE.fromExternal(encAmount, inputProof);
    require(FHE.ge(_balances[msg.sender], amount), "Insufficient"); // WRONG! ebool != bool
    _balances[msg.sender] = FHE.sub(_balances[msg.sender], amount);
}

// CORRECT: Use select pattern
function withdraw(externalEuint64 encAmount, bytes calldata inputProof) external {
    euint64 amount = FHE.fromExternal(encAmount, inputProof);
    ebool hasEnough = FHE.ge(_balances[msg.sender], amount);
    euint64 actualAmount = FHE.select(hasEnough, amount, FHE.asEuint64(0));
    _balances[msg.sender] = FHE.sub(_balances[msg.sender], actualAmount);
}
\`\`\`

### Mistake 5: Using Chai's revertedWith for Encrypted Failures

\`\`\`typescript
// WRONG: This will PASS (the tx does not revert!)
await expect(
  contract.connect(alice).withdraw(enc.handles[0], enc.inputProof)
).to.not.be.reverted;
// This proves nothing -- it always passes for select-pattern contracts

// CORRECT: Verify that state is unchanged
await (await contract.connect(alice).withdraw(
  enc.handles[0], enc.inputProof
)).wait();
const handle = await contract.connect(alice).getBalance();
const clear = await fhevm.userDecryptEuint(
  FhevmType.euint64, handle, contractAddress, alice
);
expect(clear).to.equal(originalBalance);  // Balance unchanged = withdrawal failed
\`\`\`

### Mistake 6: Mismatched Signer in createEncryptedInput

\`\`\`typescript
// WRONG: Encrypted for alice, sent by bob
const enc = await fhevm
  .createEncryptedInput(contractAddress, alice.address)
  .add64(100)
  .encrypt();
await contract.connect(bob).deposit(enc.handles[0], enc.inputProof);
// Proof validation fails!

// CORRECT: Match signer
const enc = await fhevm
  .createEncryptedInput(contractAddress, bob.address)
  .add64(100)
  .encrypt();
await contract.connect(bob).deposit(enc.handles[0], enc.inputProof);
\`\`\`

---

## 8. Best Practices Checklist

Use this checklist when writing tests for any FHE contract:

### Test Structure
- [ ] Use \`beforeEach\` to deploy a fresh contract for each test (isolation)
- [ ] Get multiple signers (\`owner\`, \`alice\`, \`bob\`, etc.) for multi-user tests
- [ ] Follow the encrypt-act-decrypt-assert pattern consistently
- [ ] Name tests descriptively: "should withdraw 0 when amount exceeds balance"

### Encrypted Inputs
- [ ] Always match \`createEncryptedInput\` signer with \`contract.connect()\` signer
- [ ] Use the correct \`add\` method for the type (\`add64\` for \`euint64\`, etc.)
- [ ] Access \`enc.handles[0]\` and \`enc.inputProof\` from the encrypted result

### Decryption
- [ ] Use the correct \`FhevmType\` enum value matching the contract's return type
- [ ] Always use BigInt comparisons (\`42n\`, not \`42\`)
- [ ] Handle decryption errors gracefully in ACL boundary tests

### Coverage
- [ ] Test deployment/initial state
- [ ] Test every public function's success path
- [ ] Test "failure" paths by verifying state is unchanged
- [ ] Test with multiple users (balance isolation, permission isolation)
- [ ] Test owner-only functions from both owner and non-owner accounts
- [ ] Test sequential operations (deposit + deposit + withdraw)
- [ ] Test edge cases: zero amounts, max values, empty balances
- [ ] Verify events for every state-changing function

### Debugging
- [ ] Add plaintext counters for operations you want to track
- [ ] Emit events with plaintext metadata (addresses, indices)
- [ ] When a test fails, isolate the failing step with checkpoints
- [ ] Temporarily use \`FHE.makePubliclyDecryptable()\` for deep debugging (remove before production)

---

## 9. Full Example: TestableVault Contract

The companion contract for this module, \`TestableVault.sol\`, demonstrates all these patterns in a single contract:

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, externalEuint64, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract TestableVault is ZamaEthereumConfig {
    address public owner;
    euint64 internal _withdrawalLimit;
    mapping(address => euint64) internal _balances;
    uint256 public depositCount;
    uint256 public withdrawalCount;

    event Deposited(address indexed user, uint256 depositIndex);
    event Withdrawn(address indexed user, uint256 withdrawalIndex);
    event WithdrawalLimitSet(address indexed setter);

    error NotOwner(address caller);

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner(msg.sender);
        _;
    }

    constructor() {
        owner = msg.sender;
        _withdrawalLimit = FHE.asEuint64(type(uint64).max);
        FHE.allowThis(_withdrawalLimit);
        FHE.allow(_withdrawalLimit, msg.sender);
    }

    function deposit(externalEuint64 encAmount, bytes calldata inputProof) external {
        euint64 amount = FHE.fromExternal(encAmount, inputProof);
        _balances[msg.sender] = FHE.add(_balances[msg.sender], amount);
        FHE.allowThis(_balances[msg.sender]);
        FHE.allow(_balances[msg.sender], msg.sender);
        depositCount++;
        emit Deposited(msg.sender, depositCount);
    }

    function withdraw(externalEuint64 encAmount, bytes calldata inputProof) external {
        euint64 amount = FHE.fromExternal(encAmount, inputProof);
        ebool hasEnough = FHE.ge(_balances[msg.sender], amount);
        ebool withinLimit = FHE.le(amount, _withdrawalLimit);
        ebool canWithdraw = FHE.and(hasEnough, withinLimit);
        euint64 withdrawAmount = FHE.select(canWithdraw, amount, FHE.asEuint64(0));
        _balances[msg.sender] = FHE.sub(_balances[msg.sender], withdrawAmount);
        FHE.allowThis(_balances[msg.sender]);
        FHE.allow(_balances[msg.sender], msg.sender);
        withdrawalCount++;
        emit Withdrawn(msg.sender, withdrawalCount);
    }

    function setWithdrawalLimit(externalEuint64 encLimit, bytes calldata inputProof) external onlyOwner {
        _withdrawalLimit = FHE.fromExternal(encLimit, inputProof);
        FHE.allowThis(_withdrawalLimit);
        FHE.allow(_withdrawalLimit, msg.sender);
        emit WithdrawalLimitSet(msg.sender);
    }

    function getBalance() external view returns (euint64) {
        return _balances[msg.sender];
    }

    function getWithdrawalLimit() external view returns (euint64) {
        return _withdrawalLimit;
    }
}
\`\`\`

Key design decisions for testability:
1. **\`depositCount\` and \`withdrawalCount\`** -- plaintext counters that tests can read without decryption
2. **Events with indices** -- every operation emits an event with a sequential index
3. **Custom errors** -- \`NotOwner(address)\` is testable with \`error.message.includes("NotOwner")\`
4. **Dual-condition withdrawal** -- tests both balance check and withdrawal limit in a single operation, demonstrating \`FHE.and()\`
5. **\`getBalance()\` uses \`msg.sender\`** -- enforces that only the balance owner can retrieve the handle

---

## 10. Test File Walkthrough

The companion test file \`TestableVault.test.ts\` contains 20+ tests organized into sections:

| Section | What it tests | Pattern demonstrated |
|---------|--------------|---------------------|
| Deployment | Initial state (owner, counters, limit) | Reading plaintext + decrypting initial values |
| Deposits | Single deposit, multiple deposits, zero deposit | Encrypt-Act-Decrypt-Assert |
| Multi-User Isolation | Independent balances for different users | Multi-signer pattern |
| Withdrawals | Partial, full, overdraft | Silent failure verification |
| Withdrawal Limit | Owner sets limit, limit enforcement | Owner-only + encrypted condition |
| Owner Functions | Transfer ownership, revert on non-owner | Error handling with try/catch |
| Sequential Operations | Complex multi-step flows | Sequential state verification |

Refer to \`test/TestableVault.test.ts\` for the complete implementation.

---

## Summary

- FHE testing follows the **encrypt -- act -- decrypt -- assert** cycle
- Use \`fhevm.createEncryptedInput()\` to create encrypted inputs; match the signer address carefully
- Use \`fhevm.userDecryptEuint(FhevmType.euintXX, handle, contractAddress, signer)\` to decrypt results
- Always use **BigInt comparisons** (\`42n\`, not \`42\`) with Chai expectations
- FHE operations on invalid conditions **do not revert** -- they silently select the fallback value (usually 0)
- Test "failure" paths by verifying **state is unchanged**, not by expecting reverts
- Use **events** and **plaintext counters** as your primary debugging tools
- Test **ACL boundaries** by attempting decryption from unauthorized signers
- Always test with **multiple signers** to verify user isolation
- Use \`FHE.makePubliclyDecryptable()\` temporarily for deep debugging, then remove it
`,
  "15-gas-optimization": `# Module 15: Gas Optimization for FHE -- Lesson

## Introduction: Why Gas Matters Even More with FHE

Every Solidity developer knows that gas optimization matters. But when you work with Fully Homomorphic Encryption on fhEVM, gas optimization is not a "nice to have" -- it is a survival skill.

Here is the core problem: a simple plaintext addition (\`uint256 a + b\`) costs roughly **3-5 gas**. An encrypted addition (\`FHE.add(euint32, euint32)\`) costs approximately **90,000 gas**. That is a factor of roughly **20,000x** more expensive. Multiply that across a realistic contract with dozens of operations, and you can hit the block gas limit with a single function call.

This has real consequences:

- **Users pay real money.** On mainnet, a single FHE-heavy transaction could cost tens or hundreds of dollars in gas fees.
- **Block gas limits are finite.** A block on Ethereum has a 30M gas limit. A contract with 300+ FHE operations in one function may simply be impossible to execute.
- **UX degrades.** Slow, expensive transactions drive users away from your dApp.

The good news: there are concrete, repeatable patterns that can reduce your FHE gas costs by 30-70% without changing the logic of your contract. This module teaches every one of them.

---

## 1. The FHE Gas Cost Model

Before you can optimize, you need to understand what things cost. The table below shows approximate gas costs for common FHE operations across all encrypted integer types. These values are representative of the fhEVM coprocessor model and may vary slightly across versions.

### Complete Gas Cost Table

| Operation | euint8 | euint16 | euint32 | euint64 | euint128 | euint256 |
|-----------|--------|---------|---------|---------|----------|----------|
| \`FHE.add\` (enc+enc) | ~50k | ~65k | ~90k | ~130k | ~180k | ~250k |
| \`FHE.add\` (enc+plain) | ~35k | ~45k | ~65k | ~95k | ~135k | ~190k |
| \`FHE.sub\` (enc-enc) | ~50k | ~65k | ~90k | ~130k | ~180k | ~250k |
| \`FHE.mul\` (enc*enc) | ~120k | ~150k | ~200k | ~300k | ~450k | ~600k |
| \`FHE.mul\` (enc*plain) | ~80k | ~100k | ~140k | ~210k | ~320k | ~430k |
| \`FHE.div\` (enc/plain) | ~50k | ~65k | ~90k | ~130k | ~180k | ~250k |
| \`FHE.rem\` (enc%plain) | ~50k | ~65k | ~90k | ~130k | ~180k | ~250k |
| \`FHE.select\` | ~45k | ~50k | ~60k | ~80k | ~110k | ~150k |
| \`FHE.eq\` | ~45k | ~50k | ~60k | ~80k | ~110k | ~150k |
| \`FHE.ne\` | ~45k | ~50k | ~60k | ~80k | ~110k | ~150k |
| \`FHE.gt\` / \`FHE.lt\` | ~45k | ~50k | ~60k | ~80k | ~110k | ~150k |
| \`FHE.ge\` / \`FHE.le\` | ~45k | ~50k | ~60k | ~80k | ~110k | ~150k |
| \`FHE.min\` / \`FHE.max\` | ~90k | ~100k | ~120k | ~160k | ~220k | ~300k |
| \`FHE.and\` / \`FHE.or\` | ~30k | ~35k | ~45k | ~60k | ~85k | ~120k |
| \`FHE.xor\` | ~30k | ~35k | ~45k | ~60k | ~85k | ~120k |
| \`FHE.not\` | ~25k | ~30k | ~40k | ~55k | ~75k | ~110k |
| \`FHE.neg\` | ~45k | ~55k | ~75k | ~110k | ~155k | ~215k |
| \`FHE.shl\` / \`FHE.shr\` | ~90k | ~100k | ~120k | ~160k | ~220k | ~300k |
| \`FHE.rotl\` / \`FHE.rotr\` | ~90k | ~100k | ~120k | ~160k | ~220k | ~300k |
| \`FHE.randEuintXX\` | ~70k | ~90k | ~120k | ~170k | ~230k | ~310k |
| \`FHE.asEuintXX\` (cast) | ~30k | ~35k | ~45k | ~65k | ~90k | ~125k |

### Key Observations

1. **Multiplication is the most expensive arithmetic operation** -- roughly 2x the cost of addition at every type size.
2. **Plaintext operands are 25-35% cheaper** than encrypted-encrypted variants.
3. **Larger types cost more** -- going from euint8 to euint64 roughly doubles or triples the cost for most operations.
4. **Comparisons are relatively cheap** -- similar cost to addition.
5. **Bitwise operations are the cheapest** -- useful when you can express logic with AND/OR/XOR.
6. **Random number generation scales with type size** -- generating a random euint256 is ~4x more expensive than euint8.

### The Cost of Type Conversion

Converting between types with \`FHE.asEuintXX()\` itself costs gas. If you are frequently upcasting from euint8 to euint32 within a function, those casts add up. Design your types at the contract level to avoid unnecessary conversions.

---

## 2. Optimization Strategy 1: Choose the Right Type Size

This is the simplest and often the most impactful optimization. If a value is guaranteed to fit in 8 bits, use \`euint8\` instead of \`euint32\` or \`euint64\`.

### Examples of Right-Sized Types

| Data | Range | Best Type |
|------|-------|-----------|
| Age | 0 -- 255 | \`euint8\` |
| Percentage | 0 -- 100 | \`euint8\` |
| Year | 2000 -- 2100 | \`euint16\` |
| Token balance | 0 -- 2^64 | \`euint64\` |
| Vote count (small DAO) | 0 -- 65535 | \`euint16\` |
| Boolean flag | 0 or 1 | \`ebool\` |

### Code Example

\`\`\`solidity
// INEFFICIENT: uses euint64 for age (0-255)
euint64 private _age;

function setAge(uint64 age) external {
    _age = FHE.asEuint64(age);           // ~65k gas for cast
    _age = FHE.add(_age, FHE.asEuint64(1)); // ~130k gas for add
    // Total: ~195k gas
}

// OPTIMIZED: uses euint8 for age
euint8 private _age;

function setAge(uint8 age) external {
    _age = FHE.asEuint8(age);            // ~30k gas for cast
    _age = FHE.add(_age, 1);             // ~35k gas for add (plaintext!)
    // Total: ~65k gas -- 67% savings!
}
\`\`\`

### When You Cannot Use Small Types

Sometimes you need the range. Token balances in DeFi often require \`euint64\` or even \`euint128\`. That is fine -- do not artificially truncate data. The point is: do not use a bigger type when a smaller one is sufficient.

---

## 3. Optimization Strategy 2: Use Plaintext Operands

When one of the two operands in an FHE operation is a known constant or a value that does not need to be secret, pass it as a plaintext. The FHE coprocessor can optimize the circuit when it knows one operand is in the clear.

### The Rule

If the second operand is **not secret**, always pass it as a plaintext:

\`\`\`solidity
// INEFFICIENT: encrypts a known constant, then adds
euint32 enc = FHE.asEuint32(value);
euint32 ten = FHE.asEuint32(10);     // unnecessary encryption
euint32 result = FHE.add(enc, ten);   // enc+enc: ~90k gas
// Total: ~135k gas (45k cast + 90k add)

// OPTIMIZED: plaintext second operand
euint32 enc = FHE.asEuint32(value);
euint32 result = FHE.add(enc, 10);    // enc+plain: ~65k gas
// Total: ~110k gas (45k cast + 65k add) -- 19% savings on this pair alone
\`\`\`

### Which Operations Support Plaintext Operands?

All of the following accept a plaintext as the second (right-hand) operand:

- Arithmetic: \`add\`, \`sub\`, \`mul\`, \`rem\`
- Comparison: \`eq\`, \`ne\`, \`lt\`, \`le\`, \`gt\`, \`ge\`
- Min/Max: \`min\`, \`max\`
- Bitwise: \`and\`, \`or\`, \`xor\`
- Shift/Rotate: \`shl\`, \`shr\`, \`rotl\`, \`rotr\`

**Division** (\`div\`) already requires a plaintext divisor -- you cannot divide by an encrypted value.

### Common Mistake: Double Encryption

A frequent pattern we see in beginner code:

\`\`\`solidity
// BAD: encrypts "1" to increment
euint32 one = FHE.asEuint32(1);
balance = FHE.add(balance, one);

// GOOD: uses plaintext "1"
balance = FHE.add(balance, 1);
\`\`\`

The savings seem small per call, but in a loop or a contract called thousands of times, they compound.

---

## 4. Optimization Strategy 3: Minimize the Number of FHE Operations

Every FHE operation has a significant fixed cost. Reducing the total number of operations is often more impactful than optimizing individual ones.

### Combine Conditions

Instead of evaluating two conditions with separate comparisons and selects, combine them:

\`\`\`solidity
// INEFFICIENT: 2 comparisons + 2 selects = 4 FHE ops
ebool tooLow = FHE.lt(enc, minVal);
euint32 step1 = FHE.select(tooLow, minVal, enc);
ebool tooHigh = FHE.gt(step1, maxVal);
euint32 result = FHE.select(tooHigh, maxVal, step1);
// 4 FHE ops: lt (~60k) + select (~60k) + gt (~60k) + select (~60k) = ~240k

// OPTIMIZED: 2 built-in ops
euint32 result = FHE.min(FHE.max(enc, minVal), maxVal);
// 2 FHE ops: max (~120k) + min (~120k) = ~240k
// Same gas in this case, but simpler code and fewer storage writes
\`\`\`

### Pre-compute in Plaintext

Anything that can be computed in plaintext should be computed in plaintext:

\`\`\`solidity
// INEFFICIENT: computes discount in encrypted space
euint32 price = FHE.asEuint32(100);
euint32 discountRate = FHE.asEuint32(10);
euint32 discountAmount = FHE.mul(price, discountRate);
euint32 finalPrice = FHE.sub(price, FHE.div(discountAmount, 100));
// 4 FHE ops!

// OPTIMIZED: apply 10% discount = multiply by 90/100
euint32 price = FHE.asEuint32(100);
euint32 finalPrice = FHE.mul(price, 90);
finalPrice = FHE.div(finalPrice, 100);
// 2 FHE ops -- 50% fewer operations
\`\`\`

### Avoid Redundant Work

Watch for patterns where you compute the same encrypted value multiple times:

\`\`\`solidity
// INEFFICIENT: computes isEligible twice
function checkAndProcess(euint32 age) internal {
    ebool isAdult = FHE.ge(age, 18);
    // ... some logic using isAdult ...

    // Later in the same function:
    ebool isAdultAgain = FHE.ge(age, 18); // redundant!
}

// OPTIMIZED: compute once, reuse
function checkAndProcess(euint32 age) internal {
    ebool isAdult = FHE.ge(age, 18);
    // ... use isAdult everywhere it is needed ...
}
\`\`\`

---

## 5. Optimization Strategy 4: Batch Processing

In traditional Solidity, individual transactions are cheap enough that making three separate calls is often fine. With FHE, each transaction has a base overhead (21,000 gas for the transaction itself, plus contract call overhead). Batching multiple updates into a single transaction amortizes this overhead.

### Example: Updating Multiple Balances

\`\`\`solidity
// INEFFICIENT: three separate transactions
function updateBalanceA(uint32 amount) external {
    _balanceA = FHE.add(_balanceA, amount);
    FHE.allowThis(_balanceA);
    FHE.allow(_balanceA, msg.sender);
}

function updateBalanceB(uint32 amount) external {
    _balanceB = FHE.add(_balanceB, amount);
    FHE.allowThis(_balanceB);
    FHE.allow(_balanceB, msg.sender);
}

function updateBalanceC(uint32 amount) external {
    _balanceC = FHE.add(_balanceC, amount);
    FHE.allowThis(_balanceC);
    FHE.allow(_balanceC, msg.sender);
}
// 3 transactions: 3 x 21k base + 3 x FHE ops + 3 x SSTORE

// OPTIMIZED: one batched transaction
function updateAllBalances(uint32 amtA, uint32 amtB, uint32 amtC) external {
    _balanceA = FHE.add(_balanceA, amtA);
    _balanceB = FHE.add(_balanceB, amtB);
    _balanceC = FHE.add(_balanceC, amtC);
    FHE.allowThis(_balanceA);
    FHE.allowThis(_balanceB);
    FHE.allowThis(_balanceC);
    FHE.allow(_balanceA, msg.sender);
    FHE.allow(_balanceB, msg.sender);
    FHE.allow(_balanceC, msg.sender);
}
// 1 transaction: 1 x 21k base + 3 x FHE ops + 3 x SSTORE
// Saves ~42k gas from avoided transaction overhead
\`\`\`

### When Batching Helps Most

- Contracts with multiple state updates per user action (e.g., updating balances, counters, and timestamps)
- Admin operations that configure multiple parameters
- Batch minting or transferring tokens

### When Batching Does NOT Help

- If the batch function hits the block gas limit, it defeats the purpose
- If individual operations need to be independently authorized

---

## 6. Optimization Strategy 5: Caching and Storage Trade-offs

If an encrypted value is computed from other encrypted values, and those source values do not change often, **cache the result** instead of recomputing it every time.

### Example: Tax Rate Calculation

\`\`\`solidity
// INEFFICIENT: recomputes tax rate from components every call
function applyTax(uint32 price) external {
    euint32 baseTax   = FHE.asEuint32(10);
    euint32 surcharge = FHE.asEuint32(5);
    euint32 taxRate   = FHE.add(baseTax, surcharge); // recomputed!
    euint32 encPrice  = FHE.asEuint32(price);
    _result = FHE.mul(encPrice, taxRate);
    // 4 FHE ops: 2 casts + 1 add + 1 mul = ~375k gas
}

// OPTIMIZED: cache the tax rate, computed once
euint32 private _cachedTaxRate;

function setupTaxRate() external onlyOwner {
    euint32 baseTax   = FHE.asEuint32(10);
    euint32 surcharge = FHE.asEuint32(5);
    _cachedTaxRate = FHE.add(baseTax, surcharge);
    FHE.allowThis(_cachedTaxRate);
    // One-time cost: ~170k gas
}

function applyTax(uint32 price) external {
    euint32 encPrice = FHE.asEuint32(price);
    _result = FHE.mul(encPrice, _cachedTaxRate);
    // Per-call cost: 1 cast + 1 mul = ~245k gas (35% savings per call!)
}
\`\`\`

### The Storage Trade-off

Storing an encrypted value in a state variable (\`SSTORE\`) costs gas too -- roughly 20,000 gas for a new slot, 5,000 for an update. So the trade-off is:

| Scenario | Better Approach |
|----------|-----------------|
| Value recomputed 1-2 times | Recompute (storage cost not worth it) |
| Value recomputed 3+ times | Cache it (amortized savings exceed storage cost) |
| Value changes every block | Recompute (cache invalidated immediately) |
| Value changes rarely | Cache it (big win) |

---

## 7. Optimization Strategy 6: Lazy Evaluation

Lazy evaluation means deferring an expensive computation until its result is actually needed. If the result may never be needed (e.g., the user might overwrite it first), you save the cost entirely.

### Example: Deferred Squaring

\`\`\`solidity
// INEFFICIENT: computes square immediately on every update
function updateValue(uint32 value) external {
    euint32 enc = FHE.asEuint32(value);
    euint32 squared = FHE.mul(enc, enc);    // expensive!
    _result = FHE.add(squared, 1);
    // 3 FHE ops every call
}

// OPTIMIZED: stores the base value, defers the expensive part
euint32 private _base;
bool private _dirty;

function updateValue(uint32 value) external {
    _base = FHE.asEuint32(value);
    FHE.allowThis(_base);
    _dirty = true;
    // 1 FHE op -- defers the mul
}

function computeResult() external {
    require(_dirty, "Nothing to compute");
    euint32 squared = FHE.mul(_base, _base);
    _result = FHE.add(squared, 1);
    _dirty = false;
    // 2 FHE ops -- only when result is actually needed
}
\`\`\`

If \`updateValue\` is called 10 times before \`computeResult\` is called once, you save 9 multiplications worth of gas (9 x ~200k = ~1.8M gas saved).

### When Lazy Evaluation Works

- Values are updated more frequently than they are read
- Expensive computations (mul, shifts) are involved
- The contract can tolerate a "stale" intermediate state

### When It Does NOT Work

- Every update must be immediately visible to other contracts
- The computation is cheap (addition) and not worth the complexity

---

## 8. Gas Profiling Technique

You cannot optimize what you cannot measure. Here is how to profile FHE gas usage in your Hardhat tests.

### Using \`receipt.gasUsed\`

\`\`\`typescript
it("should measure gas for an FHE operation", async function () {
  const tx = await contract.someFunction(42);
  const receipt = await tx.wait();
  console.log(\`Gas used: \${receipt.gasUsed}\`);
});
\`\`\`

### Comparing Two Implementations

\`\`\`typescript
it("should compare inefficient vs optimized", async function () {
  const tx1 = await contract.inefficient_version(42);
  const receipt1 = await tx1.wait();

  const tx2 = await contract.optimized_version(42);
  const receipt2 = await tx2.wait();

  const savings = receipt1.gasUsed - receipt2.gasUsed;
  const pct = (Number(savings) * 100) / Number(receipt1.gasUsed);
  console.log(\`Savings: \${savings} gas (\${pct.toFixed(1)}%)\`);
});
\`\`\`

### Setting Gas Budgets

For production contracts, establish maximum gas budgets per function:

\`\`\`typescript
it("transfer should use less than 500k gas", async function () {
  const tx = await contract.transfer(recipient, 100);
  const receipt = await tx.wait();
  expect(receipt.gasUsed).to.be.lessThan(500_000n);
});
\`\`\`

This acts as a regression test: if a future refactor accidentally adds FHE operations, the test will fail.

### The GasBenchmark Contract

The \`GasBenchmark.sol\` contract in this module provides isolated benchmarks for individual FHE operations. Run the tests and examine the output:

\`\`\`bash
npx hardhat test test/GasBenchmark.test.ts
\`\`\`

Each test logs the gas cost of a single operation, giving you a real-world reference table for your specific fhEVM version.

---

## 9. Real-World Example: Optimizing a Confidential ERC-20 Transfer

Let us walk through a realistic optimization of a confidential token transfer function.

### Before: Naive Implementation

\`\`\`solidity
function transfer(address to, uint32 amount) external {
    euint32 encAmount = FHE.asEuint32(amount);

    // Check balance >= amount (encrypted comparison)
    ebool hasEnough = FHE.ge(_balances[msg.sender], encAmount);

    // Compute new balances
    euint32 newSenderBal   = FHE.sub(_balances[msg.sender], encAmount);
    euint32 newReceiverBal = FHE.add(_balances[to], encAmount);

    // Conditionally apply (if balance was sufficient)
    _balances[msg.sender] = FHE.select(hasEnough, newSenderBal, _balances[msg.sender]);
    _balances[to]         = FHE.select(hasEnough, newReceiverBal, _balances[to]);

    // ACL
    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);
}
// Operations: 1 cast + 1 ge + 1 sub + 1 add + 2 select = 6 FHE ops
// Estimated gas: ~45k + ~60k + ~90k + ~90k + ~120k = ~405k
\`\`\`

### After: Optimized Implementation

\`\`\`solidity
function transfer(address to, uint32 amount) external {
    // Use plaintext operand for the amount (no cast needed for comparisons/arithmetic)
    ebool hasEnough = FHE.ge(_balances[msg.sender], amount);  // enc vs plain

    euint32 newSenderBal   = FHE.sub(_balances[msg.sender], amount);  // enc - plain
    euint32 newReceiverBal = FHE.add(_balances[to], amount);           // enc + plain

    _balances[msg.sender] = FHE.select(hasEnough, newSenderBal, _balances[msg.sender]);
    _balances[to]         = FHE.select(hasEnough, newReceiverBal, _balances[to]);

    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);
}
// Operations: 1 ge(plain) + 1 sub(plain) + 1 add(plain) + 2 select = 5 FHE ops
// Estimated gas: ~45k + ~65k + ~65k + ~120k = ~295k
// Savings: ~110k gas (27%)
\`\`\`

The only change: we removed the \`FHE.asEuint32(amount)\` cast and used the plaintext \`amount\` directly as the second operand in \`ge\`, \`sub\`, and \`add\`. This eliminated the cast entirely and made the arithmetic operations cheaper.

---

## 10. Real-World Example: Optimizing a Voting Contract

### Before: Naive Voting

\`\`\`solidity
function vote(uint32 candidateId, uint32 weight) external {
    euint32 encWeight = FHE.asEuint32(weight);
    euint32 encId     = FHE.asEuint32(candidateId);

    // Check if voter is eligible (weight > 0)
    ebool isEligible = FHE.gt(encWeight, FHE.asEuint32(0));

    // Check if candidate is valid (id < numCandidates)
    ebool isValid = FHE.lt(encId, FHE.asEuint32(numCandidates));

    // Both must be true
    ebool canVote = FHE.and(isEligible, isValid);

    // Add weight to candidate tally
    euint32 newTally = FHE.add(_tallies[candidateId], encWeight);
    _tallies[candidateId] = FHE.select(canVote, newTally, _tallies[candidateId]);

    FHE.allowThis(_tallies[candidateId]);
}
// 4 casts + 2 comparisons + 1 and + 1 add + 1 select = 9 FHE ops
\`\`\`

### After: Optimized Voting

\`\`\`solidity
function vote(uint32 candidateId, uint32 weight) external {
    require(candidateId < numCandidates, "Invalid candidate"); // plaintext check!
    require(weight > 0, "Zero weight");                         // plaintext check!

    // Both checks were on publicly-known values -- no FHE needed
    _tallies[candidateId] = FHE.add(_tallies[candidateId], weight); // enc + plain

    FHE.allowThis(_tallies[candidateId]);
}
// 0 casts + 0 comparisons + 1 add(plain) = 1 FHE op
// Savings: 8 FHE operations eliminated!
\`\`\`

The key insight: \`candidateId\` and \`weight\` were **not secret** in the original design. The only secret is the running tally. By moving the validation to plaintext \`require()\` statements, we eliminated 8 of 9 FHE operations.

> **Lesson:** Before encrypting a value, ask yourself: "Does this value actually need to be confidential?" If not, keep it in plaintext.

---

## 11. Optimization Checklist

Use this checklist when reviewing your FHE contracts:

- [ ] **Right-sized types?** Are you using the smallest encrypted type that fits your data?
- [ ] **Plaintext operands?** For every FHE operation, is the second operand truly secret? If not, pass it as plaintext.
- [ ] **Minimum operations?** Can any FHE operations be eliminated by refactoring or pre-computing in plaintext?
- [ ] **Batch updates?** Are there multiple state changes that can be combined into a single transaction?
- [ ] **Cached intermediates?** Are there encrypted values being recomputed that could be stored?
- [ ] **Lazy evaluation?** Are there expensive computations that can be deferred?
- [ ] **Redundant comparisons?** Can \`gt + select\` be replaced with \`max\`? Can \`lt + select\` be replaced with \`min\`?
- [ ] **Unnecessary casts?** Are you calling \`FHE.asEuintXX()\` on values that could be passed as plaintext operands directly?
- [ ] **Gas budget tests?** Do your tests verify that key functions stay within a gas budget?
- [ ] **Profiled?** Have you measured actual gas usage with \`receipt.gasUsed\`?

---

## 12. Common Anti-Patterns

### Anti-Pattern 1: "Encrypt Everything"

\`\`\`solidity
// BAD: encrypts the contract owner address check
ebool isOwner = FHE.eq(FHE.asEuint32(uint32(uint160(msg.sender))),
                       FHE.asEuint32(uint32(uint160(owner))));

// GOOD: owner is public, use plaintext
require(msg.sender == owner, "Not owner");
\`\`\`

### Anti-Pattern 2: "One Operation Per Transaction"

\`\`\`solidity
// BAD: separate transactions for each step
function step1_addBalance(uint32 amt) external { ... }
function step2_checkLimit() external { ... }
function step3_applyFee() external { ... }

// GOOD: combine into one
function updateBalance(uint32 amt) external {
    // add + check + fee in one transaction
}
\`\`\`

### Anti-Pattern 3: "Ignoring Type Sizes"

\`\`\`solidity
// BAD: using euint256 for a boolean flag
euint256 private _isActive;

// GOOD: use ebool
ebool private _isActive;
\`\`\`

### Anti-Pattern 4: "Recomputing Constants"

\`\`\`solidity
// BAD: encrypts "100" every time the function is called
function applyPercent(euint32 value) internal returns (euint32) {
    return FHE.div(FHE.mul(value, FHE.asEuint32(percentage)), FHE.asEuint32(100));
}

// GOOD: use plaintext for the constant 100
function applyPercent(euint32 value) internal returns (euint32) {
    return FHE.div(FHE.mul(value, percentage), 100);
}
\`\`\`

---

## 13. Summary of Gas Savings by Pattern

| Pattern | Typical Savings | Difficulty |
|---------|----------------|------------|
| Right-sized types | 30-60% | Easy |
| Plaintext operands | 15-35% | Easy |
| Minimize operations | 20-80% | Medium |
| Batch processing | 10-20% (tx overhead) | Easy |
| Caching | 25-50% (on repeated calls) | Medium |
| Lazy evaluation | 0-90% (depends on access pattern) | Hard |
| Redundant select elimination | 10-30% | Medium |
| Avoid unnecessary casts | 5-15% | Easy |

---

## 14. What is Next?

In the exercise for this module, you will be given a deliberately inefficient confidential token contract. Your task is to apply the patterns from this lesson to reduce its gas consumption by at least 30%. Use the gas profiling techniques to measure your progress.

Then, in the quiz, you will test your understanding of the gas cost model and optimization strategies.

---

## Key Takeaways

1. FHE operations cost 10-100x more gas than plaintext equivalents. Optimization is not optional.
2. The single biggest win is usually **using plaintext operands** -- it requires zero architectural changes.
3. **Right-sizing types** is the second easiest win -- use euint8 when 8 bits suffice.
4. Always **measure gas** with \`receipt.gasUsed\` before and after optimizing.
5. Ask yourself for every encrypted value: "Does this actually need to be secret?"
`,
  "16-security": `# Module 16: Security Best Practices for FHE -- Lesson

## Introduction: FHE Security is Different

Security in traditional smart contracts focuses on reentrancy, integer overflow, access control, and front-running. The data itself is always public -- anyone can read any storage slot. The security model is about protecting *logic*, not *data*.

FHE contracts flip this entirely. The data is encrypted. Nobody can read storage slots and extract meaningful values. This is a massive privacy win, but it introduces a completely new attack surface that most Solidity developers have never encountered.

**The new attack surface is metadata.**

Even when data is encrypted, an attacker can observe:
- **Gas consumption** -- Different execution paths consume different gas
- **Transaction success or failure** -- Reverts vs. successful execution
- **Storage access patterns** -- Which slots are read/written
- **Function selectors** -- Which function was called (always visible)
- **Timing** -- When transactions are submitted relative to other events
- **ACL state** -- Who has been granted access to which ciphertext handles

These metadata channels can reveal information about encrypted values. The core discipline of FHE security is ensuring that **no metadata leaks correlate with encrypted state**.

This lesson covers the seven most critical FHE-specific vulnerabilities and the patterns to prevent them.

---

## 1. Vulnerability: Information Leakage via Gas Consumption

### The Problem

In traditional Solidity, branching on a condition is harmless because the condition is already public. In FHE contracts, branching on an encrypted condition creates a **gas side channel**.

Consider this vulnerable pattern:

\`\`\`solidity
// VULNERABLE: Gas reveals the encrypted condition
function vulnerableTransfer(address to, uint64 amount) external {
    euint64 encAmount = FHE.asEuint64(amount);
    ebool hasBalance = FHE.ge(_balances[msg.sender], encAmount);

    if (FHE.decrypt(hasBalance)) {
        // Branch A: ~400k gas (FHE.sub + FHE.add + 4 ACL calls)
        _balances[msg.sender] = FHE.sub(_balances[msg.sender], encAmount);
        _balances[to] = FHE.add(_balances[to], encAmount);
        FHE.allowThis(_balances[msg.sender]);
        FHE.allow(_balances[msg.sender], msg.sender);
        FHE.allowThis(_balances[to]);
        FHE.allow(_balances[to], to);
    } else {
        // Branch B: ~30k gas (no FHE operations)
        // Do nothing
    }
}
\`\`\`

An observer watching the transaction's gas usage sees:
- **~400k gas consumed** --> the sender had sufficient balance
- **~30k gas consumed** --> the sender had insufficient balance

The encrypted balance is leaked through gas consumption, completely defeating the purpose of encryption.

### The Fix: Uniform Execution with FHE.select()

\`FHE.select()\` is the FHE equivalent of a ternary operator, but it executes **both paths** and selects the result based on the encrypted condition. Gas consumption is identical regardless of which value is selected.

\`\`\`solidity
// SECURE: Uniform gas consumption
function secureTransfer(address to, uint64 amount) external {
    euint64 encAmount = FHE.asEuint64(amount);
    ebool hasBalance = FHE.ge(_balances[msg.sender], encAmount);

    // Both paths computed, result selected -- same gas either way
    euint64 actualAmount = FHE.select(
        hasBalance,
        encAmount,           // if true: transfer the amount
        FHE.asEuint64(0)     // if false: transfer 0
    );

    _balances[msg.sender] = FHE.sub(_balances[msg.sender], actualAmount);
    _balances[to] = FHE.add(_balances[to], actualAmount);

    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);
}
\`\`\`

**Key insight:** \`FHE.select()\` costs the same gas regardless of the condition's value. The observer sees identical gas consumption whether the transfer happened or not.

### The Rule

> **Never branch (if/else, while, for with encrypted bounds) on an encrypted condition. Always use FHE.select().**

### Additional Gas Leak Vectors

Beyond if/else, watch for these subtle gas leaks:

1. **Early returns:** \`if (condition) return;\` -- the return vs. continuation has different gas
2. **Dynamic loops:** \`for (uint i = 0; i < encryptedCount; i++)\` -- loop count reveals the encrypted value
3. **Storage writes:** Conditional storage writes (writing to a slot vs. not) have different gas costs
4. **External calls:** Calling another contract conditionally reveals the condition

All of these must be replaced with uniform execution patterns.

---

## 2. Vulnerability: Missing ACL Permissions

### The Problem

Every FHE operation produces a **new ciphertext** with a **new handle**. The new handle has an **empty ACL** -- no address has access, not even the contract that created it. If you forget to set the ACL:

- The **contract** cannot use the value in future transactions (operations on it will fail)
- The **user** cannot decrypt their own data (decryption requests are rejected)

\`\`\`solidity
// VULNERABLE: No ACL after state update
function vulnerableMint(address to, uint64 amount) external onlyOwner {
    _balances[to] = FHE.asEuint64(amount);
    // Missing: FHE.allowThis(_balances[to]);
    // Missing: FHE.allow(_balances[to], to);
    // The balance exists but nobody can use it!
}
\`\`\`

### The Fix: ACL After Every State Update

\`\`\`solidity
// SECURE: Full ACL management
function secureMint(address to, uint64 amount) external onlyOwner {
    _balances[to] = FHE.asEuint64(amount);
    FHE.allowThis(_balances[to]);      // Contract can use it
    FHE.allow(_balances[to], to);      // User can decrypt it
}
\`\`\`

### The ACL Checklist

After **every** FHE operation that writes to state, you must:

1. **\`FHE.allowThis(handle)\`** -- Always. The contract needs access for future operations.
2. **\`FHE.allow(handle, user)\`** -- For every user who should be able to decrypt the value.
3. Consider \`FHE.allowTransient(handle, addr)\` for inter-contract calls within the same transaction.

### Common ACL Mistakes

| Mistake | Consequence |
|---------|-------------|
| Forgot \`allowThis\` after \`FHE.add()\` | Contract cannot use the sum in the next tx |
| Forgot \`allow(h, user)\` after transfer | Recipient cannot decrypt their new balance |
| Set ACL on old handle, not new handle | ACL is per-handle, not per-variable |
| Used \`allow\` for temporary inter-contract call | Wasted gas; use \`allowTransient\` instead |
| Forgot to re-set ACL in every branch of select | Only one branch's ACL is applied |

### ACL After Select

A subtle case: when you use \`FHE.select()\`, the result is a new handle regardless of which branch was selected. You must set ACL on the result:

\`\`\`solidity
_balances[msg.sender] = FHE.select(condition, valueA, valueB);
// The result is a NEW handle -- ACL is empty
FHE.allowThis(_balances[msg.sender]);
FHE.allow(_balances[msg.sender], msg.sender);
\`\`\`

---

## 3. Vulnerability: Unvalidated Encrypted Inputs

### The Problem

When users submit encrypted inputs to your contract, you must validate them before use. An unvalidated input could be a malformed ciphertext, an uninitialized handle, or a handle from a different contract's ACL domain.

\`\`\`solidity
// VULNERABLE: No input validation
function vulnerableDeposit(
    externalEuint64 encAmount,
    bytes calldata inputProof
) external {
    euint64 amount = FHE.fromExternal(encAmount, inputProof);
    // Missing: require(FHE.isInitialized(amount), "Invalid input");

    _balances[msg.sender] = FHE.add(_balances[msg.sender], amount);
    // If amount is an invalid handle, this add may produce garbage
}
\`\`\`

### The Fix: Always Validate

\`\`\`solidity
// SECURE: Full input validation
function secureDeposit(
    externalEuint64 encAmount,
    bytes calldata inputProof
) external {
    // Step 1: Convert and verify the ZK proof
    euint64 amount = FHE.fromExternal(encAmount, inputProof);

    // Step 2: Check the resulting handle is valid
    require(FHE.isInitialized(amount), "Invalid encrypted input");

    // Step 3: Now safe to use
    _balances[msg.sender] = FHE.add(_balances[msg.sender], amount);
    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
}
\`\`\`

### Validation Checklist

1. **\`FHE.fromExternal(encValue, inputProof)\`** -- Always use this to convert external inputs. It validates the ZK proof that the ciphertext was correctly formed.
2. **\`FHE.isInitialized(handle)\`** -- Check that the handle is valid before use. This catches zero handles and uninitialized state.
3. **Check state variables too** -- Before using a stored encrypted value, verify it has been initialized:
   \`\`\`solidity
   require(FHE.isInitialized(_balances[user]), "User has no balance");
   \`\`\`

---

## 4. Vulnerability: Denial of Service via Unbounded FHE Operations

### The Problem

FHE operations are computationally expensive. Each operation costs between 50,000 and 600,000 gas depending on the type and operand size. A function with unbounded FHE operations inside a loop is a DoS vector.

\`\`\`solidity
// VULNERABLE: No cap on array size
function vulnerableBatchAdd(
    address[] calldata recipients,
    uint64 amount
) external onlyOwner {
    for (uint256 i = 0; i < recipients.length; i++) {
        _balances[recipients[i]] = FHE.add(
            _balances[recipients[i]],
            FHE.asEuint64(amount)
        );
        FHE.allowThis(_balances[recipients[i]]);
        FHE.allow(_balances[recipients[i]], recipients[i]);
    }
}
\`\`\`

With 3 FHE operations per iteration (add, allowThis, allow) at ~200k gas each, a batch of 50 recipients costs **~30M gas** -- at or beyond the block gas limit. An attacker who controls the input array can reliably DoS the function.

### The Fix: Bound All Loops and Rate-Limit

\`\`\`solidity
uint256 public constant MAX_BATCH = 10;

function secureBatchAdd(
    address[] calldata recipients,
    uint64 amount
) external onlyOwner {
    require(recipients.length <= MAX_BATCH, "Batch too large");

    for (uint256 i = 0; i < recipients.length; i++) {
        _balances[recipients[i]] = FHE.add(
            _balances[recipients[i]],
            FHE.asEuint64(amount)
        );
        FHE.allowThis(_balances[recipients[i]]);
        FHE.allow(_balances[recipients[i]], recipients[i]);
    }
}
\`\`\`

### Additional DoS Mitigations

1. **Rate limiting per user:**
   \`\`\`solidity
   mapping(address => uint256) private _lastOpBlock;
   uint256 public cooldownBlocks = 5;

   modifier rateLimited() {
       require(
           block.number >= _lastOpBlock[msg.sender] + cooldownBlocks,
           "Rate limited"
       );
       _lastOpBlock[msg.sender] = block.number;
       _;
   }
   \`\`\`

2. **Require deposits for expensive operations:** Charge a fee proportional to the FHE computation cost. This economically discourages DoS.

3. **Pagination:** For operations over large datasets, process items in pages rather than all at once.

### Gas Cost Reference for FHE Operations

| Operation | Approximate Gas Cost |
|-----------|---------------------|
| \`FHE.asEuintXX()\` (plaintext to encrypted) | ~50k |
| \`FHE.add()\`, \`FHE.sub()\` | ~150k-200k |
| \`FHE.mul()\` | ~300k-400k |
| \`FHE.le()\`, \`FHE.ge()\`, \`FHE.eq()\` | ~150k-200k |
| \`FHE.select()\` | ~200k-300k |
| \`FHE.and()\`, \`FHE.or()\`, \`FHE.xor()\` | ~150k |
| \`FHE.allowThis()\`, \`FHE.allow()\` | ~50k-100k |
| \`FHE.fromExternal()\` | ~200k-300k |

Use these estimates to calculate maximum loop iterations before hitting gas limits.

---

## 5. Vulnerability: Encrypted Error Handling

### The Problem

In traditional Solidity, you communicate errors via \`require()\` and \`revert()\`. But in FHE contracts, **reverting based on an encrypted condition leaks information**.

\`\`\`solidity
// VULNERABLE: Revert reveals the encrypted condition
function vulnerableWithdraw(uint64 amount) external {
    euint64 encAmount = FHE.asEuint64(amount);
    ebool hasBalance = FHE.ge(_balances[msg.sender], encAmount);

    // If we could decrypt and revert here, the revert itself
    // tells the world that the user's balance is < amount.
    // Transaction success tells the world balance >= amount.
    // Either way, information about the encrypted balance is leaked.
}
\`\`\`

### The Fix: The LastError Pattern

Instead of reverting, always succeed and store an encrypted error code that only the user can decrypt.

\`\`\`solidity
// Error codes
uint8 constant ERR_NONE = 0;
uint8 constant ERR_INSUFFICIENT_BALANCE = 1;
uint8 constant ERR_LIMIT_EXCEEDED = 2;

mapping(address => euint8) private _lastError;

function secureWithdraw(uint64 amount) external {
    euint64 encAmount = FHE.asEuint64(amount);
    ebool hasBalance = FHE.ge(_balances[msg.sender], encAmount);

    // Always execute -- transfer actual amount or 0
    euint64 actualAmount = FHE.select(
        hasBalance,
        encAmount,
        FHE.asEuint64(0)
    );

    _balances[msg.sender] = FHE.sub(_balances[msg.sender], actualAmount);
    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);

    // Set encrypted error code
    _lastError[msg.sender] = FHE.select(
        hasBalance,
        FHE.asEuint8(ERR_NONE),
        FHE.asEuint8(ERR_INSUFFICIENT_BALANCE)
    );
    FHE.allowThis(_lastError[msg.sender]);
    FHE.allow(_lastError[msg.sender], msg.sender);
}

// User can check their last error (only they can decrypt it)
function getLastError() external view returns (euint8) {
    require(FHE.isSenderAllowed(_lastError[msg.sender]), "No access");
    return _lastError[msg.sender];
}
\`\`\`

### When Can You Still Revert?

You can safely \`require()\` and \`revert()\` on **plaintext** conditions:

\`\`\`solidity
// SAFE: These are plaintext checks
require(msg.sender != address(0), "Zero address");          // plaintext
require(amount <= MAX_AMOUNT, "Amount too large");           // plaintext
require(msg.sender == owner, "Not owner");                   // plaintext
if (recipients.length > MAX_BATCH) revert BatchTooLarge();   // plaintext
\`\`\`

The rule is: **revert on plaintext conditions, use LastError for encrypted conditions.**

### LastError Design Patterns

Define clear error codes as contract constants:

\`\`\`solidity
uint8 public constant ERR_NONE = 0;                // Success
uint8 public constant ERR_INSUFFICIENT_BALANCE = 1; // Not enough funds
uint8 public constant ERR_LIMIT_EXCEEDED = 2;       // Over transfer limit
uint8 public constant ERR_UNAUTHORIZED = 3;         // Not permitted
uint8 public constant ERR_INVALID_AMOUNT = 4;       // Bad input value
\`\`\`

Clients decrypt the error code after each transaction to understand the outcome.

---

## 6. Vulnerability: Front-Running and MEV

### The Problem

Even though FHE encrypts the values, certain metadata is always visible on-chain:

- **Function selector** -- Everyone knows which function you called
- **Recipient address** -- In a transfer, \`to\` is usually a plaintext parameter
- **Transaction timing** -- When you submitted relative to other transactions
- **Sender address** -- Always visible as \`msg.sender\`

An attacker knows Alice called \`transfer(encryptedAmount, proof, bobAddress)\` even though the amount is encrypted. They know:
- Alice is sending tokens to Bob
- The transfer is happening right now
- If they can observe Alice's balance changing (via ACL or public decryption), they learn the amount

### Mitigations

1. **Use encrypted recipients when possible:**
   \`\`\`solidity
   // If your protocol supports it, encrypt the recipient too
   function transfer(
       externalEuint64 encAmount,
       bytes calldata amountProof,
       // Recipient could be encoded as an encrypted address
       // or use stealth address patterns
   ) external { ... }
   \`\`\`

2. **Commit-reveal for time-sensitive operations:**
   \`\`\`solidity
   // Phase 1: Submit encrypted commitment
   function commit(bytes32 commitHash) external {
       _commits[msg.sender] = commitHash;
       _commitBlock[msg.sender] = block.number;
   }

   // Phase 2: Reveal after N blocks
   function reveal(
       externalEuint64 encValue,
       bytes calldata proof,
       bytes32 salt
   ) external {
       require(
           block.number > _commitBlock[msg.sender] + REVEAL_DELAY,
           "Too early"
       );
       require(
           keccak256(abi.encodePacked(msg.sender, salt)) == _commits[msg.sender],
           "Invalid reveal"
       );
       // Process the encrypted value
   }
   \`\`\`

3. **Batch operations:** Process multiple operations in a single transaction to reduce the information leaked per operation.

4. **Avoid makePubliclyDecryptable on individual data:** Only reveal aggregate values, not per-user data.

### What FHE Does NOT Protect

| Visible to Everyone | Protected by FHE |
|---------------------|-------------------|
| Function selector (which function) | Encrypted parameter values |
| Sender address (msg.sender) | Internal encrypted state |
| Recipient address (if plaintext param) | Comparison results |
| Gas consumption | Encrypted error codes |
| Block number / timestamp | Encrypted intermediate computations |
| Transaction success / failure | Encrypted storage values |

Understanding this boundary is essential for designing secure FHE protocols.

---

## 7. Vulnerability: Misuse of makePubliclyDecryptable

### The Problem

\`FHE.makePubliclyDecryptable()\` is a powerful but dangerous function. It makes an encrypted value decryptable by **any address**. This is irreversible -- once called, the ciphertext's plaintext value is effectively public.

\`\`\`solidity
// VULNERABLE: Reveals individual user's private balance
function vulnerableRevealBalance(address user) external onlyOwner {
    FHE.makePubliclyDecryptable(_balances[user]);
    // Now ANYONE can decrypt user's balance. Privacy is destroyed.
}
\`\`\`

### Safe Uses

- Revealing **aggregate** values: total supply, vote tallies, auction results
- Revealing **game outcomes** after the game ends
- Revealing **non-sensitive** protocol parameters

### Unsafe Uses

- Individual user balances
- Personal votes before tallying
- Private bids before auction closes
- Any per-user sensitive data

### The Rule

> **Never call makePubliclyDecryptable on individual user data. Only use it for aggregate or non-sensitive values that are meant to become public.**

If you need to grant access to specific parties, use \`FHE.allow()\` instead:

\`\`\`solidity
// SECURE: Grant specific auditor access, not everyone
function grantAuditAccess(address auditor) external onlyOwner {
    FHE.allow(_balances[targetUser], auditor);
}
\`\`\`

---

## 8. Security Audit Checklist for FHE Contracts

Use this checklist when reviewing any FHE contract:

### ACL Management
- [ ] Every FHE operation that writes to state is followed by \`FHE.allowThis()\`
- [ ] Every user-facing encrypted value has \`FHE.allow(handle, user)\` set
- [ ] \`FHE.allowTransient()\` is used for inter-contract calls (not \`FHE.allow()\`)
- [ ] View functions returning encrypted handles check \`FHE.isSenderAllowed()\`
- [ ] No overly permissive ACL (granting access to addresses that do not need it)

### Information Leakage
- [ ] No \`if/else\` or \`while\` branching on encrypted conditions
- [ ] All conditional logic uses \`FHE.select()\`
- [ ] No \`require()\` or \`revert()\` on encrypted conditions
- [ ] No early returns based on encrypted state
- [ ] Gas consumption is uniform across all execution paths

### Input Validation
- [ ] All external encrypted inputs validated with \`FHE.fromExternal()\`
- [ ] \`FHE.isInitialized()\` checked after \`fromExternal()\` and before using stored handles
- [ ] No use of unvalidated handles in arithmetic operations

### DoS Prevention
- [ ] All loops with FHE operations have bounded iteration counts
- [ ] Batch operations have maximum size limits
- [ ] Rate limiting on expensive FHE operations (per-user cooldowns)
- [ ] Gas costs estimated for worst-case loop execution

### Error Handling
- [ ] LastError pattern used for encrypted conditions (no reverts)
- [ ] Error codes are encrypted and ACL-protected
- [ ] Plaintext \`require()\` only for plaintext conditions (ownership, zero address, etc.)

### Privacy
- [ ] \`FHE.makePubliclyDecryptable()\` not used on individual user data
- [ ] Only aggregate/non-sensitive values are made publicly decryptable
- [ ] Encrypted recipients considered where applicable

### Access Control
- [ ] Admin functions protected by \`onlyOwner\` or role-based modifiers
- [ ] Ownership transfer function exists and is protected
- [ ] No public functions that modify critical encrypted state without authorization
- [ ] Custom errors used for clear failure reasons on plaintext conditions

---

## 9. Practical Exercise: Auditing VulnerableDemo.sol

Let us walk through \`VulnerableDemo.sol\` and identify each vulnerability.

### Vulnerability 1: \`vulnerableMint()\`

\`\`\`solidity
function vulnerableMint(address to, uint64 amount) external onlyOwner {
    _balances[to] = FHE.asEuint64(amount);
    // MISSING: FHE.allowThis(_balances[to])
    // MISSING: FHE.allow(_balances[to], to)
}
\`\`\`

**Issue:** No ACL permissions set. The contract cannot use this balance in future transactions, and the user cannot decrypt it.

**Fix:** Add two lines after the assignment:
\`\`\`solidity
FHE.allowThis(_balances[to]);
FHE.allow(_balances[to], to);
\`\`\`

### Vulnerability 2: \`vulnerableTransfer()\`

\`\`\`solidity
if (FHE.isInitialized(hasBalance)) {
    // expensive FHE operations
    transferCount++;
}
\`\`\`

**Issue:** Branching on an encrypted-derived condition creates a gas side channel. The \`transferCount++\` also reveals information via storage writes.

**Fix:** Use \`FHE.select()\` for uniform execution:
\`\`\`solidity
euint64 actual = FHE.select(hasBalance, encAmount, FHE.asEuint64(0));
_balances[msg.sender] = FHE.sub(_balances[msg.sender], actual);
_balances[to] = FHE.add(_balances[to], actual);
\`\`\`

### Vulnerability 3: \`vulnerableDeposit()\`

\`\`\`solidity
euint64 amount = FHE.fromExternal(encAmount, inputProof);
// Missing: require(FHE.isInitialized(amount), "Invalid input");
\`\`\`

**Issue:** No validation that the encrypted input is properly initialized. A malformed input could produce undefined behavior.

**Fix:** Add the \`FHE.isInitialized()\` check immediately after \`fromExternal()\`.

### Vulnerability 4: \`vulnerableBatchAdd()\`

\`\`\`solidity
for (uint256 i = 0; i < recipients.length; i++) {
    // 3 FHE operations per iteration, no cap on recipients.length
}
\`\`\`

**Issue:** No maximum batch size. An attacker can pass thousands of addresses to exceed the block gas limit.

**Fix:** Add \`require(recipients.length <= MAX_BATCH, "Batch too large");\`

### Vulnerability 5: \`vulnerableWithdraw()\`

**Issue:** The function subtracts from the balance unconditionally. In a real-world version with a decrypt-and-revert pattern, the revert itself leaks information about the encrypted balance.

**Fix:** Use the select pattern and LastError for user feedback.

### Vulnerability 6: \`vulnerableRevealBalance()\`

\`\`\`solidity
FHE.makePubliclyDecryptable(_balances[user]);
\`\`\`

**Issue:** Destroys the user's balance privacy. Anyone can now decrypt it.

**Fix:** Use \`FHE.allow()\` to grant access to specific authorized parties only.

### Vulnerability 7: \`vulnerableOpenMint()\`

\`\`\`solidity
function vulnerableOpenMint(address to, uint64 amount) external {
    // No access control -- anyone can mint!
\`\`\`

**Issue:** No \`onlyOwner\` modifier. Any user can mint arbitrary amounts.

**Fix:** Add the \`onlyOwner\` modifier.

---

## 10. Summary

FHE security requires a fundamentally different mindset from traditional smart contract security. The data is encrypted, but the metadata is not. Your security model must account for every observable side effect of your contract's execution.

### The Seven Rules of FHE Security

1. **Never branch on encrypted conditions.** Use \`FHE.select()\` for uniform execution.
2. **Always set ACL after every FHE state update.** \`FHE.allowThis()\` + \`FHE.allow()\` on every new handle.
3. **Always validate encrypted inputs.** \`FHE.fromExternal()\` + \`FHE.isInitialized()\` on every external input.
4. **Bound all FHE loops.** Cap iterations, rate-limit, and require deposits for expensive operations.
5. **Use LastError, not revert, for encrypted conditions.** Encrypted error codes preserve privacy.
6. **Never reveal individual data.** Only use \`makePubliclyDecryptable()\` for aggregate values.
7. **Protect admin functions.** Access control is still essential -- encryption does not replace authorization.

### Mental Model

Think of your FHE contract as a black box. An observer can see:
- What goes in (function call, sender, gas limit)
- What comes out (success/failure, gas used, events emitted)
- How long it takes (block inclusion timing)

Your job is to ensure that these observable properties reveal **nothing** about the encrypted state inside the box. Every function should consume the same gas, emit the same events, and succeed or fail based only on plaintext conditions, regardless of the encrypted values involved.

This is the discipline of FHE security.

---

## References

- [Zama fhEVM Documentation](https://docs.zama.ai/fhevm)
- [FHEVM Security Considerations](https://docs.zama.ai/fhevm/fundamentals/acl)
- SecurityPatterns.sol -- Reference implementation of all patterns in this lesson
- VulnerableDemo.sol -- Educational contract showing common mistakes
`,
  "17-advanced-patterns": `# Module 17: Advanced FHE Design Patterns -- Lesson

## Introduction: Beyond Basic FHE

By now you know how to declare encrypted types, perform FHE operations, manage ACL permissions, handle encrypted inputs, request decryptions, and use conditional logic with \`FHE.select()\`. Those are the building blocks. This module teaches you how to combine them into **design patterns** that solve real problems in production confidential applications.

Think of it this way: Modules 03-09 taught you individual FHE "words." Modules 11-14 taught you to write "sentences." This module teaches you "paragraph structure" -- the higher-level patterns that determine whether your confidential application is robust, user-friendly, and gas-efficient.

We cover six patterns:

| Pattern | Problem It Solves | Key Technique |
|---------|------------------|---------------|
| Encrypted State Machine | Private transition conditions in workflows | \`FHE.ge()\` + \`FHE.select()\` on encrypted thresholds |
| LastError | No feedback when FHE operations silently fail | Encrypted error codes per user |
| Encrypted Registry | Flexible encrypted data storage with sharing | Nested mappings + ACL grants |
| Cross-Contract Composability | Passing encrypted values between contracts | \`FHE.allow(handle, otherContract)\` |
| Encrypted Batch Processing | Multiple FHE operations in one transaction | Bounded loops + gas awareness |
| Time-Locked Encrypted Values | Values that become decryptable at a future time | \`block.timestamp\` guards + \`makePubliclyDecryptable()\` |

---

## Pattern 1: Encrypted State Machines

### Why This Pattern Exists

Many decentralized applications follow a state machine: an escrow moves from Funded to Released, a game moves from Lobby to Playing to Finished, a milestone payment moves from Pending to Approved. In traditional Solidity, the transition conditions are public -- everyone can see *why* a state changed.

With FHE, we can make the **transition condition private** while keeping the **state itself public**. This is a powerful separation:

- **Public:** Which state the machine is in (observers need to know this to interact correctly)
- **Private:** Why and when the transition will happen (the encrypted threshold, counter, or condition)

### Use Cases

- **Escrow release:** Funds release when an encrypted milestone metric reaches a private target
- **Game logic:** A game round ends when an encrypted score reaches a hidden threshold
- **Milestone payments:** Payment unlocks when an encrypted deliverable count hits a private goal
- **Governance escalation:** A proposal escalates when encrypted support reaches a private quorum

### Implementation Walkthrough

Let us examine \`EncryptedStateMachine.sol\`:

\`\`\`solidity
enum State {
    IDLE,
    ACTIVE,
    PAUSED,
    COMPLETED
}

State public currentState; // Public: everyone knows which state

euint32 private _threshold;  // Private: nobody knows the target
euint32 private _counter;    // Private: nobody knows the current count
\`\`\`

The state enum is stored in plaintext. This is intentional -- if the state were encrypted, users would not know whether they can perform actions. The threshold and counter are encrypted, so the "distance to transition" is hidden.

**Setting the threshold:**

\`\`\`solidity
function setThreshold(externalEuint32 encThreshold, bytes calldata inputProof) external onlyOwner {
    euint32 threshold = FHE.fromExternal(encThreshold, inputProof);
    _threshold = threshold;
    FHE.allowThis(_threshold);

    if (!thresholdSet) {
        _counter = FHE.asEuint32(0);
        FHE.allowThis(_counter);
    }

    thresholdSet = true;
}
\`\`\`

The owner encrypts the threshold client-side and submits it. Nobody -- not even the contract -- "knows" the plaintext value. The comparison happens entirely in the FHE domain.

**Incrementing the counter:**

\`\`\`solidity
function performAction() external inState(State.ACTIVE) {
    _counter = FHE.add(_counter, FHE.asEuint32(1));
    FHE.allowThis(_counter);

    actionCount++;
    emit ActionPerformed(msg.sender, actionCount);
}
\`\`\`

Notice that \`actionCount\` is public (observers can see how many actions have been performed), but \`_counter\` is encrypted. In this simple example they track the same value, but in a real application you might have a more complex encrypted metric that differs from the public action count.

**Checking the transition:**

\`\`\`solidity
function checkTransition() external inState(State.ACTIVE) {
    _transitionReady = FHE.ge(_counter, _threshold);
    FHE.allowThis(_transitionReady);
}
\`\`\`

\`FHE.ge()\` computes whether \`counter >= threshold\` entirely in the encrypted domain. The result is an \`ebool\` -- nobody can read it without decryption.

**Revealing and executing:**

\`\`\`solidity
function revealTransition() external onlyOwner inState(State.ACTIVE) {
    FHE.makePubliclyDecryptable(_transitionReady);
}

function executeTransition(bool isReady) external onlyOwner inState(State.ACTIVE) {
    if (isReady) {
        currentState = State.COMPLETED;
    }
}
\`\`\`

The owner makes the transition result publicly decryptable, then submits the decrypted boolean. If the condition was met, the state advances. If not, the machine stays ACTIVE for more actions.

### Key Insight

The state machine pattern separates **what** (which state, public) from **why** (the condition, private). Observers see \`ACTIVE -> COMPLETED\` but never learn that the threshold was 42 or that the counter reached it on the 42nd action. They only learn that *some* encrypted condition was satisfied.

---

## Pattern 2: The LastError Pattern

### The Problem

This is arguably the most important pattern for FHE application usability. Here is the core problem:

In traditional Solidity, when a transfer fails due to insufficient balance, the transaction **reverts** with an error message. The user sees "Insufficient balance" in their wallet. Simple.

In FHE Solidity, we **cannot revert based on encrypted conditions**. Why? Because a revert is a public signal. If \`transfer(encrypted_amount)\` reverts only when the balance is too low, an observer can learn about the user's balance by watching which transactions revert. This is an information leak.

The standard FHE approach is to use \`FHE.select()\`:

\`\`\`solidity
// Standard approach: silently transfer 0 on failure
ebool hasBalance = FHE.ge(balance, amount);
euint64 actualAmount = FHE.select(hasBalance, amount, FHE.asEuint64(0));
\`\`\`

This never reverts. If the balance is insufficient, it transfers 0. But the user gets **no feedback** -- they do not know whether their transfer succeeded or failed, or why.

### The Solution: Encrypted Error Codes

The LastError pattern stores an **encrypted error code** per user after each operation:

\`\`\`solidity
mapping(address => euint8) private _lastError;

// Error codes:
// 0 = SUCCESS
// 1 = INSUFFICIENT_BALANCE
// 2 = AMOUNT_TOO_LARGE
// 3 = SELF_TRANSFER
\`\`\`

After a transfer, the contract computes an encrypted error code using nested \`FHE.select()\`:

\`\`\`solidity
euint8 errorCode = FHE.asEuint8(0); // Start with SUCCESS

// If insufficient balance, set error to 1
errorCode = FHE.select(insufficientBalance, FHE.asEuint8(1), errorCode);

// If amount too large, set error to 2 (overrides insufficient balance)
errorCode = FHE.select(isTooLarge, FHE.asEuint8(2), errorCode);

// If self-transfer, set error to 3 (highest priority)
errorCode = FHE.select(isSelfTransfer, FHE.asEuint8(3), errorCode);

// Store for the user
_lastError[msg.sender] = errorCode;
FHE.allowThis(_lastError[msg.sender]);
FHE.allow(_lastError[msg.sender], msg.sender);
\`\`\`

The user can then decrypt their error code:

\`\`\`typescript
// Frontend: check what happened
const errorHandle = await token.connect(alice).getLastError();
const errorCode = await fhevm.userDecryptEuint(
  FhevmType.euint8, errorHandle, tokenAddress, alice
);

if (errorCode === 0n) console.log("Transfer succeeded!");
if (errorCode === 1n) console.log("Insufficient balance");
if (errorCode === 2n) console.log("Amount exceeds cap");
if (errorCode === 3n) console.log("Cannot transfer to yourself");
\`\`\`

### Why This Is Private

The error code is encrypted and ACL-protected to the user. Only Alice can decrypt Alice's error. An observer sees that Alice called \`transfer()\` and it did not revert -- they learn nothing about whether it succeeded or failed.

### Error Code Priority

When multiple conditions fail simultaneously (for example, a self-transfer that also exceeds the cap), the last \`FHE.select()\` in the chain wins. Design your priority order intentionally:

\`\`\`
Low priority    -->    High priority
INSUFFICIENT_BALANCE   AMOUNT_TOO_LARGE   SELF_TRANSFER
\`\`\`

The code evaluates in order: if insufficient balance is set to 1, then amount-too-large overrides to 2, then self-transfer overrides to 3. This means the user always sees the "most important" error.

### Best Practice: Clear Before New Operations

\`\`\`solidity
function clearError() external {
    _lastError[msg.sender] = FHE.asEuint8(0);
    FHE.allowThis(_lastError[msg.sender]);
    FHE.allow(_lastError[msg.sender], msg.sender);
}
\`\`\`

Encourage users to call \`clearError()\` before performing a new operation. This prevents confusion from stale error codes. Alternatively, the \`transfer()\` function always overwrites the previous error, so calling clear is optional.

### Implementation Detail

Let us look at how the error code determines the actual transfer amount:

\`\`\`solidity
// Only transfer if error code is 0 (SUCCESS)
ebool isSuccess = FHE.eq(errorCode, FHE.asEuint8(0));
euint64 actualAmount = FHE.select(isSuccess, amount, FHE.asEuint64(0));

// Update balances with actualAmount (0 on any error)
_balances[msg.sender] = FHE.sub(_balances[msg.sender], actualAmount);
_balances[to] = FHE.add(_balances[to], actualAmount);
\`\`\`

The actual transfer amount is determined by the error code. If any error occurred, \`actualAmount\` is 0, so balances do not change. This is elegant: the error code computation and the transfer logic are unified through a single \`isSuccess\` check.

---

## Pattern 3: Encrypted Registries

### The Problem

Applications often need flexible encrypted storage -- not just tokens with fixed balance semantics, but arbitrary encrypted key-value pairs that users can store, retrieve, share, and delete.

Consider these use cases:
- A user stores encrypted medical records under keys like "blood_type", "allergies"
- A credential system stores encrypted scores under keys like "credit_score", "income"
- A configuration system stores encrypted parameters under keys like "risk_tolerance", "max_position"

### Implementation Walkthrough

\`EncryptedRegistry.sol\` implements a per-user encrypted key-value store:

\`\`\`solidity
// Per-user, per-key encrypted value storage
mapping(address => mapping(string => euint64)) private _store;

// Track whether a key has been set (plaintext, for existence checks)
mapping(address => mapping(string => bool)) private _hasKey;
\`\`\`

The double mapping \`_store[user][key]\` provides complete isolation between users. Alice's "salary" key is completely separate from Bob's "salary" key.

The \`_hasKey\` mapping is stored in plaintext. This is a design choice: existence of a key is public information, but the value is private. If you need to hide even the existence of keys, you would omit this mapping (at the cost of not being able to check existence cheaply).

**Storing a value:**

\`\`\`solidity
function setValue(string calldata key, externalEuint64 encValue, bytes calldata inputProof) external {
    euint64 value = FHE.fromExternal(encValue, inputProof);

    _store[msg.sender][key] = value;
    FHE.allowThis(_store[msg.sender][key]);
    FHE.allow(_store[msg.sender][key], msg.sender);

    if (!_hasKey[msg.sender][key]) {
        _keyIndex[msg.sender][key] = _userKeys[msg.sender].length;
        _userKeys[msg.sender].push(key);
        _hasKey[msg.sender][key] = true;
    }
}
\`\`\`

The key tracking arrays (\`_userKeys\`, \`_keyIndex\`) enable enumeration -- the user can list all their keys and iterate over them. This uses a swap-and-pop pattern for efficient deletion.

**Sharing a value:**

\`\`\`solidity
function shareValue(string calldata key, address recipient) external {
    require(_hasKey[msg.sender][key], "Key does not exist");
    FHE.allow(_store[msg.sender][key], recipient);
}
\`\`\`

Sharing is a single ACL grant. The recipient gets read access to the same encrypted handle -- no data is copied or re-encrypted. This is gas-efficient and leverages the FHE ACL system naturally.

The recipient reads the shared value through a separate function:

\`\`\`solidity
function getSharedValue(address owner_, string calldata key) external view returns (euint64) {
    return _store[owner_][key];
}
\`\`\`

**Deleting a value:**

\`\`\`solidity
function deleteValue(string calldata key) external {
    _store[msg.sender][key] = FHE.asEuint64(0);
    FHE.allowThis(_store[msg.sender][key]);

    // Remove from keys array using swap-and-pop
    uint256 index = _keyIndex[msg.sender][key];
    uint256 lastIndex = _userKeys[msg.sender].length - 1;
    if (index != lastIndex) {
        string memory lastKey = _userKeys[msg.sender][lastIndex];
        _userKeys[msg.sender][index] = lastKey;
        _keyIndex[msg.sender][lastKey] = index;
    }
    _userKeys[msg.sender].pop();
    delete _keyIndex[msg.sender][key];
    _hasKey[msg.sender][key] = false;
}
\`\`\`

We cannot truly "delete" an FHE handle from the blockchain -- the ciphertext is stored in the blockchain state forever. Instead, we overwrite it with encrypted zero and remove the key from tracking. From the application's perspective, the key no longer exists.

### Design Decision: What Should Be Public?

In the registry pattern, you must decide what metadata is public:

| Data | Public or Private? | Rationale |
|------|-------------------|-----------|
| Key names | Public | String keys are stored in plaintext for cheap lookups |
| Key existence | Public | The \`_hasKey\` mapping is plaintext |
| Number of keys | Public | Array length is plaintext |
| Values | **Private** | Encrypted with per-user ACL |

If you need to hide key names, you could hash them (\`keccak256(key)\`) and use \`bytes32\` instead of \`string\`. If you need to hide even the number of keys, you would need a more complex data structure (e.g., a fixed-size array with encrypted "empty" markers).

---

## Pattern 4: Cross-Contract Composability

### The Challenge

In a multi-contract system, Contract A might store an encrypted value that Contract B needs to read. FHE's ACL system prevents unauthorized access -- so how do you grant one contract access to another contract's encrypted data?

### The Solution: Explicit ACL Grants

The key insight is that ACL permissions can be granted to **any address**, including contract addresses:

\`\`\`solidity
// In Contract A (Token):
function grantVaultAccess(address vault) external {
    // msg.sender (the user) grants the Vault contract access to their balance
    FHE.allow(_balances[msg.sender], vault);
}

// In Contract B (Vault):
function deposit() external {
    // The Vault can now read the user's token balance
    euint64 userBalance = token.balanceOf(msg.sender);
    // ... use userBalance in FHE operations ...
}
\`\`\`

### The Flow

\`\`\`
1. User holds tokens in Contract A (encrypted balance)
2. User calls A.grantVaultAccess(contractB_address)
   --> FHE.allow(balance, contractB)
3. User calls B.deposit()
   --> B reads A.balanceOf(user) and gets the euint64 handle
   --> B can now perform FHE operations on that handle
4. B stores its own encrypted values and grants ACL as needed
\`\`\`

### Interface Design

When designing contracts that accept encrypted values from other contracts, define clear interfaces:

\`\`\`solidity
interface IConfidentialToken {
    function balanceOf(address account) external view returns (euint64);
}

contract Vault is ZamaEthereumConfig {
    IConfidentialToken public token;

    function deposit(uint256 amount) external {
        euint64 balance = token.balanceOf(msg.sender);
        // Vault can now use this encrypted balance
    }
}
\`\`\`

### Important: ACL Propagation

When Contract B creates a **new** encrypted value by operating on Contract A's data, the new value has its own ACL. You must explicitly grant permissions on the new value:

\`\`\`solidity
function computeReward(address user) external {
    euint64 balance = token.balanceOf(user);
    euint64 reward = FHE.mul(balance, FHE.asEuint64(rewardRate));

    // The reward handle has NO permissions yet -- not even for the user
    _rewards[user] = reward;
    FHE.allowThis(_rewards[user]);
    FHE.allow(_rewards[user], user);
}
\`\`\`

Every FHE operation produces a new handle with empty ACL. Always set permissions explicitly.

### Cross-Contract Pattern Summary

\`\`\`
Contract A stores encrypted data
    |
    v
User grants Contract B access: FHE.allow(handle, contractB)
    |
    v
Contract B reads handle via Contract A's view function
    |
    v
Contract B computes new encrypted values
    |
    v
Contract B sets ACL on NEW values (the old ACL does not carry over)
\`\`\`

---

## Pattern 5: Encrypted Batch Processing

### Why Batch?

Some operations naturally work on multiple items: distributing rewards to N users, updating N encrypted scores, or processing N encrypted votes. Doing these one-at-a-time costs N transactions, each with base gas overhead.

### The Rule: Bounded Iteration Only

Never use unbounded loops with FHE operations. Each FHE operation consumes significant gas compared to plaintext operations. An unbounded loop can easily exceed the block gas limit.

\`\`\`solidity
// WRONG: Unbounded loop
function distributeRewards(address[] calldata users) external {
    for (uint256 i = 0; i < users.length; i++) {
        _balances[users[i]] = FHE.add(_balances[users[i]], FHE.asEuint64(reward));
        // Each iteration: ~200k-500k gas for FHE.add
    }
}
\`\`\`

Instead, bound your loops:

\`\`\`solidity
uint256 public constant MAX_BATCH = 5;

function distributeRewards(address[] calldata users) external {
    require(users.length <= MAX_BATCH, "Batch too large");

    for (uint256 i = 0; i < users.length; i++) {
        _balances[users[i]] = FHE.add(_balances[users[i]], FHE.asEuint64(reward));
        FHE.allowThis(_balances[users[i]]);
        FHE.allow(_balances[users[i]], users[i]);
    }
}
\`\`\`

### Gas Estimation

FHE operations are significantly more expensive than plaintext:

| Operation | Approximate Gas |
|-----------|---------------|
| \`FHE.add(euint64, euint64)\` | ~200k |
| \`FHE.sub(euint64, euint64)\` | ~200k |
| \`FHE.mul(euint64, euint64)\` | ~300k |
| \`FHE.ge(euint64, euint64)\` | ~200k |
| \`FHE.select(ebool, euint64, euint64)\` | ~250k |
| \`FHE.fromExternal()\` | ~300k |

A batch of 5 FHE additions costs roughly 1M gas. Plan your batch sizes accordingly.

### The PerformBatchActions Pattern

Our \`EncryptedStateMachine.sol\` demonstrates a simple batch:

\`\`\`solidity
function performBatchActions(uint8 count) external inState(State.ACTIVE) {
    require(count > 0 && count <= 10, "Count must be 1-10");

    // Single FHE operation regardless of count
    _counter = FHE.add(_counter, FHE.asEuint32(uint32(count)));
    FHE.allowThis(_counter);

    actionCount += count;
}
\`\`\`

This is optimal because it reduces N FHE additions to a single FHE addition by pre-computing the sum in plaintext. Not all batch operations can be optimized this way, but always look for opportunities to minimize the number of FHE operations.

---

## Pattern 6: Time-Locked Encrypted Values

### The Concept

Sometimes you want an encrypted value to become publicly readable only after a certain time. Examples:
- Sealed bids revealed after the bidding period
- Encrypted votes decrypted after the voting deadline
- Secret game moves revealed after the round ends

### The Pattern

Combine \`block.timestamp\` (plaintext time) with \`FHE.makePubliclyDecryptable()\`:

\`\`\`solidity
uint256 public revealTime;
euint64 private _secretValue;

function setSecret(externalEuint64 encValue, bytes calldata inputProof, uint256 lockDuration) external {
    _secretValue = FHE.fromExternal(encValue, inputProof);
    FHE.allowThis(_secretValue);
    revealTime = block.timestamp + lockDuration;
}

function reveal() external {
    require(block.timestamp >= revealTime, "Too early");
    FHE.makePubliclyDecryptable(_secretValue);
}
\`\`\`

Before \`revealTime\`, the value is encrypted and only the contract can operate on it. After \`revealTime\`, anyone can call \`reveal()\` and the value becomes publicly decryptable.

### Important: Time Is Not Encrypted

\`block.timestamp\` is plaintext and controlled by validators. This means:
- The reveal time is public (everyone knows when the value will be decryptable)
- Validators have minor influence over \`block.timestamp\` (typically +-15 seconds)
- For high-stakes applications, use block numbers instead of timestamps for more predictability

### Use Case: Commitment Schemes

Time-locked encryption enables commit-reveal schemes without the separate reveal transaction:

\`\`\`
Phase 1 (Commit): Users submit encrypted values
Phase 2 (Lock): No new submissions after deadline
Phase 3 (Reveal): Anyone calls reveal() after lockTime
   --> FHE.makePubliclyDecryptable() on all committed values
\`\`\`

This is simpler than traditional commit-reveal because users do not need to separately reveal their commitments -- the FHE system handles it.

---

## Putting It All Together

### How Patterns Combine

Real applications use multiple patterns simultaneously:

**Encrypted Escrow** (exercise for this module):
- **State Machine**: CREATED -> FUNDED -> RELEASED / DISPUTED / EXPIRED
- **LastError**: Encrypted error codes when funding or releasing fails
- **Time-Lock**: Funds auto-release after a deadline
- **Cross-Contract**: Escrow reads token balances via ACL

**Confidential DEX:**
- **State Machine**: Order lifecycle (OPEN -> MATCHED -> SETTLED)
- **Encrypted Registry**: Order book with encrypted prices and quantities
- **Batch Processing**: Match multiple orders in one transaction
- **Cross-Contract**: DEX reads token balances for settlement

**Private Game:**
- **State Machine**: LOBBY -> PLAYING -> FINISHED
- **LastError**: Invalid move feedback without revealing game state
- **Time-Lock**: Moves revealed after round timer expires
- **Encrypted Registry**: Per-player encrypted game state

### Design Principles for Production FHE Contracts

1. **Minimize FHE operations.** Every encrypted operation costs 10-100x more gas than its plaintext equivalent. Compute as much as possible in plaintext and only encrypt what must be private.

2. **ACL is your access control layer.** Do not try to build your own permission system for encrypted data. Use \`FHE.allow()\` and \`FHE.allowThis()\` consistently.

3. **Never branch on encrypted conditions.** Use \`FHE.select()\` instead of \`if/else\`. The control flow must be identical regardless of the encrypted values.

4. **Use the LastError pattern for user feedback.** Silent failures are terrible UX. Always give users an encrypted error code they can decrypt to understand what happened.

5. **Keep state public when possible.** Encrypt only what must be private. Public state is cheaper and easier to reason about.

6. **Bound all loops.** Never iterate over an unbounded collection with FHE operations inside the loop.

7. **Design for composability.** Use interfaces and ACL grants to enable contract-to-contract encrypted data flow.

8. **Test with known values.** Encrypt known plaintext values in tests, then decrypt results to verify correctness. The test patterns from Module 14 apply directly.

### Pattern Selection Guide

| If you need... | Use this pattern |
|----------------|-----------------|
| Workflow with private conditions | Encrypted State Machine |
| User feedback without info leaks | LastError Pattern |
| Flexible encrypted data storage | Encrypted Registry |
| Multi-contract encrypted data flow | Cross-Contract Composability |
| Multiple FHE operations per tx | Encrypted Batch Processing |
| Reveal encrypted data at a future time | Time-Locked Encrypted Values |

---

## Summary

This module introduced six advanced patterns that transform basic FHE operations into production-ready design primitives:

1. **Encrypted State Machine** -- Public states with private transition conditions. The "why" stays encrypted even as the "what" is visible.

2. **LastError Pattern** -- Encrypted error codes per user, solving the FHE usability problem of silent failures. Users decrypt their own error to learn what happened.

3. **Encrypted Registry** -- Per-user key-value storage with sharing via ACL grants. Flexible enough for medical records, credentials, or configuration.

4. **Cross-Contract Composability** -- Explicit ACL grants between contracts enable multi-contract encrypted architectures.

5. **Encrypted Batch Processing** -- Bounded iteration over encrypted data, with gas-aware batch sizes.

6. **Time-Locked Encrypted Values** -- Combining plaintext timestamps with \`makePubliclyDecryptable()\` for timed reveals.

These patterns are not theoretical. They appear in every non-trivial FHE application. The exercise for this module asks you to combine three of them (State Machine, LastError, Time-Lock) into a working Encrypted Escrow contract. This is the kind of design work you will do when building real confidential dApps.

In the next module, you will see how these patterns scale to even more complex architectures as we approach the capstone project.
`,
  "18-confidential-defi": `# Module 18: Confidential DeFi -- Lesson

## Introduction: Why Confidential DeFi?

Decentralized finance has transformed how we think about financial services. Lending, trading, and asset management can now happen without intermediaries. But there is a fundamental problem: **everything is public**.

On a standard EVM blockchain, every transaction is visible to everyone:

- Your collateral deposit amount is public
- Your loan size is public
- Your trading orders are public
- Your liquidation threshold is public

This transparency creates serious problems:

\`\`\`
The Public DeFi Problem:

1. Front-running: MEV bots see your trade and execute ahead of you
2. Sandwich attacks: Bots place orders before AND after yours, extracting value
3. Liquidation hunting: Observers see when you are close to liquidation
4. Information asymmetry: Whales can see and exploit smaller traders
5. Strategic copying: Competitors can copy your trading strategy
\`\`\`

In traditional finance, trade privacy is the default. When you place a limit order at a brokerage, other participants do not see your order until it is executed. When you take out a loan at a bank, other customers do not know your loan balance.

FHE (Fully Homomorphic Encryption) brings this privacy to on-chain DeFi. With FHEVM, we can build lending protocols where collateral and borrow amounts are encrypted, and order books where prices and quantities are hidden until execution.

This module builds two production-relevant DeFi primitives:
1. **ConfidentialLending** -- A lending protocol with encrypted collateral, borrowing, and interest
2. **EncryptedOrderBook** -- An order book with encrypted prices and amounts

---

## 1. Confidential Lending Protocol

### 1.1 Architecture Overview

A lending protocol has a straightforward lifecycle:

\`\`\`
Lending Lifecycle:
1. User deposits collateral (encrypted amount)
2. User borrows against collateral (encrypted amount)
3. Protocol checks collateralization ratio (FHE comparison)
4. Interest accrues over time (FHE arithmetic on encrypted balance)
5. User repays borrow (FHE subtraction)
6. User withdraws collateral (with sufficiency check)
\`\`\`

In our simplified model:
- **Collateral** is tracked per user as \`euint64\`
- **Borrow balance** is tracked per user as \`euint64\`
- **LTV (Loan-to-Value)** is 50%: you can borrow up to half your collateral
- **Interest** is 10% per accrual period (simplified)

### 1.2 Encrypted Collateral Management

Each user has two encrypted balances stored in mappings:

\`\`\`solidity
mapping(address => euint64) private _collateral;
mapping(address => euint64) private _borrowBalance;
mapping(address => bool) private _initialized;
\`\`\`

Both are initialized to encrypted zero when a user first interacts with the protocol:

\`\`\`solidity
function _initUser(address user) internal {
    if (!_initialized[user]) {
        _collateral[user] = FHE.asEuint64(0);
        FHE.allowThis(_collateral[user]);
        FHE.allow(_collateral[user], user);

        _borrowBalance[user] = FHE.asEuint64(0);
        FHE.allowThis(_borrowBalance[user]);
        FHE.allow(_borrowBalance[user], user);

        _initialized[user] = true;
    }
}
\`\`\`

Key points:
- \`FHE.allowThis()\` grants the contract permission to operate on the encrypted value
- \`FHE.allow(handle, user)\` grants the user permission to decrypt their own balance
- The \`_initialized\` flag prevents re-initialization (which would reset balances)

### 1.3 Depositing Collateral

Depositing adds encrypted collateral to the user's balance:

\`\`\`solidity
function deposit(externalEuint64 encAmount, bytes calldata inputProof) external {
    _initUser(msg.sender);

    euint64 amount = FHE.fromExternal(encAmount, inputProof);

    _collateral[msg.sender] = FHE.add(_collateral[msg.sender], amount);
    FHE.allowThis(_collateral[msg.sender]);
    FHE.allow(_collateral[msg.sender], msg.sender);

    emit Deposited(msg.sender);
}
\`\`\`

The deposit amount is encrypted end-to-end:
1. The user encrypts the amount client-side using \`fhevm.createEncryptedInput()\`
2. The encrypted value and proof are sent to the contract
3. \`FHE.fromExternal()\` converts the external input to an internal \`euint64\`
4. \`FHE.add()\` adds it to the existing collateral (both encrypted)
5. ACL is updated for the new handle (every FHE operation produces a new handle)

**Important:** After every FHE operation that produces a new handle, you must call \`FHE.allowThis()\` and \`FHE.allow()\` again. The ACL is per-handle, not per-slot.

### 1.4 The Collateralization Check with FHE

The core innovation is the on-chain collateralization check using encrypted values:

\`\`\`solidity
function borrow(externalEuint64 encAmount, bytes calldata inputProof) external {
    _initUser(msg.sender);

    euint64 borrowAmount = FHE.fromExternal(encAmount, inputProof);

    // Total borrow after this request
    euint64 newBorrowBalance = FHE.add(_borrowBalance[msg.sender], borrowAmount);

    // 50% LTV check: newBorrowBalance <= collateral / 2
    euint64 maxBorrow = FHE.div(_collateral[msg.sender], 2);
    ebool withinLimit = FHE.le(newBorrowBalance, maxBorrow);

    // If within limit, apply the borrow; otherwise keep existing balance
    _borrowBalance[msg.sender] = FHE.select(
        withinLimit,
        newBorrowBalance,
        _borrowBalance[msg.sender]
    );
    FHE.allowThis(_borrowBalance[msg.sender]);
    FHE.allow(_borrowBalance[msg.sender], msg.sender);

    emit Borrowed(msg.sender);
}
\`\`\`

Let us trace through the logic:

1. \`borrowAmount\` is the encrypted amount the user wants to borrow
2. \`newBorrowBalance\` adds this to any existing borrow (also encrypted)
3. \`maxBorrow = collateral / 2\` computes the maximum allowed borrow (encrypted division)
4. \`withinLimit = FHE.le(newBorrowBalance, maxBorrow)\` checks the LTV constraint -- this returns an \`ebool\` (encrypted boolean)
5. \`FHE.select(withinLimit, newBorrowBalance, _borrowBalance[msg.sender])\` conditionally updates the borrow balance

The critical insight: **we cannot use \`if/else\` on encrypted booleans**. The result of \`FHE.le()\` is encrypted -- we do not know if it is \`true\` or \`false\`. Instead, we use \`FHE.select()\` to pick between two encrypted values based on the encrypted condition.

### 1.5 The LastError Pattern

In traditional Solidity, a failed borrow would \`revert\`. But reverting leaks information:

\`\`\`
Problem with revert:
- User tries to borrow X
- Transaction reverts with "Insufficient collateral"
- Observer now knows: user's collateral < 2X
- This narrows down the collateral range

Solution: silent failure
- User tries to borrow X
- Borrow balance stays the same (FHE.select picks the old value)
- No revert, no information leaked
- User checks their own balance to see if it changed
\`\`\`

This is the **LastError pattern**: instead of reverting on failure, the contract silently does nothing. The user can decrypt their own balance to check whether the operation succeeded. The contract can optionally store an error code, but even the error code must be carefully managed to avoid leaking information about the encrypted state.

In our implementation, the \`Borrowed\` event is always emitted regardless of success. An observer only sees that a borrow attempt was made, but not whether it succeeded or how much was borrowed.

### 1.6 Interest Accrual on Encrypted Balances

Interest is calculated using FHE arithmetic:

\`\`\`solidity
function accrueInterest(address user) external onlyOwner {
    _initUser(user);

    euint64 interest = FHE.div(_borrowBalance[user], 10);
    _borrowBalance[user] = FHE.add(_borrowBalance[user], interest);
    FHE.allowThis(_borrowBalance[user]);
    FHE.allow(_borrowBalance[user], user);

    emit InterestAccrued(user);
}
\`\`\`

This adds 10% interest: \`interest = borrowBalance / 10\`, then \`borrowBalance += interest\`.

Key observations:
- The interest amount is never revealed -- it is computed entirely on encrypted data
- \`FHE.div()\` performs integer division on encrypted values
- The owner (or a keeper) triggers interest accrual per user
- In production, you would batch this across all users or use a per-block accrual model

### 1.7 Withdrawal with Collateral Sufficiency Check

Withdrawing collateral requires checking that the remaining collateral still covers the borrow:

\`\`\`solidity
function withdraw(externalEuint64 encAmount, bytes calldata inputProof) external {
    _initUser(msg.sender);

    euint64 withdrawAmount = FHE.fromExternal(encAmount, inputProof);

    // Remaining collateral after withdrawal
    euint64 remaining = FHE.sub(_collateral[msg.sender], withdrawAmount);

    // Check: remaining >= 2 * borrowBalance
    euint64 requiredCollateral = FHE.mul(_borrowBalance[msg.sender], FHE.asEuint64(2));
    ebool isSafe = FHE.ge(remaining, requiredCollateral);

    // Also check withdrawAmount <= collateral (prevent underflow)
    ebool hasEnough = FHE.ge(_collateral[msg.sender], withdrawAmount);
    ebool canWithdraw = FHE.and(isSafe, hasEnough);

    _collateral[msg.sender] = FHE.select(
        canWithdraw,
        remaining,
        _collateral[msg.sender]
    );
    FHE.allowThis(_collateral[msg.sender]);
    FHE.allow(_collateral[msg.sender], msg.sender);

    emit Withdrawn(msg.sender);
}
\`\`\`

Two checks are combined with \`FHE.and()\`:
1. **Safety check:** \`remaining >= 2 * borrowBalance\` ensures 50% LTV is maintained
2. **Underflow check:** \`withdrawAmount <= collateral\` prevents FHE subtraction underflow

If either check fails, the collateral remains unchanged (LastError pattern).

### 1.8 Repayment

Repayment reduces the borrow balance:

\`\`\`solidity
function repay(externalEuint64 encAmount, bytes calldata inputProof) external {
    _initUser(msg.sender);

    euint64 repayAmount = FHE.fromExternal(encAmount, inputProof);

    // Cap repayment to the current borrow balance
    euint64 actualRepay = FHE.min(repayAmount, _borrowBalance[msg.sender]);

    _borrowBalance[msg.sender] = FHE.sub(_borrowBalance[msg.sender], actualRepay);
    FHE.allowThis(_borrowBalance[msg.sender]);
    FHE.allow(_borrowBalance[msg.sender], msg.sender);

    emit Repaid(msg.sender);
}
\`\`\`

\`FHE.min()\` caps the repayment to the borrow balance. If the user tries to repay more than they owe, only the owed amount is subtracted. This prevents underflow without revealing the borrow balance.

---

## 2. Encrypted Order Book

### 2.1 Why Encrypted Order Books Matter

Traditional on-chain order books (like on Serum or dYdX v3) expose every order to everyone:

\`\`\`
Traditional Order Book (public):
  BUY  100 units @ \$50  (Alice)
  BUY   50 units @ \$48  (Bob)
  SELL  75 units @ \$52  (Carol)
  SELL 200 units @ \$55  (Dave)

Problems:
- MEV bots see Alice's large buy order and front-run it
- Traders see the order book depth and manipulate prices
- Market makers' strategies are fully visible
- Dark pools exist in TradFi precisely to avoid this
\`\`\`

An encrypted order book hides the critical information:

\`\`\`
Encrypted Order Book:
  BUY  [encrypted] units @ [encrypted]  (Alice)
  BUY  [encrypted] units @ [encrypted]  (Bob)
  SELL [encrypted] units @ [encrypted]  (Carol)
  SELL [encrypted] units @ [encrypted]  (Dave)

What is public: order exists, trader address, buy/sell direction
What is private: price, amount, fill amount
\`\`\`

### 2.2 Order Structure

Each order stores encrypted price and amount alongside public metadata:

\`\`\`solidity
struct Order {
    address trader;
    euint64 price;
    euint64 amount;
    bool isBuy;
    bool isActive;
}

mapping(uint256 => Order) private _orders;
uint256 public orderCount;
uint256 public activeOrderCount;
uint256 public constant MAX_ACTIVE_ORDERS = 50;
\`\`\`

Design decisions:
- **\`trader\` is public:** Addresses are always visible on-chain (transaction sender)
- **\`isBuy\` is public:** The direction (buy vs sell) must be known to match orders
- **\`isActive\` is public:** Needed for validation without FHE overhead
- **\`price\` and \`amount\` are encrypted:** These are the sensitive values
- **\`MAX_ACTIVE_ORDERS = 50\`:** Prevents DoS from unbounded order storage

### 2.3 Order Submission

Buy and sell order submission follow the same pattern:

\`\`\`solidity
function submitBuyOrder(
    externalEuint64 encPrice,
    bytes calldata priceProof,
    externalEuint64 encAmount,
    bytes calldata amountProof
) external {
    require(activeOrderCount < MAX_ACTIVE_ORDERS, "Too many active orders");

    euint64 price = FHE.fromExternal(encPrice, priceProof);
    euint64 amount = FHE.fromExternal(encAmount, amountProof);

    uint256 orderId = orderCount++;
    _orders[orderId].trader = msg.sender;
    _orders[orderId].price = price;
    _orders[orderId].amount = amount;
    _orders[orderId].isBuy = true;
    _orders[orderId].isActive = true;

    FHE.allowThis(_orders[orderId].price);
    FHE.allow(_orders[orderId].price, msg.sender);
    FHE.allowThis(_orders[orderId].amount);
    FHE.allow(_orders[orderId].amount, msg.sender);

    activeOrderCount++;

    emit OrderSubmitted(orderId, msg.sender, true);
}
\`\`\`

Note the dual encrypted inputs: both price and amount are encrypted separately, each with its own proof. The function takes four parameters for the encrypted data: two handles and two proofs. Both receive ACL grants for the contract and the trader.

### 2.4 Order Matching Logic

The matching function is the heart of the order book. It compares a buy order against a sell order:

\`\`\`solidity
function matchOrders(uint256 buyOrderId, uint256 sellOrderId) external onlyOwner {
    require(_orders[buyOrderId].isActive, "Buy order not active");
    require(_orders[sellOrderId].isActive, "Sell order not active");
    require(_orders[buyOrderId].isBuy, "Not a buy order");
    require(!_orders[sellOrderId].isBuy, "Not a sell order");

    // Check if buy price >= sell price
    ebool canMatch = FHE.ge(
        _orders[buyOrderId].price,
        _orders[sellOrderId].price
    );

    // Fill amount = min of both order amounts
    euint64 fillAmount = FHE.min(
        _orders[buyOrderId].amount,
        _orders[sellOrderId].amount
    );

    // If prices are incompatible, fill becomes 0
    euint64 actualFill = FHE.select(canMatch, fillAmount, FHE.asEuint64(0));

    // Update remaining amounts
    _orders[buyOrderId].amount = FHE.sub(_orders[buyOrderId].amount, actualFill);
    _orders[sellOrderId].amount = FHE.sub(_orders[sellOrderId].amount, actualFill);

    // Update ACL for new handles
    FHE.allowThis(_orders[buyOrderId].amount);
    FHE.allow(_orders[buyOrderId].amount, _orders[buyOrderId].trader);
    FHE.allowThis(_orders[sellOrderId].amount);
    FHE.allow(_orders[sellOrderId].amount, _orders[sellOrderId].trader);

    emit OrderMatched(buyOrderId, sellOrderId);
}
\`\`\`

Step-by-step breakdown:

1. **Price comparison:** \`FHE.ge(buyPrice, sellPrice)\` checks if the buy price is at least as high as the sell price. This returns an \`ebool\` -- we do not know the result.

2. **Fill calculation:** \`FHE.min(buyAmount, sellAmount)\` determines how much can be filled. If one order is for 100 units and the other for 60, the fill is 60.

3. **Conditional fill:** \`FHE.select(canMatch, fillAmount, 0)\` makes the fill 0 if prices are incompatible. This is the key privacy mechanism -- the fill either happens or it does not, and nobody can tell which.

4. **Amount update:** \`FHE.sub(amount, actualFill)\` reduces both orders by the fill amount. If \`actualFill\` is 0 (incompatible prices), the subtraction has no effect.

5. **ACL refresh:** New handles from \`FHE.sub()\` need fresh ACL grants.

### 2.5 What Is Public vs. Private

This is a critical distinction for any confidential DeFi protocol:

| Information | Visibility | Why |
|---|---|---|
| Order exists | Public | Transaction is on-chain |
| Trader address | Public | \`msg.sender\` is always visible |
| Buy/sell direction | Public | Stored as plaintext \`bool\` for matching efficiency |
| Order price | Private | Encrypted \`euint64\` |
| Order amount | Private | Encrypted \`euint64\` |
| Fill amount | Private | Computed with \`FHE.min\` and \`FHE.select\` |
| Whether match succeeded | Private | \`actualFill\` could be 0 or non-zero; only traders know |
| Order cancellation | Public | Changes \`isActive\` flag |

The \`OrderMatched\` event is emitted regardless of whether the match actually filled. An observer sees that a match was attempted between two order IDs, but not whether it succeeded or how much was filled.

### 2.6 Order Cancellation

Traders can cancel their own orders:

\`\`\`solidity
function cancelOrder(uint256 orderId) external {
    require(orderId < orderCount, "Invalid order");
    require(_orders[orderId].isActive, "Order not active");
    require(_orders[orderId].trader == msg.sender, "Not your order");

    _orders[orderId].isActive = false;
    activeOrderCount--;

    emit OrderCancelled(orderId, msg.sender);
}
\`\`\`

Cancellation is a plaintext operation -- it only flips a boolean. The encrypted price and amount remain in storage but are no longer matchable.

---

## 3. Privacy Trade-offs in DeFi

### 3.1 What You CAN Keep Private

With FHE, the following can remain encrypted:

- **Amounts:** Collateral deposits, borrow amounts, order quantities, fill sizes
- **Prices:** Limit order prices, liquidation thresholds, interest amounts
- **Balances:** User balances, collateral ratios, debt levels
- **Comparisons:** Whether a borrow is within LTV, whether orders matched

### 3.2 What You CANNOT Hide

Even with FHE, some information is inherently public on any blockchain:

- **Addresses:** \`msg.sender\` is always visible. Everyone knows who is interacting with the protocol.
- **Function calls:** Which function was called and when. An observer knows you called \`borrow()\` even if they do not know the amount.
- **Timing:** When you placed an order, when you repaid, how frequently you interact.
- **Gas usage:** Different FHE operations use different gas amounts, which can sometimes leak information about the code path taken.
- **Transaction count:** How many orders a trader has placed.

### 3.3 Hybrid Approaches

In practice, confidential DeFi protocols use a hybrid approach:

\`\`\`
Hybrid Privacy Model:
- Encrypted: amounts, prices, balances (the "what")
- Public: addresses, function calls, timing (the "who" and "when")
- Semi-public: aggregated metrics (total TVL, order count)
\`\`\`

This is analogous to traditional finance:
- Your bank knows your balance (encrypted on-chain)
- The public knows you have a bank account (address interaction)
- Aggregate statistics are published (total deposits)

### 3.4 Compliance Considerations

A common concern with privacy protocols is regulatory compliance. FHE-based DeFi can support compliance through:

1. **KYC gates:** Require address whitelisting before interaction (plaintext check before encrypted operations)
2. **Auditor access:** Grant specific addresses ACL access to encrypted balances via \`FHE.allow(handle, auditor)\`
3. **Threshold reporting:** Use FHE comparison to flag large transactions without revealing exact amounts
4. **Selective disclosure:** Users can choose to make their own balances publicly decryptable

---

## 4. Advanced DeFi Concepts with FHE

### 4.1 Encrypted AMMs (Concept)

An Automated Market Maker (AMM) with encrypted reserves is theoretically possible:

\`\`\`
Standard AMM: x * y = k (constant product formula)
  - x = reserve of token A (public)
  - y = reserve of token B (public)
  - k = constant (public)

Encrypted AMM:
  - x = euint64 reserve of token A (encrypted)
  - y = euint64 reserve of token B (encrypted)
  - k check: FHE.mul(newX, newY) >= FHE.mul(oldX, oldY)
\`\`\`

Challenges:
- The constant product formula requires \`FHE.mul()\` which is expensive
- Slippage protection needs encrypted comparison with user's minimum output
- Price oracle extraction is impossible (which is actually a feature -- prevents oracle manipulation)

### 4.2 Private Yield Farming

Yield farming with encrypted staking amounts:
- Users stake encrypted amounts
- Rewards are calculated using FHE arithmetic
- Compound interest uses iterative FHE operations
- Share-based models (like ERC-4626) work well because share prices can be public while individual holdings are private

### 4.3 Confidential Insurance Protocols

Insurance with encrypted premiums and claims:
- Premium amounts are encrypted (prevents adverse selection based on premium size)
- Claim amounts are encrypted (prevents targeting of high-value policies)
- Payout decisions use FHE comparison against policy limits
- Risk pools have encrypted total exposure

### 4.4 Future Standards

The FHE community is working on standards for confidential tokens and DeFi:
- **Confidential ERC-20:** Encrypted balances with standard transfer interface (already demonstrated in Module 11)
- **Encrypted vaults:** ERC-4626-style vaults with encrypted deposits and withdrawals
- **Cross-protocol composability:** How encrypted values move between DeFi protocols

> **Production Example:** Zaiffer Protocol (a Zama + PyratzLabs joint venture) is building ZaifferSwaps (MEV-protected trading with encrypted order amounts) and ZaifferYields (confidential yield vaults) using the exact patterns covered in this module. Zama's 2026 roadmap includes cUSDT/cUSDC/cETH yield integration with AAVE and Morpho — demonstrating real market demand for confidential DeFi. The ERC-7984 standard (co-developed by Zama and OpenZeppelin) formalizes the confidential token interface that underpins these products.

---

## 5. Production Considerations

### 5.1 Gas Costs

FHE operations are significantly more expensive than plaintext operations:

\`\`\`
Approximate FHE Gas Costs (relative):
- FHE.add()     ~50,000 gas
- FHE.sub()     ~50,000 gas
- FHE.mul()     ~100,000 gas
- FHE.div()     ~150,000 gas
- FHE.le()      ~50,000 gas
- FHE.select()  ~50,000 gas
- FHE.min()     ~100,000 gas

A single borrow() call in ConfidentialLending:
- FHE.fromExternal()  ~100,000
- FHE.add()           ~50,000
- FHE.div()           ~150,000
- FHE.le()            ~50,000
- FHE.select()        ~50,000
- ACL operations       ~50,000
Total:                ~450,000 gas

Compare to a plaintext lending protocol:
- SSTORE + arithmetic  ~30,000 gas
\`\`\`

This 10-15x gas overhead is the cost of privacy. Optimization strategies include:
- Batching operations (e.g., accrue interest for multiple users in one transaction)
- Reducing FHE operations per function call
- Using smaller encrypted types (\`euint8\`, \`euint16\`) where the value range allows
- Caching intermediate FHE results across function calls

### 5.2 Liquidation Challenges

Liquidation in confidential lending is fundamentally harder:

\`\`\`
Traditional Lending:
- Anyone can check if a position is undercollateralized
- Liquidation bots monitor all positions in real-time
- Immediate liquidation when health factor < 1

Confidential Lending:
- Nobody can see collateral or borrow amounts
- Cannot run off-chain health checks
- Liquidation must be triggered differently
\`\`\`

Possible approaches:
1. **Self-reporting:** Users call a function that checks their own health factor using FHE and triggers liquidation if needed (relies on user cooperation)
2. **Keeper incentives:** A keeper calls \`checkHealth(user)\` which does the FHE check on-chain and grants a reward if liquidation occurs
3. **Time-based checks:** Interest accrual also checks health factor
4. **Threshold decryption:** After a certain condition, the health factor is made publicly decryptable

### 5.3 Oracle Integration

Price oracles with encrypted values present unique challenges:

- Chainlink feeds provide public prices -- these can be wrapped into \`euint64\` with \`FHE.asEuint64(oraclePrice)\`
- The oracle price itself may leak information about positions (if you know the price and the LTV, you can estimate ranges)
- Private oracle feeds (encrypted oracle responses) are an active research area

### 5.4 Composability

One of DeFi's greatest strengths is composability -- protocols building on each other. With FHE:

- Encrypted values can be passed between contracts if ACL is properly managed
- \`FHE.allow(handle, otherContract)\` grants another contract access to an encrypted value
- This enables lending protocol -> DEX -> yield aggregator pipelines with encrypted amounts
- Standard interfaces are needed for encrypted value passing (emerging area)

---

## 6. Full Code Walkthrough: ConfidentialLending.sol

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint8, euint16, euint32, euint64, ebool, externalEuint64, externalEuint32}
    from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract ConfidentialLending is ZamaEthereumConfig {
    // Error codes for the LastError pattern
    enum ErrorCode {
        NO_ERROR,
        INSUFFICIENT_COLLATERAL,
        INSUFFICIENT_BORROW_BALANCE,
        INSUFFICIENT_COLLATERAL_FOR_WITHDRAWAL
    }

    // Encrypted balances per user
    mapping(address => euint64) private _collateral;
    mapping(address => euint64) private _borrowBalance;
    mapping(address => bool) private _initialized;
    mapping(address => ErrorCode) public lastError;

    address public owner;

    // Events for all operations
    event Deposited(address indexed user);
    event Withdrawn(address indexed user);
    event Borrowed(address indexed user);
    event Repaid(address indexed user);
    event InterestAccrued(address indexed user);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    // Initialize user balances to encrypted 0
    function _initUser(address user) internal { ... }

    // Deposit encrypted collateral
    function deposit(externalEuint64 encAmount, bytes calldata inputProof) external { ... }

    // Borrow with 50% LTV check (silent failure via FHE.select)
    function borrow(externalEuint64 encAmount, bytes calldata inputProof) external { ... }

    // Repay borrow (capped to balance via FHE.min)
    function repay(externalEuint64 encAmount, bytes calldata inputProof) external { ... }

    // Withdraw with collateral sufficiency check
    function withdraw(externalEuint64 encAmount, bytes calldata inputProof) external { ... }

    // Accrue 10% interest (owner only)
    function accrueInterest(address user) external onlyOwner { ... }

    // View functions returning encrypted handles
    function getCollateral() external view returns (euint64) { ... }
    function getBorrowBalance() external view returns (euint64) { ... }
}
\`\`\`

The contract has 8 main functions:
1. \`_initUser()\` -- Internal initialization
2. \`deposit()\` -- Add collateral
3. \`borrow()\` -- Take a loan (with LTV check)
4. \`repay()\` -- Reduce loan (capped to balance)
5. \`withdraw()\` -- Remove collateral (with safety check)
6. \`accrueInterest()\` -- Add 10% interest (owner)
7. \`getCollateral()\` -- Read encrypted collateral handle
8. \`getBorrowBalance()\` -- Read encrypted borrow handle

---

## 7. Full Code Walkthrough: EncryptedOrderBook.sol

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint8, euint16, euint32, euint64, ebool, externalEuint64, externalEuint32}
    from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedOrderBook is ZamaEthereumConfig {
    struct Order {
        address trader;
        euint64 price;
        euint64 amount;
        bool isBuy;
        bool isActive;
    }

    mapping(uint256 => Order) private _orders;
    uint256 public orderCount;
    uint256 public activeOrderCount;
    uint256 public constant MAX_ACTIVE_ORDERS = 50;

    address public owner;

    event OrderSubmitted(uint256 indexed orderId, address indexed trader, bool isBuy);
    event OrderMatched(uint256 indexed buyOrderId, uint256 indexed sellOrderId);
    event OrderCancelled(uint256 indexed orderId, address indexed trader);

    // Submit buy order with encrypted price + amount
    function submitBuyOrder(
        externalEuint64 encPrice, bytes calldata priceProof,
        externalEuint64 encAmount, bytes calldata amountProof
    ) external { ... }

    // Submit sell order (same signature)
    function submitSellOrder(...) external { ... }

    // Match a buy against a sell (owner/keeper only)
    function matchOrders(uint256 buyOrderId, uint256 sellOrderId) external onlyOwner { ... }

    // Cancel own order
    function cancelOrder(uint256 orderId) external { ... }

    // Read encrypted handles
    function getOrderAmount(uint256 orderId) external view returns (euint64) { ... }
    function getOrderPrice(uint256 orderId) external view returns (euint64) { ... }
}
\`\`\`

The contract has 9 main functions:
1. \`submitBuyOrder()\` -- Place encrypted buy order
2. \`submitSellOrder()\` -- Place encrypted sell order
3. \`matchOrders()\` -- Match two orders (owner)
4. \`cancelOrder()\` -- Cancel own order
5. \`getOrderAmount()\` -- Read encrypted amount handle
6. \`getOrderPrice()\` -- Read encrypted price handle
7. \`isOrderActive()\` -- Check if order is active
8. \`getOrderTrader()\` -- Get trader address
9. \`isOrderBuy()\` -- Check order direction

---

## 8. Testing Confidential DeFi

Testing FHE-based DeFi requires the same patterns from earlier modules:

\`\`\`typescript
// Encrypt input
const enc = await fhevm
  .createEncryptedInput(contractAddress, signer.address)
  .add64(amount)
  .encrypt();

// Call function
await contract.connect(signer).deposit(enc.handles[0], enc.inputProof);

// Decrypt and verify
const handle = await contract.connect(signer).getCollateral();
const value = await fhevm.userDecryptEuint(
  FhevmType.euint64, handle, contractAddress, signer
);
expect(value).to.equal(expectedAmount);
\`\`\`

Key testing patterns for DeFi:
- **Test the happy path:** Deposit, borrow within limits, repay, withdraw
- **Test silent failures:** Borrow over limit, withdraw too much -- verify balance unchanged
- **Test multi-user isolation:** One user's actions should not affect another
- **Test interest accrual:** Verify arithmetic is correct across multiple accruals
- **Test edge cases:** Repay more than owed, withdraw all collateral with no borrow

---

## Summary

- **Confidential lending** encrypts collateral and borrow balances, enforcing LTV with \`FHE.le()\` and \`FHE.select()\`
- **Encrypted order books** hide prices and amounts while allowing on-chain matching with \`FHE.ge()\` and \`FHE.min()\`
- **The LastError pattern** avoids information leakage by using \`FHE.select()\` instead of \`revert\`
- **Privacy trade-offs:** Amounts and prices can be private; addresses, timing, and function calls cannot
- **Gas costs** are 10-15x higher than plaintext DeFi -- optimization matters
- **Liquidation** in confidential lending requires new mechanisms (keeper-based, self-reporting)
- **Composability** between encrypted DeFi protocols requires careful ACL management
- **Real-world DeFi** stands to benefit enormously: eliminating front-running, MEV extraction, and information asymmetry
- FHE-based DeFi is not theoretical -- the contracts in this module are functional and testable today
`,
  "19-capstone": `# Module 19: Capstone -- Confidential DAO -- Lesson

## Introduction

This capstone project brings together every concept from the bootcamp into a single, comprehensive application: a **Confidential DAO**. This DAO features:

1. **Confidential Governance Tokens** (Module 11) -- Encrypted balances determine voting power
2. **Private Voting** (Module 12) -- Votes are encrypted; tallies hidden until finalization
3. **Treasury Management** -- Proposals to spend DAO funds
4. **Frontend Integration** (Module 10) -- Full dApp interface

This is a challenging project that combines encrypted types, operations, ACL, conditional logic, decryption, and frontend integration.

> **Architecture Note:** This lesson teaches a **two-contract architecture** (GovernanceToken + ConfidentialDAO) with weighted voting for educational purposes — it demonstrates cross-contract ACL, interface patterns, and advanced FHE composition. The reference implementation in \`contracts/ConfidentialDAO.sol\` uses a **simplified monolithic architecture** (single contract, unweighted votes) that is easier to test and deploy. Both approaches are valid; the two-contract version is the "stretch goal" for students who want a deeper challenge.

---

## 1. System Architecture

\`\`\`
ConfidentialDAO (main contract)
    |
    |-- GovernanceToken (ConfidentialERC20)
    |       - Encrypted balances
    |       - Voting power source
    |
    |-- Proposals
    |       - Description + amount
    |       - Encrypted yes/no tallies
    |       - Weighted by token balance
    |
    |-- Treasury
    |       - ETH held by the DAO
    |       - Released via approved proposals
    |
    v
Frontend (React + Relayer SDK)
    - Create proposals
    - Cast weighted votes
    - View results after finalization
    - Execute approved proposals
\`\`\`

---

## 2. The Governance Token

We use a simplified version of the confidential ERC-20 from Module 11. The DAO contract needs to read token balances for vote weighting, so we must set up cross-contract ACL.

\`\`\`solidity
// In GovernanceToken: allow the DAO contract to read balances
function grantDAOAccess(address dao) public {
    FHE.allow(_balances[msg.sender], dao);
}
\`\`\`

When a user wants to vote, they first grant the DAO contract access to their token balance. The DAO can then use the encrypted balance as the vote weight.

---

## 3. Weighted Voting

Unlike Module 12's simple Yes/No voting (each vote = 1), the DAO uses **weighted voting** where your vote power equals your token balance:

\`\`\`solidity
function vote(uint256 proposalId, externalEbool encryptedVote, bytes calldata inputProof) external {
    // Get the voter's token balance (DAO must have ACL access)
    euint64 weight = governanceToken.balanceOf(msg.sender);

    ebool voteYes = FHE.fromExternal(encryptedVote, inputProof);

    euint64 zero = FHE.asEuint64(0);
    euint64 yesWeight = FHE.select(voteYes, weight, zero);
    euint64 noWeight = FHE.select(voteYes, zero, weight);

    p.yesVotes = FHE.add(p.yesVotes, yesWeight);
    p.noVotes = FHE.add(p.noVotes, noWeight);
}
\`\`\`

The voter's entire token balance is used as the vote weight. If they vote Yes, their full balance is added to \`yesVotes\` and 0 to \`noVotes\` (and vice versa).

---

## 4. Complete ConfidentialDAO Contract

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool, externalEbool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

interface IGovernanceToken {
    function balanceOf(address account) external view returns (euint64);
}

contract ConfidentialDAO is ZamaEthereumConfig {
    struct Proposal {
        string description;
        address recipient;
        uint256 amount; // ETH amount to transfer if approved
        uint256 startTime;
        uint256 endTime;
        euint64 yesVotes;
        euint64 noVotes;
        bool exists;
        bool finalized;
        bool executed;
    }

    address public admin;
    IGovernanceToken public governanceToken;
    uint256 public proposalCount;
    uint256 public votingDuration;

    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => mapping(address => bool)) private _hasVoted;

    event ProposalCreated(
        uint256 indexed proposalId,
        string description,
        address recipient,
        uint256 amount
    );
    event VoteCast(uint256 indexed proposalId, address indexed voter);
    event ProposalFinalized(uint256 indexed proposalId);
    event ProposalExecuted(uint256 indexed proposalId, address recipient, uint256 amount);
    event TreasuryFunded(address indexed from, uint256 amount);

    modifier onlyAdmin() {
        require(msg.sender == admin, "Not admin");
        _;
    }

    constructor(address _governanceToken, uint256 _votingDuration) {
        admin = msg.sender;
        governanceToken = IGovernanceToken(_governanceToken);
        votingDuration = _votingDuration;
    }

    // Accept ETH for the treasury
    receive() external payable {
        emit TreasuryFunded(msg.sender, msg.value);
    }

    function createProposal(
        string calldata description,
        address recipient,
        uint256 amount
    ) public returns (uint256) {
        require(amount <= address(this).balance, "Insufficient treasury");

        uint256 proposalId = proposalCount++;

        proposals[proposalId].description = description;
        proposals[proposalId].recipient = recipient;
        proposals[proposalId].amount = amount;
        proposals[proposalId].startTime = block.timestamp;
        proposals[proposalId].endTime = block.timestamp + votingDuration;
        proposals[proposalId].yesVotes = FHE.asEuint64(0);
        proposals[proposalId].noVotes = FHE.asEuint64(0);
        proposals[proposalId].exists = true;

        FHE.allowThis(proposals[proposalId].yesVotes);
        FHE.allowThis(proposals[proposalId].noVotes);

        emit ProposalCreated(proposalId, description, recipient, amount);
        return proposalId;
    }

    function vote(uint256 proposalId, externalEbool encryptedVote, bytes calldata inputProof) external {
        Proposal storage p = proposals[proposalId];
        require(p.exists, "Proposal does not exist");
        require(block.timestamp >= p.startTime, "Voting not started");
        require(block.timestamp < p.endTime, "Voting ended");
        require(!_hasVoted[proposalId][msg.sender], "Already voted");

        _hasVoted[proposalId][msg.sender] = true;

        // Get voter's token balance as vote weight
        // The voter must have previously granted ACL to this contract
        euint64 weight = governanceToken.balanceOf(msg.sender);

        ebool voteYes = FHE.fromExternal(encryptedVote, inputProof);
        euint64 zero = FHE.asEuint64(0);

        euint64 yesWeight = FHE.select(voteYes, weight, zero);
        euint64 noWeight = FHE.select(voteYes, zero, weight);

        p.yesVotes = FHE.add(p.yesVotes, yesWeight);
        p.noVotes = FHE.add(p.noVotes, noWeight);

        FHE.allowThis(p.yesVotes);
        FHE.allowThis(p.noVotes);

        emit VoteCast(proposalId, msg.sender);
    }

    function finalize(uint256 proposalId) public onlyAdmin {
        Proposal storage p = proposals[proposalId];
        require(p.exists, "Proposal does not exist");
        require(block.timestamp >= p.endTime, "Voting not ended");
        require(!p.finalized, "Already finalized");

        p.finalized = true;

        // Make vote tallies publicly decryptable
        FHE.makePubliclyDecryptable(p.yesVotes);
        FHE.makePubliclyDecryptable(p.noVotes);

        emit ProposalFinalized(proposalId);
    }

    function executeProposal(
        uint256 proposalId,
        uint64 decryptedYes,
        uint64 decryptedNo
    ) public onlyAdmin {
        Proposal storage p = proposals[proposalId];
        require(p.finalized, "Not finalized");
        require(!p.executed, "Already executed");
        require(decryptedYes > decryptedNo, "Proposal not approved");
        require(address(this).balance >= p.amount, "Insufficient treasury");

        p.executed = true;

        // Transfer ETH from treasury to recipient
        payable(p.recipient).transfer(p.amount);

        emit ProposalExecuted(proposalId, p.recipient, p.amount);
    }

    function getProposalResults(uint256 proposalId) public view returns (euint64, euint64) {
        Proposal storage p = proposals[proposalId];
        require(p.finalized, "Not finalized");
        return (p.yesVotes, p.noVotes);
    }

    function hasVoted(uint256 proposalId, address voter) public view returns (bool) {
        return _hasVoted[proposalId][voter];
    }

    function treasuryBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
\`\`\`

---

## 5. Cross-Contract ACL Flow

This is a new concept. The DAO contract needs to read the voter's token balance, but the balance is encrypted and ACL-protected.

**Setup flow:**

\`\`\`
1. User holds governance tokens (encrypted balance)
2. Before voting, user calls:
   governanceToken.grantDAOAccess(daoAddress)
   This executes: FHE.allow(_balances[msg.sender], daoAddress)
3. Now when user votes, the DAO contract can read:
   governanceToken.balanceOf(msg.sender)
   and get the euint64 balance
4. The DAO uses this balance as the vote weight
\`\`\`

In the GovernanceToken contract:

\`\`\`solidity
function grantDAOAccess(address dao) public {
    require(_initialized[msg.sender], "No balance");
    FHE.allow(_balances[msg.sender], dao);
}

// balanceOf needs to be callable by the DAO (not just msg.sender)
function balanceOf(address account) public view returns (euint64) {
    return _balances[account];
}
\`\`\`

---

## 6. Proposal Lifecycle

\`\`\`
Phase 1: Create
  - Anyone can create a proposal
  - Specifies: description, recipient, ETH amount
  - Voting period starts immediately

Phase 2: Vote
  - Token holders vote Yes/No (encrypted)
  - Vote weight = token balance at time of vote
  - One vote per address per proposal

Phase 3: Finalize
  - Admin finalizes after voting ends
  - Makes vote tallies publicly decryptable

Phase 4: Execute
  - Admin submits decrypted tallies
  - If yes > no: ETH transferred from treasury to recipient
  - If no >= yes: proposal rejected
\`\`\`

---

## 7. Treasury Management

The DAO holds ETH in its treasury:

\`\`\`solidity
// Anyone can fund the treasury
receive() external payable {
    emit TreasuryFunded(msg.sender, msg.value);
}

// Approved proposals transfer from treasury
payable(p.recipient).transfer(p.amount);
\`\`\`

The treasury balance is public (ETH balance is always visible on-chain). This is a design choice -- you could track an "encrypted budget" separately if needed.

---

## 8. Security Considerations

### Vote Weight Manipulation

If a user transfers tokens after voting on one proposal, they could receive tokens and vote again (on the same proposal, from a different address that now holds the tokens). The \`_hasVoted\` mapping prevents the same address from voting twice, but not the same tokens from being used twice.

**Production solution:** Snapshot balances at proposal creation time. This requires additional data structures.

### Admin Trust

The admin can:
- Finalize proposals (timing control)
- Execute proposals (submits decrypted tallies)

The admin cannot:
- Change votes (encrypted)
- See individual votes (no ACL)
- Execute rejected proposals (yes > no check)

For a trustless design, consider using \`FHE.makePubliclyDecryptable()\` so anyone can verify vote tallies, and add on-chain execution logic based on the decrypted results.

### Treasury Drain

A series of proposals could drain the treasury. Consider:
- Minimum quorum (total votes must exceed a threshold)
- Proposal amount caps
- Cooldown periods between proposals

---

## 9. Frontend Architecture

\`\`\`
Pages:
1. Dashboard
   - Treasury balance
   - Active proposals list
   - Your token balance (decrypted)

2. Create Proposal
   - Description, recipient, amount form
   - Submit transaction

3. Proposal Detail
   - Description, status, time remaining
   - Vote button (Yes/No)
   - Results (after finalization)

4. Token Management
   - Grant DAO access (one-time)
   - Transfer tokens
   - View balance
\`\`\`

Key frontend interactions:

\`\`\`typescript
// Grant DAO access (one-time per user)
await governanceToken.grantDAOAccess(daoAddress);

// Create proposal
await dao.createProposal(description, recipient, amount);

// Vote
const input = instance.createEncryptedInput(daoAddress, userAddress);
input.addBool(true); // Vote Yes
const encrypted = await input.encrypt();
await dao.vote(proposalId, encrypted.handles[0], encrypted.inputProof);

// Admin: finalize and execute
await dao.finalize(proposalId);
// ... decrypt via userDecryptEuint in tests ...
await dao.executeProposal(proposalId, yesVotes, noVotes);
\`\`\`

---

## 10. Testing Strategy

\`\`\`
Test 1: Token Distribution
  - Deploy GovernanceToken
  - Mint tokens to 3 test accounts
  - Verify encrypted balances

Test 2: DAO Setup
  - Deploy ConfidentialDAO with token address
  - Fund treasury with ETH
  - Each user grants DAO access

Test 3: Proposal Creation
  - Create a proposal (recipient, amount)
  - Verify proposal fields

Test 4: Voting
  - User A votes Yes (weight = 100 tokens)
  - User B votes No (weight = 50 tokens)
  - User C votes Yes (weight = 75 tokens)
  - Verify duplicate prevention

Test 5: Finalization and Execution
  - Finalize after voting period
  - Decrypt tallies (Yes = 175, No = 50)
  - Execute proposal
  - Verify ETH transferred to recipient

Test 6: Rejection
  - Create another proposal
  - Majority votes No
  - Execute should fail (no > yes)
\`\`\`

---

## Summary

The Confidential DAO combines all FHEVM concepts:

| Module | Concept Used |
|--------|-------------|
| 03: Encrypted Types | \`euint64\`, \`ebool\`, \`eaddress\` |
| 04: Operations | \`FHE.add()\`, \`FHE.gt()\` |
| 05: ACL | \`FHE.allow()\`, \`FHE.allowThis()\`, cross-contract ACL |
| 06: Inputs | \`externalEbool\`, \`FHE.fromExternal()\` |
| 07: Decryption | \`makePubliclyDecryptable()\` for tallies |
| 08: Conditional Logic | \`FHE.select()\` for weighted voting |
| 10: Frontend | Relayer SDK integration |
| 11: ERC-20 | Governance token with encrypted balances |
| 12: Voting | Private voting with encrypted tallies |

This capstone demonstrates that FHEVM can power real-world, privacy-preserving decentralized governance.
`,
};

export const exercises: Record<string, string> = {
  "00-prerequisites": `# Module 00 - Exercise: Build a SimpleVault Contract

## Objective

Create a \`SimpleVault\` contract that allows users to deposit ETH, track balances using mappings, withdraw their funds, and includes basic access control. This exercise brings together all the concepts covered in Module 00.

---

## Requirements

1. **Deposit:** Users can deposit ETH into the vault. Their balance is tracked in a mapping.
2. **Withdraw:** Users can withdraw up to their deposited balance.
3. **Events:** Emit \`Deposit\` and \`Withdrawal\` events for every state-changing operation.
4. **Access Control:** Only the contract owner can call \`emergencyWithdraw()\`.
5. **Pause:** The owner can pause and unpause the contract. Deposits and withdrawals are blocked while paused.
6. **View Functions:** \`getBalance()\` returns the caller's vault balance; \`getVaultTotal()\` returns the contract's total ETH balance.

---

## Starter Code

Copy this into \`contracts/SimpleVault.sol\` and fill in the function bodies.

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract SimpleVault {
    // --- State Variables ---
    address public owner;
    bool public paused;
    mapping(address => uint256) private balances;

    // --- Events ---
    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    event EmergencyWithdrawal(address indexed owner, uint256 amount);
    event Paused(address indexed owner);
    event Unpaused(address indexed owner);

    // --- Errors ---
    error NotOwner();
    error ContractPaused();
    error ZeroAmount();
    error InsufficientBalance(uint256 available, uint256 requested);
    error TransferFailed();

    // --- Modifiers ---

    /// @dev Restricts access to the contract owner
    modifier onlyOwner() {
        // TODO: Revert with NotOwner() if caller is not the owner
        _;
    }

    /// @dev Blocks execution when the contract is paused
    modifier whenNotPaused() {
        // TODO: Revert with ContractPaused() if paused is true
        _;
    }

    // --- Constructor ---

    constructor() {
        // TODO: Set the deployer as the owner
    }

    // --- Core Functions ---

    /// @notice Deposit ETH into the vault
    function deposit() external payable whenNotPaused {
        // TODO:
        // 1. Revert with ZeroAmount() if msg.value is 0
        // 2. Add msg.value to the caller's balance in the mapping
        // 3. Emit the Deposit event
    }

    /// @notice Withdraw ETH from the vault
    /// @param amount The amount of ETH to withdraw (in wei)
    function withdraw(uint256 amount) external whenNotPaused {
        // TODO:
        // 1. Revert with ZeroAmount() if amount is 0
        // 2. Revert with InsufficientBalance if caller's balance < amount
        // 3. Subtract amount from the caller's balance (do this BEFORE transfer!)
        // 4. Transfer ETH to the caller using payable(msg.sender).call{value: amount}("")
        // 5. Revert with TransferFailed() if the transfer did not succeed
        // 6. Emit the Withdrawal event
    }

    /// @notice Owner-only emergency withdrawal of all contract funds
    function emergencyWithdraw() external onlyOwner {
        // TODO:
        // 1. Store the current contract balance in a local variable
        // 2. Transfer all ETH to the owner
        // 3. Revert with TransferFailed() if it fails
        // 4. Emit the EmergencyWithdrawal event
    }

    /// @notice Pause the contract (owner only)
    function pause() external onlyOwner {
        // TODO:
        // 1. Set paused to true
        // 2. Emit the Paused event
    }

    /// @notice Unpause the contract (owner only)
    function unpause() external onlyOwner {
        // TODO:
        // 1. Set paused to false
        // 2. Emit the Unpaused event
    }

    // --- View Functions ---

    /// @notice Returns the caller's deposited balance
    function getBalance() external view returns (uint256) {
        // TODO: Return the caller's balance from the mapping
    }

    /// @notice Returns the total ETH held in the vault
    function getVaultTotal() external view returns (uint256) {
        // TODO: Return the contract's ETH balance (address(this).balance)
    }
}
\`\`\`

---

## Hints

Try to complete the exercise on your own first. If you get stuck, expand the hints below.

<details>
<summary>Hint 1: onlyOwner modifier</summary>

\`\`\`solidity
modifier onlyOwner() {
    if (msg.sender != owner) revert NotOwner();
    _;
}
\`\`\`
</details>

<details>
<summary>Hint 2: whenNotPaused modifier</summary>

\`\`\`solidity
modifier whenNotPaused() {
    if (paused) revert ContractPaused();
    _;
}
\`\`\`
</details>

<details>
<summary>Hint 3: deposit function</summary>

\`\`\`solidity
function deposit() external payable whenNotPaused {
    if (msg.value == 0) revert ZeroAmount();
    balances[msg.sender] += msg.value;
    emit Deposit(msg.sender, msg.value);
}
\`\`\`
</details>

<details>
<summary>Hint 4: withdraw function (CEI pattern)</summary>

The Checks-Effects-Interactions (CEI) pattern requires you to update state **before** making external calls to prevent reentrancy.

\`\`\`solidity
function withdraw(uint256 amount) external whenNotPaused {
    if (amount == 0) revert ZeroAmount();
    if (balances[msg.sender] < amount) {
        revert InsufficientBalance(balances[msg.sender], amount);
    }

    balances[msg.sender] -= amount;  // Effect before Interaction

    (bool success, ) = payable(msg.sender).call{value: amount}("");
    if (!success) revert TransferFailed();

    emit Withdrawal(msg.sender, amount);
}
\`\`\`
</details>

<details>
<summary>Hint 5: emergencyWithdraw function</summary>

\`\`\`solidity
function emergencyWithdraw() external onlyOwner {
    uint256 total = address(this).balance;
    (bool success, ) = payable(owner).call{value: total}("");
    if (!success) revert TransferFailed();
    emit EmergencyWithdrawal(owner, total);
}
\`\`\`
</details>

---

## Test Template

Use this template to verify your implementation:

\`\`\`javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");

describe("SimpleVault", function () {
    async function deployFixture() {
        const [owner, user1, user2] = await ethers.getSigners();
        const Vault = await ethers.getContractFactory("SimpleVault");
        const vault = await Vault.deploy();
        return { vault, owner, user1, user2 };
    }

    describe("Deployment", function () {
        it("should set the deployer as owner", async function () {
            const { vault, owner } = await loadFixture(deployFixture);
            expect(await vault.owner()).to.equal(owner.address);
        });

        it("should start unpaused", async function () {
            const { vault } = await loadFixture(deployFixture);
            expect(await vault.paused()).to.equal(false);
        });
    });

    describe("Deposits", function () {
        it("should accept ETH and update balance", async function () {
            const { vault, user1 } = await loadFixture(deployFixture);
            const amount = ethers.parseEther("1.0");

            await vault.connect(user1).deposit({ value: amount });
            expect(await vault.connect(user1).getBalance()).to.equal(amount);
        });

        it("should emit Deposit event", async function () {
            const { vault, user1 } = await loadFixture(deployFixture);
            const amount = ethers.parseEther("1.0");

            await expect(vault.connect(user1).deposit({ value: amount }))
                .to.emit(vault, "Deposit")
                .withArgs(user1.address, amount);
        });

        it("should revert on zero deposit", async function () {
            const { vault, user1 } = await loadFixture(deployFixture);
            await expect(
                vault.connect(user1).deposit({ value: 0 })
            ).to.be.revertedWithCustomError(vault, "ZeroAmount");
        });
    });

    describe("Withdrawals", function () {
        it("should allow withdrawal of deposited amount", async function () {
            const { vault, user1 } = await loadFixture(deployFixture);
            const amount = ethers.parseEther("1.0");

            await vault.connect(user1).deposit({ value: amount });
            await vault.connect(user1).withdraw(amount);
            expect(await vault.connect(user1).getBalance()).to.equal(0);
        });

        it("should revert when withdrawing more than balance", async function () {
            const { vault, user1 } = await loadFixture(deployFixture);
            const amount = ethers.parseEther("1.0");

            await expect(
                vault.connect(user1).withdraw(amount)
            ).to.be.revertedWithCustomError(vault, "InsufficientBalance");
        });
    });

    describe("Access Control", function () {
        it("should allow only owner to pause", async function () {
            const { vault, user1 } = await loadFixture(deployFixture);
            await expect(
                vault.connect(user1).pause()
            ).to.be.revertedWithCustomError(vault, "NotOwner");
        });

        it("should block deposits when paused", async function () {
            const { vault, owner, user1 } = await loadFixture(deployFixture);
            await vault.connect(owner).pause();
            await expect(
                vault.connect(user1).deposit({ value: ethers.parseEther("1.0") })
            ).to.be.revertedWithCustomError(vault, "ContractPaused");
        });
    });
});
\`\`\`

---

## Expected Output

When all functions are correctly implemented and you run \`npx hardhat test\`:

\`\`\`
  SimpleVault
    Deployment
      ✓ should set the deployer as owner
      ✓ should start unpaused
    Deposits
      ✓ should accept ETH and update balance
      ✓ should emit Deposit event
      ✓ should revert on zero deposit
    Withdrawals
      ✓ should allow withdrawal of deposited amount
      ✓ should revert when withdrawing more than balance
    Access Control
      ✓ should allow only owner to pause
      ✓ should block deposits when paused

  9 passing
\`\`\`

---

## Bonus Challenges

1. Add a \`transferOwnership(address newOwner)\` function with proper validation.
2. Add a \`receive()\` fallback that calls \`deposit()\` so users can send ETH directly.
3. Track total deposits per user (cumulative, not just current balance) using a separate mapping.
`,
  "01-intro-to-fhe": `# Module 01 - Exercises: Introduction to FHE

## Exercise 1: Encryption Fundamentals (15 min)

### Part A: Classify the Encryption Type
For each scenario, identify if it uses **symmetric** or **asymmetric** encryption:

1. Alice sends Bob a message using his public key
2. A company encrypts its database with a single master key
3. SSH key-pair authentication
4. AES-256 encrypted file storage
5. TLS certificate verification

<details>
<summary>Answer Key</summary>

1. Asymmetric — uses Bob's public key, only his private key decrypts
2. Symmetric — single master key for both encrypt/decrypt
3. Asymmetric — SSH uses public/private key pairs
4. Symmetric — AES is a symmetric cipher
5. Asymmetric — certificates use public/private keys
</details>

### Part B: Homomorphic Encryption Properties
Given plaintext values a=5 and b=3, and an FHE scheme where E(x) represents encryption:

1. If we compute \`FHE.add(E(5), E(3))\` and decrypt the result, what do we get?
2. If we compute \`FHE.mul(E(5), E(3))\` and decrypt the result, what do we get?
3. Why can't we simply check \`E(5) == E(5)\` to see if two encrypted values are equal?

<details>
<summary>Answer Key</summary>

1. 8 — homomorphic addition preserves the plaintext addition
2. 15 — homomorphic multiplication preserves the plaintext multiplication
3. Encrypted values include randomness (nonce), so encrypting the same plaintext twice produces different ciphertexts. Instead, we use \`FHE.eq(E(5), E(5))\` which returns an encrypted boolean.
</details>

## Exercise 2: FHE Scheme Comparison (10 min)

Fill in the table:

| Feature | PHE | SHE | FHE |
|---------|-----|-----|-----|
| Addition | ? | ? | ? |
| Multiplication | ? | ? | ? |
| Unlimited Operations | ? | ? | ? |
| Real-world example | ? | ? | ? |

<details>
<summary>Answer Key</summary>

| Feature | PHE | SHE | FHE |
|---------|-----|-----|-----|
| Addition | Yes (additive) or Yes (multiplicative) | Yes | Yes |
| Multiplication | No (additive) or Yes (multiplicative) | Yes | Yes |
| Unlimited Operations | Yes (for supported op) | No (noise budget) | Yes (bootstrapping) |
| Real-world example | RSA (multiplicative), Paillier (additive) | BGV, BFV | TFHE (Zama) |
</details>

## Exercise 3: Privacy Solution Comparison (10 min)

For each use case, which privacy technology is BEST suited and why?

1. Proving you are over 18 without revealing your exact age
2. Computing average salary across companies without any company seeing others' data
3. Running an encrypted smart contract where the computation itself is confidential
4. Processing data in a secure cloud environment

<details>
<summary>Answer Key</summary>

1. **ZK-Proofs** — ideal for proving a property without revealing the underlying data
2. **MPC** — multiple parties can jointly compute without revealing individual inputs
3. **FHE (fhEVM)** — compute on encrypted data on-chain without ever decrypting
4. **TEE** — hardware-level isolation for data processing (but requires trust in hardware)
</details>

## Exercise 4: fhEVM Architecture (15 min)

### Part A: Component Matching
Match each fhEVM component with its role:

| Component | Role |
|-----------|------|
| 1. FHE Library (FHE.sol) | A. Stores encryption/decryption keys securely |
| 2. Coprocessor | B. Provides Solidity API for encrypted operations |
| 3. Gateway | C. Executes heavy FHE computations off-chain |
| 4. KMS (Key Management Service) | D. Mediates decryption requests between chain and KMS |

<details>
<summary>Answer Key</summary>

1-B, 2-C, 3-D, 4-A
</details>

### Part B: Transaction Flow
Order these steps for an encrypted token transfer on fhEVM:

- [ ] FHE.le() compares encrypted balance with encrypted amount
- [ ] User encrypts transfer amount client-side
- [ ] FHE.sub() and FHE.add() update encrypted balances
- [ ] User submits encrypted input with proof to the contract
- [ ] FHE.select() chooses: if sufficient balance, transfer; else no change
- [ ] FHE.fromExternal() verifies and converts the input
- [ ] FHE.allow() grants access to new balance for sender and receiver

<details>
<summary>Answer Key</summary>

Correct order:
1. User encrypts transfer amount client-side
2. User submits encrypted input with proof to the contract
3. FHE.fromExternal() verifies and converts the input
4. FHE.le() compares encrypted balance with encrypted amount
5. FHE.select() chooses: if sufficient balance, transfer; else no change
6. FHE.sub() and FHE.add() update encrypted balances
7. FHE.allow() grants access to new balance for sender and receiver
</details>

## Exercise 5: About Zama (5 min)

Answer the following questions about Zama:

1. What is Zama's core technology contribution to the blockchain space?
2. Name two key products/libraries that Zama provides.
3. What does TFHE stand for and why is it significant for fhEVM?

<details>
<summary>Answer Key</summary>

1. Zama provides open-source FHE (Fully Homomorphic Encryption) tools for blockchain and AI, enabling computation on encrypted data.
2. fhEVM (encrypted smart contracts), TFHE-rs (Rust FHE library), Concrete (FHE compiler), Concrete ML (encrypted ML).
3. TFHE = Torus Fully Homomorphic Encryption. It is significant because it supports fast bootstrapping, enabling unlimited encrypted computations without noise accumulation, making it practical for smart contract execution.
</details>
`,
  "02-development-setup": `# Module 02: Exercise — Build & Deploy Your First FHEVM Contract

## Objective

Set up a complete FHEVM development environment from scratch, write an encrypted storage contract, compile it, and write a passing test.

---

## Task: Encrypted Greeting Contract

Build a contract called \`EncryptedGreeting\` that:

1. Stores an encrypted boolean (\`ebool\`) indicating whether a greeting has been set
2. Stores an encrypted number (\`euint8\`) representing a greeting code (0-255)
3. Has a function \`setGreeting(uint8 code)\` that sets both values
4. Has a function \`isGreetingSet()\` that returns the \`ebool\`

---

## Starter Code

### \`contracts/EncryptedGreeting.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, ebool, euint8} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedGreeting is ZamaEthereumConfig {
    ebool private _isSet;
    euint8 private _greetingCode;

    constructor() {
        // TODO: Initialize _isSet to encrypted false
        // TODO: Initialize _greetingCode to encrypted 0
        // TODO: Grant this contract access to both values
    }

    function setGreeting(uint8 code) public {
        // TODO: Set _greetingCode to the encrypted version of \`code\`
        // TODO: Set _isSet to encrypted true
        // TODO: Grant this contract access to both updated values
    }

    function isGreetingSet() public view returns (ebool) {
        // TODO: Return the encrypted boolean
    }

    function getGreetingCode() public view returns (euint8) {
        // TODO: Return the encrypted greeting code
    }
}
\`\`\`

### \`test/EncryptedGreeting.test.ts\`

\`\`\`typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("EncryptedGreeting", function () {
  it("should deploy successfully", async function () {
    // TODO: Deploy the contract and assert it has a valid address
  });

  it("should allow setting a greeting", async function () {
    // TODO: Deploy the contract
    // TODO: Call setGreeting with a code value
    // TODO: Assert the transaction succeeded (no revert)
  });
});
\`\`\`

---

## Step-by-Step Instructions

1. **Create the project:**
   \`\`\`bash
   mkdir encrypted-greeting && cd encrypted-greeting
   npm init -y
   npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox
   npm install @fhevm/solidity
   npm install --save-dev @fhevm/hardhat-plugin @fhevm/mock-utils
   npx hardhat init  # Choose TypeScript
   \`\`\`

2. **Create the contract** in \`contracts/EncryptedGreeting.sol\`

3. **Fill in the TODOs** using:
   - \`FHE.asEbool(false)\` / \`FHE.asEbool(true)\`
   - \`FHE.asEuint8(value)\`
   - \`FHE.allowThis(handle)\`

4. **Write the test** in \`test/EncryptedGreeting.test.ts\`

5. **Compile and test:**
   \`\`\`bash
   npx hardhat compile
   npx hardhat test
   \`\`\`

---

## Hints

<details>
<summary>Hint 1: Constructor initialization</summary>

\`\`\`solidity
_isSet = FHE.asEbool(false);
_greetingCode = FHE.asEuint8(0);
FHE.allowThis(_isSet);
FHE.allowThis(_greetingCode);
\`\`\`
</details>

<details>
<summary>Hint 2: setGreeting function</summary>

\`\`\`solidity
_greetingCode = FHE.asEuint8(code);
_isSet = FHE.asEbool(true);
FHE.allowThis(_greetingCode);
FHE.allowThis(_isSet);
\`\`\`
</details>

<details>
<summary>Hint 3: Test deployment</summary>

\`\`\`typescript
const factory = await ethers.getContractFactory("EncryptedGreeting");
const contract = await factory.deploy();
await contract.waitForDeployment();
expect(await contract.getAddress()).to.be.properAddress;
\`\`\`
</details>

---

## Bonus Challenge

Add an \`owner\` variable and an \`onlyOwner\` modifier so that only the deployer can call \`setGreeting\`. This combines traditional Solidity patterns with FHEVM.

---

## Success Criteria

- [ ] Project compiles without errors
- [ ] All tests pass
- [ ] Contract uses \`FHE\` library (not \`TFHE\`)
- [ ] Contract inherits \`ZamaEthereumConfig\`
- [ ] \`FHE.allowThis()\` is called after every encrypted state update

## Bonus Challenge: Production Pattern (Stage 2)

Modify your \`EncryptedGreeting\` contract to accept encrypted input instead of plaintext:

1. Change the parameter type from \`uint8\` to \`externalEuint8\` and add \`bytes calldata inputProof\`
2. Use \`FHE.fromExternal(encValue, inputProof)\` inside the function
3. Update your test to use \`fhevm.createEncryptedInput()\` pattern

**Hint:** Look at \`../../contracts/HelloFHEVM.sol\` for the production pattern.
`,
  "03-encrypted-types": `# Module 03: Exercise — Encrypted User Profile

## Objective

Build an \`EncryptedProfile\` contract that stores multiple encrypted fields of different types, demonstrating mastery of the FHEVM type system.

---

## Task: Encrypted User Profile

Create a contract that stores a user profile with the following encrypted fields:

| Field | Type | Description |
|-------|------|-------------|
| \`_isVerified\` | \`ebool\` | Whether the user has been verified |
| \`_age\` | \`euint8\` | User's age (0-255) |
| \`_reputation\` | \`euint16\` | Reputation score (0-65535) |
| \`_balance\` | \`euint64\` | Token balance |
| \`_walletAddress\` | \`eaddress\` | A linked wallet address |

The contract should:
1. Initialize all fields in the constructor
2. Provide setter functions for each field
3. Provide getter functions that return encrypted handles
4. Only allow the contract owner to set fields

---

## Starter Code

### \`contracts/EncryptedProfile.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, ebool, euint8, euint16, euint64, eaddress} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedProfile is ZamaEthereumConfig {
    address public owner;

    // TODO: Declare encrypted state variables
    // _isVerified (ebool)
    // _age (euint8)
    // _reputation (euint16)
    // _balance (euint64)
    // _walletAddress (eaddress)

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor() {
        owner = msg.sender;
        // TODO: Initialize all encrypted fields to default values
        // TODO: Call FHE.allowThis() for each field
    }

    function setVerified(bool verified) public onlyOwner {
        // TODO: Set _isVerified to encrypted value of \`verified\`
        // TODO: FHE.allowThis() + FHE.allow(handle, msg.sender)
    }

    function setAge(uint8 age) public onlyOwner {
        // TODO: Set _age to encrypted value of \`age\`
        // TODO: FHE.allowThis() + FHE.allow(handle, msg.sender)
    }

    function setReputation(uint16 rep) public onlyOwner {
        // TODO: Set _reputation to encrypted value of \`rep\`
        // TODO: FHE.allowThis() + FHE.allow(handle, msg.sender)
    }

    function setBalance(uint64 bal) public onlyOwner {
        // TODO: Set _balance to encrypted value of \`bal\`
        // TODO: FHE.allowThis() + FHE.allow(handle, msg.sender)
    }

    function setWalletAddress(address wallet) public onlyOwner {
        // TODO: Set _walletAddress to encrypted value of \`wallet\`
        // TODO: FHE.allowThis() + FHE.allow(handle, msg.sender)
    }

    function addToBalance(uint64 amount) public onlyOwner {
        // TODO: Add \`amount\` to _balance using FHE.add
        // TODO: FHE.allowThis() + FHE.allow(handle, msg.sender)
    }

    function incrementReputation() public onlyOwner {
        // TODO: Add 1 to _reputation using FHE.add
        // TODO: FHE.allowThis() + FHE.allow(handle, msg.sender)
    }

    // Getters (return encrypted handles)
    function getIsVerified() public view returns (ebool) {
        return _isVerified;
    }

    function getAge() public view returns (euint8) {
        return _age;
    }

    function getReputation() public view returns (euint16) {
        return _reputation;
    }

    function getBalance() public view returns (euint64) {
        return _balance;
    }

    function getWalletAddress() public view returns (eaddress) {
        return _walletAddress;
    }
}
\`\`\`

---

## Step-by-Step Instructions

1. **Declare the state variables** using the correct encrypted types
2. **Initialize all variables** in the constructor using \`FHE.asXXX()\` functions
3. **Call both \`FHE.allowThis()\` and \`FHE.allow(handle, msg.sender)\`** after every encrypted state update — \`allowThis\` grants the contract access, \`allow\` grants the caller access to decrypt
4. **Implement all setter functions** using the appropriate \`FHE.asXXX()\` conversion
5. **Implement \`addToBalance\`** using \`FHE.add()\` for homomorphic addition
6. **Implement \`incrementReputation\`** using \`FHE.add()\` with \`FHE.asEuint16(1)\`

---

## Hints

<details>
<summary>Hint 1: Variable declarations</summary>

\`\`\`solidity
ebool private _isVerified;
euint8 private _age;
euint16 private _reputation;
euint64 private _balance;
eaddress private _walletAddress;
\`\`\`
</details>

<details>
<summary>Hint 2: Constructor initialization</summary>

\`\`\`solidity
_isVerified = FHE.asEbool(false);
_age = FHE.asEuint8(0);
_reputation = FHE.asEuint16(0);
_balance = FHE.asEuint64(0);
_walletAddress = FHE.asEaddress(address(0));
FHE.allowThis(_isVerified);
FHE.allow(_isVerified, msg.sender);
FHE.allowThis(_age);
FHE.allow(_age, msg.sender);
FHE.allowThis(_reputation);
FHE.allow(_reputation, msg.sender);
FHE.allowThis(_balance);
FHE.allow(_balance, msg.sender);
FHE.allowThis(_walletAddress);
FHE.allow(_walletAddress, msg.sender);
\`\`\`
</details>

<details>
<summary>Hint 3: addToBalance</summary>

\`\`\`solidity
function addToBalance(uint64 amount) public onlyOwner {
    _balance = FHE.add(_balance, FHE.asEuint64(amount));
    FHE.allowThis(_balance);
    FHE.allow(_balance, msg.sender);
}
\`\`\`
</details>

---

## Bonus Challenges

1. **Add a \`checkAge\` function** that returns an \`ebool\` indicating whether the stored age is greater than or equal to 18 (use \`FHE.ge()\`).

2. **Add a \`hasHighReputation\` function** that returns an \`ebool\` for whether reputation exceeds 1000.

3. **Add an \`isMyWallet\` function** that takes an \`address\` parameter and returns an \`ebool\` indicating whether it matches the stored wallet address.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] All five encrypted types are correctly used
- [ ] All variables are initialized in the constructor
- [ ] \`FHE.allowThis()\` is called after every encrypted state update
- [ ] \`addToBalance\` performs homomorphic addition
- [ ] \`incrementReputation\` performs homomorphic addition
- [ ] Only the owner can modify fields
`,
  "04-operations": `# Module 04: Exercise — Encrypted Vault with Operations

## Objective

Build an \`EncryptedVault\` contract that demonstrates arithmetic, comparison, and min/max operations on encrypted data.

---

## Task: Encrypted Vault

Create a contract where users can deposit and withdraw encrypted amounts with the following rules:

1. Each user has an encrypted balance (\`euint64\`)
2. Deposits add to the balance (arithmetic)
3. Withdrawals subtract from the balance with **underflow protection** (comparison + select)
4. A maximum balance cap of \`1,000,000\` is enforced (min/max)
5. Users can check if their balance exceeds a threshold (comparison returning \`ebool\`)

---

## Starter Code

### \`contracts/EncryptedVault.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedVault is ZamaEthereumConfig {
    mapping(address => euint64) private _balances;
    mapping(address => bool) private _initialized;

    uint64 public constant MAX_BALANCE = 1_000_000;

    function _initBalance(address user) internal {
        if (!_initialized[user]) {
            _balances[user] = FHE.asEuint64(0);
            FHE.allowThis(_balances[user]);
            FHE.allow(_balances[user], user);
            _initialized[user] = true;
        }
    }

    function deposit(uint64 amount) public {
        _initBalance(msg.sender);
        // TODO: Add \`amount\` to the sender's balance using FHE.add()
        // TODO: Clamp to MAX_BALANCE using FHE.min()
        // TODO: FHE.allowThis() and FHE.allow() for the user
    }

    function withdraw(uint64 amount) public {
        _initBalance(msg.sender);
        // TODO: Check if balance >= amount using FHE.ge()
        // TODO: Calculate balance - amount using FHE.sub()
        // TODO: Use FHE.select() to pick (balance - amount) if valid, else keep balance
        // TODO: FHE.allowThis() and FHE.allow() for the user
    }

    function isAboveThreshold(uint64 threshold) public returns (ebool) {
        _initBalance(msg.sender);
        // TODO: Compare balance > threshold using FHE.gt()
        // TODO: FHE.allowThis() and FHE.allow() the result
        // TODO: Return the ebool
    }

    function doubleBalance() public {
        _initBalance(msg.sender);
        // TODO: Multiply balance by 2 using FHE.mul()
        // TODO: Clamp to MAX_BALANCE using FHE.min()
        // TODO: FHE.allowThis() and FHE.allow()
    }

    function halveDividend() public {
        _initBalance(msg.sender);
        // TODO: Divide balance by 2 using FHE.div() (plaintext divisor)
        // TODO: FHE.allowThis() and FHE.allow()
    }

    function getBalance() public view returns (euint64) {
        return _balances[msg.sender];
    }
}
\`\`\`

---

## Step-by-Step Instructions

1. **\`deposit\`**: Use \`FHE.add()\` to add the amount, then \`FHE.min()\` to cap at \`MAX_BALANCE\`
2. **\`withdraw\`**: Use \`FHE.ge()\` to check funds, \`FHE.sub()\` to compute difference, \`FHE.select()\` for safe result
3. **\`isAboveThreshold\`**: Use \`FHE.gt()\` to compare balance against the threshold
4. **\`doubleBalance\`**: Use \`FHE.mul()\` with 2, then \`FHE.min()\` to cap
5. **\`halveDividend\`**: Use \`FHE.div()\` with plaintext 2

---

## Hints

<details>
<summary>Hint 1: deposit function</summary>

\`\`\`solidity
function deposit(uint64 amount) public {
    _initBalance(msg.sender);
    euint64 newBalance = FHE.add(_balances[msg.sender], FHE.asEuint64(amount));
    _balances[msg.sender] = FHE.min(newBalance, FHE.asEuint64(MAX_BALANCE));
    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
}
\`\`\`
</details>

<details>
<summary>Hint 2: withdraw function</summary>

\`\`\`solidity
function withdraw(uint64 amount) public {
    _initBalance(msg.sender);
    euint64 amt = FHE.asEuint64(amount);
    ebool canWithdraw = FHE.ge(_balances[msg.sender], amt);
    euint64 newBalance = FHE.sub(_balances[msg.sender], amt);
    _balances[msg.sender] = FHE.select(canWithdraw, newBalance, _balances[msg.sender]);
    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
}
\`\`\`
</details>

<details>
<summary>Hint 3: isAboveThreshold function</summary>

\`\`\`solidity
function isAboveThreshold(uint64 threshold) public returns (ebool) {
    _initBalance(msg.sender);
    ebool result = FHE.gt(_balances[msg.sender], FHE.asEuint64(threshold));
    FHE.allowThis(result);
    FHE.allow(result, msg.sender);
    return result;
}
\`\`\`
</details>

---

## Bonus Challenges

1. **Add a \`transferEncrypted\` function** that takes an \`address to\` and \`uint64 amount\`, performing a safe transfer between two encrypted balances.

2. **Add a \`getBalanceRange\` function** that returns an \`euint8\` representing which range the balance falls in: 0 = low (< 1000), 1 = medium (< 100000), 2 = high (>= 100000). Use \`FHE.select()\` and comparisons.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] \`deposit\` performs addition and caps at MAX_BALANCE
- [ ] \`withdraw\` has underflow protection using \`FHE.ge()\` + \`FHE.select()\`
- [ ] \`isAboveThreshold\` returns a properly ACL-granted \`ebool\`
- [ ] \`doubleBalance\` uses \`FHE.mul()\` with clamping
- [ ] \`halveDividend\` uses \`FHE.div()\` with a plaintext divisor
- [ ] All encrypted results have proper \`FHE.allowThis()\` and \`FHE.allow()\` calls
`,
  "05-access-control": `# Module 05: Exercise — Encrypted Token with ACL

## Objective

Build a minimal encrypted ERC20-like token that properly manages ACL for balances across minting, transferring, and querying.

---

## Task: ConfidentialToken

Create a contract with the following features:

1. **Minting** — Owner can mint encrypted tokens to any address
2. **Transfer** — Users can transfer encrypted amounts to other users
3. **Balance query** — Users can retrieve their own encrypted balance (with ACL check)
4. **Approval** — Users can approve another address to access their balance

---

## Starter Code

### \`contracts/ConfidentialToken.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract ConfidentialToken is ZamaEthereumConfig {
    address public owner;
    mapping(address => euint64) private _balances;
    mapping(address => bool) private _initialized;
    mapping(address => mapping(address => bool)) private _approvals;

    event Transfer(address indexed from, address indexed to);
    event Mint(address indexed to);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function _ensureInitialized(address user) internal {
        if (!_initialized[user]) {
            _balances[user] = FHE.asEuint64(0);
            FHE.allowThis(_balances[user]);
            FHE.allow(_balances[user], user);
            _initialized[user] = true;
        }
    }

    function mint(address to, uint64 amount) public onlyOwner {
        _ensureInitialized(to);
        // TODO: Add amount to the recipient's balance
        // TODO: Update ACL for both the contract and the recipient
        emit Mint(to);
    }

    function transfer(address to, uint64 amount) public {
        _ensureInitialized(msg.sender);
        _ensureInitialized(to);

        euint64 amt = FHE.asEuint64(amount);

        // TODO: Check if sender has enough balance using FHE.ge()
        // TODO: Compute new sender balance using FHE.sub()
        // TODO: Compute new receiver balance using FHE.add()
        // TODO: Use FHE.select() for conditional update
        // TODO: Update ACL for sender's balance (contract + sender)
        // TODO: Update ACL for receiver's balance (contract + receiver)

        emit Transfer(msg.sender, to);
    }

    function approve(address spender) public {
        _approvals[msg.sender][spender] = true;
        // TODO: If balance is initialized, grant spender access via FHE.allow()
    }

    function balanceOf(address account) public view returns (euint64) {
        // TODO: Check if msg.sender is the account owner OR an approved spender
        // TODO: Check FHE.isSenderAllowed() for the balance handle
        // TODO: Return the encrypted balance
    }

    function getMyBalance() public view returns (euint64) {
        // TODO: Verify msg.sender has access using FHE.isSenderAllowed()
        // TODO: Return own balance
    }
}
\`\`\`

---

## Step-by-Step Instructions

1. **\`mint\`**: Use \`FHE.add()\` to increase balance, then \`FHE.allowThis()\` and \`FHE.allow()\` for the recipient
2. **\`transfer\`**: Implement the full safe-transfer pattern with \`FHE.ge()\`, \`FHE.select()\`, and proper ACL for both parties
3. **\`approve\`**: Store approval flag and grant ACL access with \`FHE.allow()\`
4. **\`balanceOf\`**: Check authorization before returning handle
5. **\`getMyBalance\`**: Shorthand for \`balanceOf(msg.sender)\`

---

## Hints

<details>
<summary>Hint 1: mint function</summary>

\`\`\`solidity
function mint(address to, uint64 amount) public onlyOwner {
    _ensureInitialized(to);
    _balances[to] = FHE.add(_balances[to], FHE.asEuint64(amount));
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);
    emit Mint(to);
}
\`\`\`
</details>

<details>
<summary>Hint 2: transfer function</summary>

\`\`\`solidity
function transfer(address to, uint64 amount) public {
    _ensureInitialized(msg.sender);
    _ensureInitialized(to);

    euint64 amt = FHE.asEuint64(amount);
    ebool hasEnough = FHE.ge(_balances[msg.sender], amt);

    euint64 newSenderBal = FHE.sub(_balances[msg.sender], amt);
    euint64 newReceiverBal = FHE.add(_balances[to], amt);

    _balances[msg.sender] = FHE.select(hasEnough, newSenderBal, _balances[msg.sender]);
    _balances[to] = FHE.select(hasEnough, newReceiverBal, _balances[to]);

    FHE.allowThis(_balances[msg.sender]);
    FHE.allow(_balances[msg.sender], msg.sender);
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);

    emit Transfer(msg.sender, to);
}
\`\`\`
</details>

<details>
<summary>Hint 3: balanceOf with ACL check</summary>

\`\`\`solidity
function balanceOf(address account) public view returns (euint64) {
    require(
        msg.sender == account || _approvals[account][msg.sender],
        "Not authorized"
    );
    require(
        FHE.isSenderAllowed(_balances[account]),
        "No ACL access"
    );
    return _balances[account];
}
\`\`\`
</details>

---

## Bonus Challenges

1. **Add \`transferFrom\`** that allows approved spenders to transfer on behalf of the balance owner.

2. **Add an \`allowBatch\` function** that grants ACL access to an array of addresses for a user's balance.

3. **Implement a \`revokeApproval\` function** — note that you cannot revoke ACL from the old handle; discuss the implications.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] \`mint\` correctly adds to balance with proper ACL
- [ ] \`transfer\` has underflow protection and updates ACL for both parties
- [ ] \`approve\` grants both mapping approval and \`FHE.allow()\` access
- [ ] \`balanceOf\` checks authorization before returning
- [ ] \`getMyBalance\` uses \`FHE.isSenderAllowed()\` as a guard
- [ ] All encrypted state updates include \`FHE.allowThis()\` and \`FHE.allow()\`
`,
  "06-encrypted-inputs": `# Module 06: Exercise — Encrypted Voting System

## Objective

Build an encrypted voting contract where voters submit their choices using client-side encryption (\`externalEuint8\`), ensuring that individual votes remain completely private.

---

## Task: PrivateVoting

Create a voting contract with the following features:

1. An owner registers candidates (up to 4 candidates, IDs 0-3)
2. Voters submit encrypted votes using \`externalEuint8\`
3. Each voter can only vote once
4. The contract tallies votes per candidate using encrypted counters
5. The vote tallies can only be revealed after the voting period ends

---

## Starter Code

### \`contracts/PrivateVoting.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint8, euint32, ebool, externalEuint8} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract PrivateVoting is ZamaEthereumConfig {
    address public owner;
    bool public votingOpen;
    uint8 public candidateCount;

    mapping(address => bool) private _hasVoted;
    mapping(address => ebool) private _encryptedHasVoted;

    // Encrypted vote tallies per candidate
    euint32 private _tally0;
    euint32 private _tally1;
    euint32 private _tally2;
    euint32 private _tally3;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(uint8 _candidateCount) {
        require(_candidateCount >= 2 && _candidateCount <= 4, "2-4 candidates");
        owner = msg.sender;
        candidateCount = _candidateCount;
        votingOpen = true;

        // TODO: Initialize all tally counters to encrypted 0
        // TODO: FHE.allowThis() for each tally
    }

    /// @notice Cast an encrypted vote
    /// @param encryptedVote Client-encrypted candidate ID (0 to candidateCount-1)
    /// @param inputProof The ZK proof for the encrypted input
    function vote(externalEuint8 encryptedVote, bytes calldata inputProof) external {
        require(votingOpen, "Voting closed");
        require(!_hasVoted[msg.sender], "Already voted");

        // TODO: Convert external input using FHE.fromExternal(encryptedVote, inputProof)

        // TODO: For each candidate, check if vote == candidateId using FHE.eq()
        // TODO: If match, increment that candidate's tally by 1 using FHE.add() + FHE.select()

        // Mark as voted
        _hasVoted[msg.sender] = true;

        // TODO: FHE.allowThis() for all updated tallies
    }

    function closeVoting() public onlyOwner {
        votingOpen = false;
    }

    /// @notice Get encrypted tally for a candidate (only after voting closes)
    function getTally(uint8 candidateId) public view returns (euint32) {
        require(!votingOpen, "Voting still open");
        require(candidateId < candidateCount, "Invalid candidate");

        // TODO: Return the appropriate tally based on candidateId
    }
}
\`\`\`

---

## Step-by-Step Instructions

1. **Constructor**: Initialize \`_tally0\` through \`_tally3\` with \`FHE.asEuint32(0)\` and call \`FHE.allowThis()\` for each.

2. **\`vote\` function**:
   - Convert the external input: \`euint8 v = FHE.fromExternal(encryptedVote, inputProof);\`
   - For each candidate \`i\`, check if the vote matches: \`ebool isCandidate_i = FHE.eq(v, FHE.asEuint8(i));\`
   - Create an encrypted 1 or 0 based on the match: \`euint32 increment = FHE.select(isCandidate_i, FHE.asEuint32(1), FHE.asEuint32(0));\`
   - Add to the tally: \`_tally_i = FHE.add(_tally_i, increment);\`
   - Call \`FHE.allowThis()\` for each updated tally

3. **\`getTally\`**: Use if/else on the candidateId to return the correct tally variable.

---

## Hints

<details>
<summary>Hint 1: Constructor initialization</summary>

\`\`\`solidity
_tally0 = FHE.asEuint32(0);
_tally1 = FHE.asEuint32(0);
_tally2 = FHE.asEuint32(0);
_tally3 = FHE.asEuint32(0);
FHE.allowThis(_tally0);
FHE.allowThis(_tally1);
FHE.allowThis(_tally2);
FHE.allowThis(_tally3);
\`\`\`
</details>

<details>
<summary>Hint 2: Vote tallying logic</summary>

\`\`\`solidity
euint8 v = FHE.fromExternal(encryptedVote, inputProof);

euint32 one = FHE.asEuint32(1);
euint32 zero = FHE.asEuint32(0);

ebool is0 = FHE.eq(v, FHE.asEuint8(0));
_tally0 = FHE.add(_tally0, FHE.select(is0, one, zero));

ebool is1 = FHE.eq(v, FHE.asEuint8(1));
_tally1 = FHE.add(_tally1, FHE.select(is1, one, zero));

ebool is2 = FHE.eq(v, FHE.asEuint8(2));
_tally2 = FHE.add(_tally2, FHE.select(is2, one, zero));

ebool is3 = FHE.eq(v, FHE.asEuint8(3));
_tally3 = FHE.add(_tally3, FHE.select(is3, one, zero));

FHE.allowThis(_tally0);
FHE.allowThis(_tally1);
FHE.allowThis(_tally2);
FHE.allowThis(_tally3);
\`\`\`
</details>

<details>
<summary>Hint 3: getTally function</summary>

\`\`\`solidity
function getTally(uint8 candidateId) public view returns (euint32) {
    require(!votingOpen, "Voting still open");
    require(candidateId < candidateCount, "Invalid candidate");
    if (candidateId == 0) return _tally0;
    if (candidateId == 1) return _tally1;
    if (candidateId == 2) return _tally2;
    return _tally3;
}
\`\`\`
</details>

---

## Client-Side Integration Code

\`\`\`javascript
// Encrypting a vote for candidate 2
const input = await instance.input.createEncryptedInput(
    contractAddress,
    userAddress
);
input.add8(2); // Vote for candidate 2
const encrypted = await input.encrypt();

const tx = await contract.vote(
    encrypted.handles[0],
    encrypted.inputProof
);
await tx.wait();
\`\`\`

---

## Bonus Challenges

1. **Add voter registration** — Only pre-registered addresses can vote. The owner calls \`registerVoter(address)\` before voting starts.

2. **Add encrypted voter tracking** — Instead of a plaintext \`_hasVoted\` mapping, store an \`ebool\` so that even the fact of whether someone voted is encrypted.

3. **Support up to 8 candidates** — Refactor the tallying to use a loop-friendly pattern or an array approach.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] \`vote\` accepts \`externalEuint8\` and \`bytes calldata inputProof\` parameters
- [ ] \`FHE.fromExternal(input, inputProof)\` is used to convert the input
- [ ] Each candidate's tally is correctly incremented based on the encrypted vote
- [ ] \`FHE.allowThis()\` is called for all updated tallies
- [ ] Tallies are only accessible after voting closes
- [ ] Each voter can only vote once
`,
  "07-decryption": `# Module 07: Exercise — Revealable Auction Contract

## Objective

Build a sealed-bid auction contract that uses **encrypted inputs** for private bids and **public decryption** via \`FHE.makePubliclyDecryptable()\` to reveal the winning bid after the auction closes.

---

## Task: RevealableAuction

Create an auction contract with these features:

1. Users submit sealed bids using \`externalEuint64\`
2. The contract tracks the highest bid and the highest bidder (both encrypted)
3. The owner can close the auction and reveal the winning bid publicly
4. Users can view their own bids via ACL-protected reencryption

---

## Starter Code

### \`contracts/RevealableAuction.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, eaddress, ebool, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract RevealableAuction is ZamaEthereumConfig {
    address public owner;
    bool public auctionOpen;
    bool public revealed;

    mapping(address => euint64) private _bids;
    mapping(address => bool) private _hasBid;

    euint64 private _highestBid;
    eaddress private _highestBidder;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor() {
        owner = msg.sender;
        auctionOpen = true;
        revealed = false;

        // TODO: Initialize _highestBid to encrypted 0
        // TODO: Initialize _highestBidder to encrypted address(0)
        // TODO: FHE.allowThis() for both
    }

    function submitBid(externalEuint64 encryptedBid, bytes calldata inputProof) external {
        require(auctionOpen, "Auction closed");
        require(!_hasBid[msg.sender], "Already bid");

        // TODO: Convert external input with FHE.fromExternal(encryptedBid, inputProof)
        // TODO: Store the bid in _bids mapping
        // TODO: Mark _hasBid as true

        // TODO: Compare with _highestBid using FHE.gt()
        // TODO: Update _highestBid using FHE.select()
        // TODO: Update _highestBidder using FHE.select()

        // TODO: ACL for bid (contract + user)
        // TODO: ACL for _highestBid and _highestBidder (contract)
    }

    function closeAuction() public onlyOwner {
        require(auctionOpen, "Already closed");
        auctionOpen = false;
    }

    function revealWinner() public onlyOwner {
        require(!auctionOpen, "Close auction first");
        require(!revealed, "Already revealed");

        // TODO: Call FHE.makePubliclyDecryptable() for _highestBid
        // TODO: Set revealed to true
    }

    function getMyBid() public view returns (euint64) {
        require(_hasBid[msg.sender], "No bid placed");
        // TODO: Check FHE.isSenderAllowed() for the user's bid
        // TODO: Return the encrypted bid handle
    }
}
\`\`\`

---

## Step-by-Step Instructions

1. **Constructor**: Initialize \`_highestBid\` with \`FHE.asEuint64(0)\` and \`_highestBidder\` with \`FHE.asEaddress(address(0))\`. Call \`FHE.allowThis()\` for both.

2. **\`submitBid\`**: Convert input with \`FHE.fromExternal()\`, store bid, compare with \`FHE.gt()\`, update with \`FHE.select()\`, set ACL permissions.

3. **\`closeAuction\`**: Simple flag flip (already implemented).

4. **\`revealWinner\`**: Call \`FHE.makePubliclyDecryptable(_highestBid)\` and set \`revealed = true\`.

5. **\`getMyBid\`**: Check \`FHE.isSenderAllowed()\` and return the encrypted handle.

---

## Hints

<details>
<summary>Hint 1: Constructor initialization</summary>

\`\`\`solidity
constructor() {
    owner = msg.sender;
    auctionOpen = true;
    revealed = false;

    _highestBid = FHE.asEuint64(0);
    _highestBidder = FHE.asEaddress(address(0));
    FHE.allowThis(_highestBid);
    FHE.allowThis(_highestBidder);
}
\`\`\`
</details>

<details>
<summary>Hint 2: submitBid with highest bid tracking</summary>

\`\`\`solidity
function submitBid(externalEuint64 encryptedBid, bytes calldata inputProof) external {
    require(auctionOpen, "Auction closed");
    require(!_hasBid[msg.sender], "Already bid");

    euint64 bid = FHE.fromExternal(encryptedBid, inputProof);
    _bids[msg.sender] = bid;
    _hasBid[msg.sender] = true;

    ebool isHigher = FHE.gt(bid, _highestBid);
    _highestBid = FHE.select(isHigher, bid, _highestBid);
    _highestBidder = FHE.select(isHigher, FHE.asEaddress(msg.sender), _highestBidder);

    FHE.allowThis(_bids[msg.sender]);
    FHE.allow(_bids[msg.sender], msg.sender);
    FHE.allowThis(_highestBid);
    FHE.allowThis(_highestBidder);
}
\`\`\`
</details>

<details>
<summary>Hint 3: revealWinner and getMyBid</summary>

\`\`\`solidity
function revealWinner() public onlyOwner {
    require(!auctionOpen, "Close auction first");
    require(!revealed, "Already revealed");

    FHE.makePubliclyDecryptable(_highestBid);
    revealed = true;
}

function getMyBid() public view returns (euint64) {
    require(_hasBid[msg.sender], "No bid placed");
    require(FHE.isSenderAllowed(_bids[msg.sender]), "Not authorized");
    return _bids[msg.sender];
}
\`\`\`
</details>

---

## Bonus Challenges

1. **Reveal the winner's address too** — Also call \`FHE.makePubliclyDecryptable(_highestBidder)\` in \`revealWinner()\`.

2. **Add a reserve price** — In the constructor, set a minimum bid amount. In \`submitBid\`, use \`FHE.ge()\` to check the bid meets the reserve.

3. **Add bid count tracking** — Track the total number of bids and emit events.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] Inherits \`ZamaEthereumConfig\` (NOT \`GatewayConfig\`)
- [ ] \`submitBid\` uses \`externalEuint64\` + \`bytes calldata inputProof\` and \`FHE.fromExternal(input, inputProof)\`
- [ ] Highest bid is tracked using \`FHE.gt()\` + \`FHE.select()\`
- [ ] \`revealWinner\` uses \`FHE.makePubliclyDecryptable()\` (NOT Gateway)
- [ ] \`getMyBid\` checks \`FHE.isSenderAllowed()\` before returning
- [ ] All encrypted state updates have proper ACL calls
`,
  "08-conditional-logic": `# Module 08: Exercise — Encrypted Marketplace with Conditional Logic

## Objective

Build an encrypted marketplace contract that uses \`FHE.select()\` extensively for pricing tiers, inventory management, and conditional order fulfillment.

---

## Task: EncryptedMarketplace

Create a contract where:

1. Sellers list items with encrypted prices and encrypted quantities
2. Buyers place orders — the order only succeeds if the buyer has enough balance AND stock is available
3. A tiered discount is applied based on the quantity ordered
4. All logic must use \`FHE.select()\` — no plaintext branching on encrypted values

---

## Starter Code

### \`contracts/EncryptedMarketplace.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, euint64, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedMarketplace is ZamaEthereumConfig {
    struct Item {
        address seller;
        euint64 pricePerUnit;
        euint32 stock;
        bool exists;
    }

    mapping(uint256 => Item) private _items;
    mapping(address => euint64) private _balances;
    mapping(address => bool) private _balInitialized;
    uint256 public nextItemId;

    function _initBalance(address user) internal {
        if (!_balInitialized[user]) {
            _balances[user] = FHE.asEuint64(0);
            FHE.allowThis(_balances[user]);
            FHE.allow(_balances[user], user);
            _balInitialized[user] = true;
        }
    }

    function deposit(uint64 amount) public {
        _initBalance(msg.sender);
        _balances[msg.sender] = FHE.add(_balances[msg.sender], FHE.asEuint64(amount));
        FHE.allowThis(_balances[msg.sender]);
        FHE.allow(_balances[msg.sender], msg.sender);
    }

    function listItem(uint64 pricePerUnit, uint32 stock) public {
        uint256 itemId = nextItemId++;
        _items[itemId] = Item({
            seller: msg.sender,
            pricePerUnit: FHE.asEuint64(pricePerUnit),
            stock: FHE.asEuint32(stock),
            exists: true
        });
        FHE.allowThis(_items[itemId].pricePerUnit);
        FHE.allowThis(_items[itemId].stock);
    }

    /// @notice Buy \`quantity\` units of item \`itemId\`
    function buyItem(uint256 itemId, uint32 quantity) public {
        require(_items[itemId].exists, "Item not found");
        _initBalance(msg.sender);
        _initBalance(_items[itemId].seller);

        euint32 qty = FHE.asEuint32(quantity);

        // TODO Step 1: Calculate discount tier using nested FHE.select()
        // qty >= 100 -> 20% discount (multiplier = 80)
        // qty >= 50  -> 10% discount (multiplier = 90)
        // qty >= 10  -> 5% discount (multiplier = 95)
        // qty < 10   -> no discount (multiplier = 100)

        // TODO Step 2: Calculate total cost
        // totalCost = (pricePerUnit * quantity * multiplier) / 100

        // TODO Step 3: Check conditions with FHE.and()
        // hasStock = stock >= quantity
        // hasFunds = balance >= totalCost
        // valid = hasStock AND hasFunds

        // TODO Step 4: Conditional updates with FHE.select()
        // If valid: deduct from buyer, add to seller, reduce stock
        // If invalid: keep everything unchanged

        // TODO Step 5: ACL updates
    }

    function getBalance() public view returns (euint64) {
        require(FHE.isSenderAllowed(_balances[msg.sender]), "No access");
        return _balances[msg.sender];
    }
}
\`\`\`

---

## Hints

<details>
<summary>Hint 1: Discount tier with nested selects</summary>

\`\`\`solidity
euint64 multiplier = FHE.asEuint64(100);
multiplier = FHE.select(FHE.ge(qty, FHE.asEuint32(10)), FHE.asEuint64(95), multiplier);
multiplier = FHE.select(FHE.ge(qty, FHE.asEuint32(50)), FHE.asEuint64(90), multiplier);
multiplier = FHE.select(FHE.ge(qty, FHE.asEuint32(100)), FHE.asEuint64(80), multiplier);
\`\`\`
</details>

<details>
<summary>Hint 2: Total cost calculation</summary>

\`\`\`solidity
euint64 baseTotal = FHE.mul(_items[itemId].pricePerUnit, FHE.asEuint64(quantity));
euint64 discounted = FHE.mul(baseTotal, multiplier);
euint64 totalCost = FHE.div(discounted, 100);
\`\`\`

> **Note:** \`FHE.div()\` only accepts a **plaintext** second operand (e.g., \`FHE.div(encVal, 100)\`). You cannot divide by an encrypted value.
</details>

<details>
<summary>Hint 3: Conditional updates</summary>

\`\`\`solidity
ebool hasStock = FHE.ge(_items[itemId].stock, qty);
ebool hasFunds = FHE.ge(_balances[msg.sender], totalCost);
ebool valid = FHE.and(hasStock, hasFunds);

_balances[msg.sender] = FHE.select(valid,
    FHE.sub(_balances[msg.sender], totalCost), _balances[msg.sender]);
_balances[_items[itemId].seller] = FHE.select(valid,
    FHE.add(_balances[_items[itemId].seller], totalCost), _balances[_items[itemId].seller]);
_items[itemId].stock = FHE.select(valid,
    FHE.sub(_items[itemId].stock, qty), _items[itemId].stock);

FHE.allowThis(_balances[msg.sender]);
FHE.allow(_balances[msg.sender], msg.sender);
FHE.allowThis(_balances[_items[itemId].seller]);
FHE.allow(_balances[_items[itemId].seller], _items[itemId].seller);
FHE.allowThis(_items[itemId].stock);
\`\`\`
</details>

---

## Bonus Challenges

1. **Add a refund function** using \`FHE.select()\` to only refund if the seller has enough balance.
2. **Add quantity limits** — Clamp the quantity to max 200 per order using \`FHE.min()\`.
3. **Add an \`isOrderValid\` function** returning \`ebool\` without executing the order.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] Tiered discount uses nested \`FHE.select()\` calls
- [ ] Order validation combines conditions with \`FHE.and()\`
- [ ] All updates use \`FHE.select()\` for conditional execution
- [ ] No \`if\` branching on encrypted values
- [ ] All encrypted state updates include proper ACL calls
`,
  "09-random": `# Module 09: Exercise — On-Chain Encrypted Randomness

## Objective

Build a series of contracts that use FHEVM's encrypted random number generation. You will implement a dice roller, a random pair generator, a coin flip mechanism, and an encrypted lottery system. All random values must remain encrypted and use proper ACL permissions.

---

## Task 1: Encrypted Dice Roller

Create a contract that simulates rolling a fair six-sided die. The result (1 through 6) must remain encrypted until the roller chooses to decrypt it.

### Requirements

1. Generate a random \`euint8\` using \`FHE.randEuint8()\`
2. Use \`FHE.rem()\` with \`6\` to get a value in \`[0, 5]\`
3. Use \`FHE.add()\` with plaintext \`1\` to shift the range to \`[1, 6]\`
4. Store the result per player and grant ACL to both the contract and the caller

### Starter Code

#### \`contracts/EncryptedDiceRoller.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint8} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedDiceRoller is ZamaEthereumConfig {
    mapping(address => euint8) private _lastRoll;
    mapping(address => uint256) private _rollCount;

    event DiceRolled(address indexed player, uint256 rollNumber);

    /// @notice Roll a fair six-sided die. Result is encrypted.
    function roll() public {
        // TODO Step 1: Generate a random euint8
        // euint8 random = FHE.randEuint8();

        // TODO Step 2: Constrain to range [0, 5] using FHE.rem()
        // euint8 zeroToFive = FHE.rem(random, ...);

        // TODO Step 3: Shift to range [1, 6] using FHE.add() with plaintext 1
        // euint8 diceResult = FHE.add(zeroToFive, ...);

        // TODO Step 4: Store the result
        // _lastRoll[msg.sender] = diceResult;

        // TODO Step 5: Set ACL permissions
        // FHE.allowThis(diceResult);
        // FHE.allow(diceResult, msg.sender);

        // TODO Step 6: Update roll count and emit event
        // _rollCount[msg.sender]++;
        // emit DiceRolled(msg.sender, _rollCount[msg.sender]);
    }

    /// @notice Get your last dice roll (encrypted). Only callable by the roller.
    function getLastRoll() public view returns (euint8) {
        require(FHE.isSenderAllowed(_lastRoll[msg.sender]), "No access");
        return _lastRoll[msg.sender];
    }

    /// @notice Get total number of rolls for a player (plaintext).
    function getRollCount(address player) public view returns (uint256) {
        return _rollCount[player];
    }
}
\`\`\`

<details>
<summary>Hint 1: Generating and constraining the random value</summary>

\`\`\`solidity
euint8 random = FHE.randEuint8();
euint8 zeroToFive = FHE.rem(random, 6);
euint8 diceResult = FHE.add(zeroToFive, FHE.asEuint8(1));
\`\`\`

\`FHE.rem(value, 6)\` returns a value in \`[0, 5]\`. Adding \`FHE.asEuint8(1)\` shifts the range to \`[1, 6]\`, which maps to a standard die face.
</details>

<details>
<summary>Hint 2: Complete roll() implementation</summary>

\`\`\`solidity
function roll() public {
    euint8 random = FHE.randEuint8();
    euint8 zeroToFive = FHE.rem(random, 6);
    euint8 diceResult = FHE.add(zeroToFive, FHE.asEuint8(1));

    _lastRoll[msg.sender] = diceResult;

    FHE.allowThis(diceResult);
    FHE.allow(diceResult, msg.sender);

    _rollCount[msg.sender]++;
    emit DiceRolled(msg.sender, _rollCount[msg.sender]);
}
\`\`\`
</details>

---

## Task 2: Random Pair Generator

Create a contract that generates two independent encrypted random \`euint32\` values as a pair. This simulates scenarios like rolling two dice, generating coordinate pairs, or creating paired random attributes.

### Requirements

1. Generate two independent \`euint32\` random values using separate \`FHE.randEuint32()\` calls
2. Store both values per user
3. Grant ACL permissions for both values to the contract and the caller
4. Provide a way for the user to retrieve each value independently

### Starter Code

#### \`contracts/RandomPairGenerator.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract RandomPairGenerator is ZamaEthereumConfig {
    struct RandomPair {
        euint32 first;
        euint32 second;
        bool exists;
    }

    mapping(address => RandomPair) private _pairs;

    event PairGenerated(address indexed user);

    /// @notice Generate a new random pair of euint32 values.
    function generatePair() public {
        // TODO Step 1: Generate first random euint32
        // euint32 val1 = FHE.randEuint32();

        // TODO Step 2: Generate second random euint32 (independent)
        // euint32 val2 = FHE.randEuint32();

        // TODO Step 3: Store the pair
        // _pairs[msg.sender] = RandomPair(val1, val2, true);

        // TODO Step 4: Set ACL for both values
        // FHE.allowThis(val1);
        // FHE.allow(val1, msg.sender);
        // FHE.allowThis(val2);
        // FHE.allow(val2, msg.sender);

        // TODO Step 5: Emit event
        // emit PairGenerated(msg.sender);
    }

    /// @notice Retrieve the first value of your random pair.
    function getFirst() public view returns (euint32) {
        require(_pairs[msg.sender].exists, "No pair generated");
        require(FHE.isSenderAllowed(_pairs[msg.sender].first), "No access");
        return _pairs[msg.sender].first;
    }

    /// @notice Retrieve the second value of your random pair.
    function getSecond() public view returns (euint32) {
        require(_pairs[msg.sender].exists, "No pair generated");
        require(FHE.isSenderAllowed(_pairs[msg.sender].second), "No access");
        return _pairs[msg.sender].second;
    }

    /// @notice Check if a user has a generated pair.
    function hasPair(address user) public view returns (bool) {
        return _pairs[user].exists;
    }
}
\`\`\`

<details>
<summary>Hint 1: Why two separate calls?</summary>

Each call to \`FHE.randEuint32()\` generates an independent encrypted random value. Calling it twice in the same function produces two unrelated values, similar to rolling two separate dice. There is no correlation between the two outputs.
</details>

<details>
<summary>Hint 2: Complete generatePair() implementation</summary>

\`\`\`solidity
function generatePair() public {
    euint32 val1 = FHE.randEuint32();
    euint32 val2 = FHE.randEuint32();

    _pairs[msg.sender] = RandomPair(val1, val2, true);

    FHE.allowThis(val1);
    FHE.allow(val1, msg.sender);
    FHE.allowThis(val2);
    FHE.allow(val2, msg.sender);

    emit PairGenerated(msg.sender);
}
\`\`\`

Note: You must set ACL for each encrypted value individually. There is no batch ACL function.
</details>

---

## Task 3: Encrypted Coin Flip

Implement a coin flip contract that returns an encrypted boolean result. The contract should support two approaches: using \`FHE.randEbool()\` directly, and using \`FHE.randEuint8()\` with modulo 2 as an alternative.

### Requirements

1. Primary method: use \`FHE.randEbool()\` to generate a random encrypted boolean
2. Alternative method: use \`FHE.randEuint8()\`, apply \`FHE.rem()\` with \`2\`, then convert to \`ebool\` using \`FHE.ne()\` with \`0\`
3. Store the result per player with proper ACL
4. Track flip history count per player

### Starter Code

#### \`contracts/EncryptedCoinFlip.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint8, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedCoinFlip is ZamaEthereumConfig {
    mapping(address => ebool) private _lastFlip;
    mapping(address => uint256) private _flipCount;
    mapping(address => bool) private _hasFlipped;

    event CoinFlipped(address indexed player, uint256 flipNumber);

    /// @notice Flip a coin using FHE.randEbool(). Result is encrypted.
    function flipDirect() public {
        // TODO Step 1: Generate random ebool directly
        // ebool result = FHE.randEbool();

        // TODO Step 2: Store result
        // _lastFlip[msg.sender] = result;
        // _hasFlipped[msg.sender] = true;

        // TODO Step 3: Set ACL
        // FHE.allowThis(result);
        // FHE.allow(result, msg.sender);

        // TODO Step 4: Update count and emit
        // _flipCount[msg.sender]++;
        // emit CoinFlipped(msg.sender, _flipCount[msg.sender]);
    }

    /// @notice Flip a coin using FHE.randEuint8() + FHE.rem() + FHE.ne().
    function flipViaModulo() public {
        // TODO Step 1: Generate random euint8
        // euint8 random = FHE.randEuint8();

        // TODO Step 2: Get 0 or 1 via modulo
        // euint8 zeroOrOne = FHE.rem(random, 2);

        // TODO Step 3: Convert to ebool (0 -> false, 1 -> true)
        // ebool result = FHE.ne(zeroOrOne, 0);

        // TODO Step 4: Store result
        // _lastFlip[msg.sender] = result;
        // _hasFlipped[msg.sender] = true;

        // TODO Step 5: Set ACL
        // FHE.allowThis(result);
        // FHE.allow(result, msg.sender);

        // TODO Step 6: Update count and emit
        // _flipCount[msg.sender]++;
        // emit CoinFlipped(msg.sender, _flipCount[msg.sender]);
    }

    /// @notice Get your last coin flip result (encrypted boolean).
    function getLastFlip() public view returns (ebool) {
        require(_hasFlipped[msg.sender], "No flip yet");
        require(FHE.isSenderAllowed(_lastFlip[msg.sender]), "No access");
        return _lastFlip[msg.sender];
    }

    /// @notice Get total number of flips for a player.
    function getFlipCount(address player) public view returns (uint256) {
        return _flipCount[player];
    }
}
\`\`\`

<details>
<summary>Hint 1: FHE.randEbool() vs modulo approach</summary>

\`FHE.randEbool()\` is the simplest approach and directly returns an \`ebool\`. The modulo approach (\`FHE.randEuint8()\` + \`FHE.rem(..., 2)\` + \`FHE.ne(..., 0)\`) is more verbose but demonstrates how to convert between encrypted types. The direct approach is preferred for production use.
</details>

<details>
<summary>Hint 2: Complete flipDirect() implementation</summary>

\`\`\`solidity
function flipDirect() public {
    ebool result = FHE.randEbool();

    _lastFlip[msg.sender] = result;
    _hasFlipped[msg.sender] = true;

    FHE.allowThis(result);
    FHE.allow(result, msg.sender);

    _flipCount[msg.sender]++;
    emit CoinFlipped(msg.sender, _flipCount[msg.sender]);
}
\`\`\`
</details>

<details>
<summary>Hint 3: Complete flipViaModulo() implementation</summary>

\`\`\`solidity
function flipViaModulo() public {
    euint8 random = FHE.randEuint8();
    euint8 zeroOrOne = FHE.rem(random, 2);
    ebool result = FHE.ne(zeroOrOne, 0);

    _lastFlip[msg.sender] = result;
    _hasFlipped[msg.sender] = true;

    FHE.allowThis(result);
    FHE.allow(result, msg.sender);

    _flipCount[msg.sender]++;
    emit CoinFlipped(msg.sender, _flipCount[msg.sender]);
}
\`\`\`

The key insight: \`FHE.ne(zeroOrOne, 0)\` returns an \`ebool\` that is encrypted \`true\` when \`zeroOrOne\` is 1, and encrypted \`false\` when it is 0.
</details>

---

## Task 4: Encrypted Lottery

Build a full encrypted lottery contract. Players enter the lottery and receive encrypted ticket numbers. When the lottery closes, a random encrypted winner index is generated. The winner can only be revealed through a controlled decryption process.

### Requirements

1. Players enter the lottery; each receives an encrypted \`euint32\` ticket number via \`FHE.randEuint32()\`
2. The contract owner can close entry and trigger winner selection
3. Winner selection uses \`FHE.randEuint32()\` with \`FHE.rem()\` based on the number of participants
4. The encrypted winner index is stored and can only be revealed by the owner
5. Proper ACL on all encrypted values

### Starter Code

#### \`contracts/EncryptedLottery.sol\`

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedLottery is ZamaEthereumConfig {
    address public owner;
    bool public isOpen;
    bool public winnerSelected;

    address[] public players;
    mapping(address => euint32) private _tickets;
    mapping(address => bool) private _hasEntered;

    euint32 private _winnerIndex;

    event LotteryOpened();
    event PlayerEntered(address indexed player, uint256 playerCount);
    event LotteryClosed(uint256 totalPlayers);
    event WinnerSelected();

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    constructor() {
        owner = msg.sender;
        isOpen = false;
        winnerSelected = false;
    }

    /// @notice Owner opens the lottery for entries.
    function openLottery() public onlyOwner {
        require(!isOpen, "Already open");
        require(!winnerSelected, "Lottery already completed");

        // Reset state for a new round
        for (uint256 i = 0; i < players.length; i++) {
            _hasEntered[players[i]] = false;
        }
        delete players;

        isOpen = true;
        winnerSelected = false;
        emit LotteryOpened();
    }

    /// @notice Enter the lottery. Each player gets an encrypted random ticket number.
    function enter() public {
        require(isOpen, "Lottery not open");
        require(!_hasEntered[msg.sender], "Already entered");

        // TODO Step 1: Generate a random encrypted ticket number for the player
        // euint32 ticket = FHE.randEuint32();

        // TODO Step 2: Store the ticket
        // _tickets[msg.sender] = ticket;

        // TODO Step 3: Set ACL so the contract and the player can access the ticket
        // FHE.allowThis(ticket);
        // FHE.allow(ticket, msg.sender);

        // TODO Step 4: Register the player
        // _hasEntered[msg.sender] = true;
        // players.push(msg.sender);

        // emit PlayerEntered(msg.sender, players.length);
    }

    /// @notice Owner closes the lottery and selects a winner.
    function closeLotteryAndPickWinner() public onlyOwner {
        require(isOpen, "Lottery not open");
        require(players.length >= 2, "Need at least 2 players");

        isOpen = false;
        emit LotteryClosed(players.length);

        // TODO Step 5: Generate a random value for winner selection
        // euint32 randomValue = FHE.randEuint32();

        // TODO Step 6: Use FHE.rem() to get an index in [0, players.length)
        // _winnerIndex = FHE.rem(randomValue, uint32(players.length));

        // TODO Step 7: Set ACL for the winner index
        // FHE.allowThis(_winnerIndex);
        // FHE.allow(_winnerIndex, owner);

        // winnerSelected = true;
        // emit WinnerSelected();
    }

    /// @notice Get your encrypted ticket number.
    function getMyTicket() public view returns (euint32) {
        require(_hasEntered[msg.sender], "Not entered");
        require(FHE.isSenderAllowed(_tickets[msg.sender]), "No access");
        return _tickets[msg.sender];
    }

    /// @notice Get the encrypted winner index (owner only, for decryption).
    function getWinnerIndex() public view returns (euint32) {
        require(winnerSelected, "Winner not selected");
        require(FHE.isSenderAllowed(_winnerIndex), "No access");
        return _winnerIndex;
    }

    /// @notice Get the total number of players.
    function getPlayerCount() public view returns (uint256) {
        return players.length;
    }

    /// @notice Get a player address by index (for resolving winner after decryption).
    function getPlayer(uint256 index) public view returns (address) {
        require(index < players.length, "Index out of bounds");
        return players[index];
    }
}
\`\`\`

<details>
<summary>Hint 1: Ticket generation in enter()</summary>

\`\`\`solidity
function enter() public {
    require(isOpen, "Lottery not open");
    require(!_hasEntered[msg.sender], "Already entered");

    euint32 ticket = FHE.randEuint32();
    _tickets[msg.sender] = ticket;

    FHE.allowThis(ticket);
    FHE.allow(ticket, msg.sender);

    _hasEntered[msg.sender] = true;
    players.push(msg.sender);

    emit PlayerEntered(msg.sender, players.length);
}
\`\`\`

Each player receives a unique encrypted random ticket number. The ticket is stored in a mapping and ACL is granted so the player can later request decryption.
</details>

<details>
<summary>Hint 2: Winner selection in closeLotteryAndPickWinner()</summary>

\`\`\`solidity
function closeLotteryAndPickWinner() public onlyOwner {
    require(isOpen, "Lottery not open");
    require(players.length >= 2, "Need at least 2 players");

    isOpen = false;
    emit LotteryClosed(players.length);

    euint32 randomValue = FHE.randEuint32();
    _winnerIndex = FHE.rem(randomValue, uint32(players.length));

    FHE.allowThis(_winnerIndex);
    FHE.allow(_winnerIndex, owner);

    winnerSelected = true;
    emit WinnerSelected();
}
\`\`\`

The winner index is an encrypted \`euint32\` in the range \`[0, players.length)\`. Nobody, including the owner, knows the winner until the encrypted index is decrypted through the FHEVM gateway. The owner is granted ACL so they can initiate the decryption request.

> **Tip:** If \`players.length\` happens to be a power of 2, you could use the bounded overload \`FHE.randEuint32(uint32(players.length))\` instead of \`FHE.rem()\` for better efficiency. However, since player counts are rarely guaranteed to be powers of 2, \`FHE.rem()\` is the general-purpose approach.
</details>

<details>
<summary>Hint 3: Resolving the winner after decryption</summary>

After the owner makes \`_winnerIndex\` publicly decryptable, anyone can decrypt the winner index client-side. The full flow is:

1. Owner calls \`closeLotteryAndPickWinner()\` -- generates encrypted winner index
2. Owner calls \`FHE.makePubliclyDecryptable(_winnerIndex)\` to allow public decryption
3. Client-side decryption reveals the plaintext index (e.g., \`3\`)
4. Owner calls \`getPlayer(3)\` to get the winner's address

This two-phase approach ensures the winner cannot be known until the explicit reveal step.
</details>

---

## Bonus Challenges

1. **Bounded Dice Roller** -- Modify the dice roller to accept a custom number of sides (e.g., D4, D8, D12, D20) as a parameter to \`roll(uint8 sides)\`.

2. **Multi-Round Lottery** -- Extend the lottery to support multiple rounds, storing the winner of each round in an array and allowing the owner to start new rounds after each draw.

3. **Random Team Assignment** -- Create a contract that randomly assigns \`N\` players into two encrypted teams. Use \`FHE.randEbool()\` for each player to decide their team (true = Team A, false = Team B).

---

## Success Criteria

- [ ] **Task 1:** \`EncryptedDiceRoller\` compiles and \`roll()\` generates values in the range \`[1, 6]\`
- [ ] **Task 1:** ACL is correctly set for both the contract (\`FHE.allowThis\`) and the caller (\`FHE.allow\`)
- [ ] **Task 2:** \`RandomPairGenerator\` generates two independent \`euint32\` values per call
- [ ] **Task 2:** Both values have individual ACL permissions set
- [ ] **Task 3:** \`EncryptedCoinFlip\` implements both \`flipDirect()\` and \`flipViaModulo()\`
- [ ] **Task 3:** \`flipViaModulo()\` correctly converts from \`euint8\` to \`ebool\` using \`FHE.ne()\`
- [ ] **Task 4:** \`EncryptedLottery\` assigns encrypted tickets to players on entry
- [ ] **Task 4:** Winner selection uses \`FHE.randEuint32()\` with \`FHE.rem()\` based on player count
- [ ] **Task 4:** Winner index ACL is granted to the owner for decryption
- [ ] **All Tasks:** No use of \`TFHE\` library (use \`FHE\` only)
- [ ] **All Tasks:** Correct function names (\`FHE.randEuint32()\`, NOT \`FHE.randomEuint32()\`)
- [ ] **All Tasks:** All contracts inherit \`ZamaEthereumConfig\`
- [ ] **All Tasks:** All encrypted values have proper ACL permissions before storage
`,
  "10-frontend-integration": `# Module 10: Exercise -- Build a Frontend for SimpleCounter

## Objective

Build a React frontend that connects to the \`SimpleCounter\` FHEVM contract, allowing users to encrypt inputs, send transactions, and decrypt their counter value.

---

## Prerequisites

- Node.js 18+
- MetaMask installed
- A deployed \`SimpleCounter\` contract on a FHEVM-enabled testnet

---

## Task 1: Project Setup

Create a new React + Vite project and install dependencies:

\`\`\`bash
npm create vite@latest fhevm-counter-app -- --template react-ts
cd fhevm-counter-app
npm install @zama-fhe/relayer-sdk ethers
\`\`\`

---

## Task 2: FHE Instance Helper

Create a file \`src/fhevm.ts\` that exports an \`initFhevm()\` function:

\`\`\`typescript
// src/fhevm.ts
import { createInstance } from "@zama-fhe/relayer-sdk/web";
import { BrowserProvider } from "ethers";

// TODO: Create a singleton FHE instance
// 1. Check if instance already exists (avoid re-init)
// 2. Create a BrowserProvider from window.ethereum
// 3. Call createInstance() with network and relayerUrl
// 4. Return the instance
\`\`\`

---

## Task 3: Encrypt and Send

Create a file \`src/counter.ts\` with functions to interact with the contract:

\`\`\`typescript
// src/counter.ts
import { Contract, BrowserProvider } from "ethers";
import { initFhevm } from "./fhevm";

const COUNTER_ADDRESS = "YOUR_DEPLOYED_ADDRESS";
const COUNTER_ABI = [
  "function increment(bytes32 encValue, bytes calldata inputProof) external",
  "function getMyCount() external view returns (uint256)",
];

export async function incrementCounter(amount: number): Promise<void> {
  const provider = new BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const userAddress = await signer.getAddress();
  const contract = new Contract(COUNTER_ADDRESS, COUNTER_ABI, signer);
  const instance = await initFhevm();

  // TODO: Create encrypted input using instance.createEncryptedInput()
  // TODO: Add a 32-bit value using input.add32(amount)
  // TODO: Encrypt the input
  // TODO: Send the transaction via contract.increment(encrypted.handles[0], encrypted.inputProof)
  // TODO: Wait for the transaction to be mined
}

export async function readCounter(): Promise<number> {
  // TODO: Get encrypted handle from contract.getMyCount()
  // TODO: Generate keypair with instance.generateKeypair()
  // TODO: Create EIP-712 message with instance.createEIP712()
  // TODO: Sign with signer.signTypedData()
  // TODO: Call instance.reencrypt() to get the decrypted value
  // TODO: Return the number
}
\`\`\`

---

## Task 4: React Component

Create or update \`src/App.tsx\`:

\`\`\`tsx
// src/App.tsx
import { useState, useEffect } from "react";
import { incrementCounter, readCounter } from "./counter";

function App() {
  const [counter, setCounter] = useState<number | null>(null);
  const [amount, setAmount] = useState(1);
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState("");

  // TODO: useEffect to call refreshCounter on mount

  async function refreshCounter() {
    // TODO: Call readCounter() and update state
    // TODO: Handle errors with try/catch
  }

  async function handleIncrement() {
    // TODO: Set loading state
    // TODO: Call incrementCounter(amount)
    // TODO: Refresh the counter display
    // TODO: Handle errors and reset loading state
  }

  return (
    <div style={{ padding: "2rem", fontFamily: "sans-serif" }}>
      <h1>Encrypted Counter dApp</h1>

      <div style={{ fontSize: "2rem", margin: "1rem 0" }}>
        {counter !== null ? counter : "---"}
      </div>

      <div>
        <label>Amount: </label>
        <input
          type="number"
          value={amount}
          onChange={(e) => setAmount(Number(e.target.value))}
          min={1}
          disabled={loading}
        />
      </div>

      <div style={{ marginTop: "1rem" }}>
        <button onClick={handleIncrement} disabled={loading}>
          + Increment
        </button>
        <button onClick={refreshCounter} disabled={loading}>
          Refresh
        </button>
      </div>

      {status && <p>{status}</p>}
    </div>
  );
}

export default App;
\`\`\`

---

## Step-by-Step Instructions

1. **Task 2:** Initialize the FHE instance as a singleton. Use \`createInstance()\` from the Relayer SDK (\`@zama-fhe/relayer-sdk\`).
2. **Task 3 - Encrypt:** Use \`instance.createEncryptedInput(contractAddress, userAddress)\`, call \`input.add32(amount)\`, then \`input.encrypt()\`.
3. **Task 3 - Send:** Pass the encrypted handle and proof to \`contract.increment(encrypted.handles[0], encrypted.inputProof)\`.
4. **Task 3 - Decrypt:** Use \`instance.generateKeypair()\`, \`instance.createEIP712()\`, \`signer.signTypedData()\`, and \`instance.reencrypt()\`.
5. **Task 4:** Wire up the React component with \`useState\`, \`useEffect\`, and the counter functions.

---

## Hints

<details>
<summary>Hint 1: initFhevm singleton</summary>

\`\`\`typescript
let fheInstance: any = null;

export async function initFhevm() {
  if (fheInstance) return fheInstance;
  const provider = new BrowserProvider(window.ethereum);
  fheInstance = await createInstance({
    network: await provider.send("eth_chainId", []),
    relayerUrl: "https://gateway.zama.ai",
  });
  return fheInstance;
}
\`\`\`
</details>

<details>
<summary>Hint 2: Encrypting and sending</summary>

\`\`\`typescript
const instance = await initFhevm();
const input = instance.createEncryptedInput(COUNTER_ADDRESS, userAddress);
input.add32(amount);
const encrypted = await input.encrypt();
const tx = await contract.increment(encrypted.handles[0], encrypted.inputProof);
await tx.wait();
\`\`\`
</details>

<details>
<summary>Hint 3: Decryption flow</summary>

\`\`\`typescript
const handle = await contract.getMyCount();
const instance = await initFhevm();
const { publicKey, privateKey } = instance.generateKeypair();
const eip712 = instance.createEIP712(publicKey, COUNTER_ADDRESS);
const signature = await signer.signTypedData(
  eip712.domain, eip712.types, eip712.message
);
const value = await instance.reencrypt(
  handle, privateKey, publicKey, signature,
  COUNTER_ADDRESS, userAddress
);
return Number(value);
\`\`\`
</details>

---

## Bonus Challenges

1. **Add a "Connect Wallet" button** that shows the connected address and handles disconnection.
2. **Add a transaction history** panel that shows the last 5 increment operations with timestamps.
3. **Add loading spinners** during encryption, transaction sending, and decryption phases separately.
4. **Deploy to Vercel** and test with a friend using a different wallet.

---

## Success Criteria

- [ ] FHE instance initializes successfully on page load
- [ ] Increment encrypts a value and sends it as a transaction with \`contract.increment(encrypted.handles[0], encrypted.inputProof)\`
- [ ] Counter value is decrypted via \`getMyCount()\` and displayed correctly
- [ ] Loading states prevent double-clicking during operations
- [ ] Errors are caught and displayed to the user
`,
  "11-project-erc20": `# Module 11: Exercise -- Build a Confidential ERC-20 Token

## Objective

Implement a complete confidential ERC-20 token contract with encrypted balances, privacy-preserving transfers, and encrypted allowances.

---

## Task: ConfidentialERC20

Build the contract step by step, filling in the TODO sections.

### Starter Code

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract ConfidentialERC20 is ZamaEthereumConfig {
    string public name;
    string public symbol;
    uint8 public constant decimals = 6;
    uint64 public totalSupply;

    mapping(address => euint64) private _balances;
    mapping(address => mapping(address => euint64)) private _allowances;
    mapping(address => bool) private _initialized;

    event Transfer(address indexed from, address indexed to);
    event Approval(address indexed owner, address indexed spender);

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function _initBalance(address account) internal {
        if (!_initialized[account]) {
            _balances[account] = FHE.asEuint64(0);
            FHE.allowThis(_balances[account]);
            FHE.allow(_balances[account], account);
            _initialized[account] = true;
        }
    }

    function balanceOf(address account) public view returns (euint64) {
        return _balances[account];
    }

    function transfer(externalEuint64 encryptedAmount, bytes calldata inputProof, address to) external {
        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);
        // TODO: Call _transfer(msg.sender, to, amount)
        // TODO: Emit Transfer event (no amount!)
    }

    function _transfer(address from, address to, euint64 amount) internal {
        _initBalance(from);
        _initBalance(to);

        // TODO: Check if from has enough balance using FHE.ge()
        // TODO: Use FHE.select() to get transferAmount (amount if enough, 0 if not)
        // TODO: Subtract transferAmount from from's balance
        // TODO: Add transferAmount to to's balance
        // TODO: FHE.allowThis() and FHE.allow() for both from and to
    }

    function approve(externalEuint64 encryptedAmount, bytes calldata inputProof, address spender) external {
        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);

        // TODO: Set _allowances[msg.sender][spender] = amount
        // TODO: FHE.allowThis() the allowance
        // TODO: FHE.allow() for both msg.sender and spender
        // TODO: Emit Approval event
    }

    function allowance(address owner) public view returns (euint64) {
        return _allowances[owner][msg.sender];
    }

    function transferFrom(
        address from,
        externalEuint64 encryptedAmount,
        bytes calldata inputProof,
        address to
    ) external {
        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);

        // TODO: Check allowance >= amount using FHE.ge()
        // TODO: Check balance >= amount using FHE.ge()
        // TODO: Combine both checks with FHE.and()
        // TODO: Use FHE.select() to determine transferAmount
        // TODO: Update allowance (subtract transferAmount)
        // TODO: Call _transfer(from, to, transferAmount)
        // TODO: Update ACL on the allowance
        // TODO: Emit Transfer event
    }
}
\`\`\`

---

## Step-by-Step Instructions

### Step 1: Constructor

Set the token name and symbol. The constructor does not take an initial supply -- use a separate \`mint\` function for distribution.

### Step 2: _transfer (The Core)

This is the most important function. Implement the no-revert pattern:
1. \`FHE.ge(_balances[from], amount)\` to check balance
2. \`FHE.select(hasEnough, amount, FHE.asEuint64(0))\` to get actual transfer amount
3. Subtract from sender, add to receiver
4. Update ACL for both

### Step 3: transfer

Simple wrapper that calls \`_transfer\` and emits an event.

### Step 4: approve

Set the allowance and grant ACL to both owner and spender.

### Step 5: transferFrom

Double-check pattern:
1. Check allowance with \`FHE.ge()\`
2. Check balance with \`FHE.ge()\`
3. Combine with \`FHE.and()\`
4. \`FHE.select()\` for the transfer amount
5. Update allowance and call \`_transfer\`

---

## Hints

<details>
<summary>Hint 1: Constructor</summary>

\`\`\`solidity
constructor(string memory _name, string memory _symbol) {
    name = _name;
    symbol = _symbol;
}
\`\`\`
</details>

<details>
<summary>Hint 2: _transfer (no-revert pattern)</summary>

\`\`\`solidity
function _transfer(address from, address to, euint64 amount) internal {
    _initBalance(from);
    _initBalance(to);

    ebool hasEnough = FHE.ge(_balances[from], amount);
    euint64 transferAmount = FHE.select(hasEnough, amount, FHE.asEuint64(0));

    _balances[from] = FHE.sub(_balances[from], transferAmount);
    _balances[to] = FHE.add(_balances[to], transferAmount);

    FHE.allowThis(_balances[from]);
    FHE.allow(_balances[from], from);
    FHE.allowThis(_balances[to]);
    FHE.allow(_balances[to], to);
}
\`\`\`
</details>

<details>
<summary>Hint 3: transferFrom (double check)</summary>

\`\`\`solidity
function transferFrom(address from, externalEuint64 encryptedAmount, bytes calldata inputProof, address to) external {
    euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);

    euint64 currentAllowance = _allowances[from][msg.sender];
    ebool hasAllowance = FHE.ge(currentAllowance, amount);
    ebool hasBalance = FHE.ge(_balances[from], amount);
    ebool canTransfer = FHE.and(hasAllowance, hasBalance);

    euint64 transferAmount = FHE.select(canTransfer, amount, FHE.asEuint64(0));

    _allowances[from][msg.sender] = FHE.sub(currentAllowance, transferAmount);
    FHE.allowThis(_allowances[from][msg.sender]);
    FHE.allow(_allowances[from][msg.sender], from);
    FHE.allow(_allowances[from][msg.sender], msg.sender);

    _transfer(from, to, transferAmount);
    emit Transfer(from, to);
}
\`\`\`
</details>

---

## Bonus Challenges

1. **Add a \`mint\` function** that only the contract owner can call, accepting a plaintext amount.
2. **Add a \`burn\` function** where users can burn their own tokens (encrypted amount, no-revert pattern).
3. **Add a \`transferPlaintext\` function** that accepts a regular \`uint64\` amount instead of encrypted -- useful for testing. Convert internally with \`FHE.asEuint64()\`.
4. **Write a Hardhat test** that deploys the contract, mints tokens, and verifies encrypted transfers.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] Constructor sets name and symbol
- [ ] \`transfer\` uses the no-revert pattern (FHE.select with 0)
- [ ] \`approve\` sets encrypted allowances with proper ACL
- [ ] \`transferFrom\` checks both allowance and balance
- [ ] Events do not contain amounts
- [ ] \`balanceOf(address)\` returns the account's encrypted balance handle
- [ ] All encrypted values have proper \`FHE.allowThis()\` and \`FHE.allow()\` calls
`,
  "12-project-voting": `# Module 12: Exercise -- Build a Confidential Voting System

## Objective

Implement a \`ConfidentialVoting\` contract where votes are encrypted, tallies are hidden during voting, and results are only revealed after the deadline.

---

## Task: ConfidentialVoting

### Starter Code

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, euint8, externalEuint8, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract ConfidentialVoting is ZamaEthereumConfig {
    struct Proposal {
        string description;
        euint32 yesVotes;
        euint32 noVotes;
        uint256 deadline;
        bool revealed;
        uint32 yesResult;
        uint32 noResult;
    }

    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => mapping(address => bool)) public hasVoted;
    uint256 public proposalCount;
    address public owner;

    event ProposalCreated(uint256 indexed proposalId, string description, uint256 deadline);
    event VoteCast(uint256 indexed proposalId, address indexed voter);
    event ResultRevealed(uint256 indexed proposalId, uint32 yesVotes, uint32 noVotes);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function createProposal(
        string calldata description,
        uint256 duration
    ) external onlyOwner {
        uint256 id = proposalCount++;

        // TODO: Set proposal fields (description, deadline = block.timestamp + duration, revealed = false)
        // TODO: Initialize yesVotes and noVotes to encrypted 0 using FHE.asEuint32(0)
        // TODO: FHE.allowThis() for both tallies
        // TODO: Emit ProposalCreated event with id, description, and deadline
    }

    function vote(uint256 proposalId, externalEuint8 encVote, bytes calldata inputProof) external {
        // TODO: Require proposalId < proposalCount ("Invalid proposal")
        // TODO: Require block.timestamp <= proposals[proposalId].deadline ("Voting ended")
        // TODO: Require voter has not already voted
        // TODO: Mark voter as having voted

        // TODO: Convert encVote using FHE.fromExternal(encVote, inputProof) -> euint8 voteValue
        // TODO: Compare with 1 to get ebool: ebool isYes = FHE.eq(voteValue, FHE.asEuint8(1))
        // TODO: Create euint32 oneVote = FHE.asEuint32(1) and zeroVote = FHE.asEuint32(0)
        // TODO: Use FHE.select(isYes, oneVote, zeroVote) for yes increment
        // TODO: Use FHE.select(isYes, zeroVote, oneVote) for no increment
        // TODO: Add increments to tallies using FHE.add()
        // TODO: FHE.allowThis() for both updated tallies
        // TODO: Emit VoteCast event
    }

    function getYesVotes(uint256 proposalId) external view returns (euint32) {
        return proposals[proposalId].yesVotes;
    }

    function getNoVotes(uint256 proposalId) external view returns (euint32) {
        return proposals[proposalId].noVotes;
    }

    function isVotingEnded(uint256 proposalId) external view returns (bool) {
        return block.timestamp > proposals[proposalId].deadline;
    }
}
\`\`\`

---

## Step-by-Step Instructions

### Step 1: createProposal

- Set the proposal description
- Compute the deadline: \`block.timestamp + duration\`
- Set \`revealed = false\`
- Use \`FHE.asEuint32(0)\` for both \`yesVotes\` and \`noVotes\`
- Grant \`FHE.allowThis()\` for both tallies (the contract needs access)
- Emit \`ProposalCreated\` with id, description, and deadline

### Step 2: vote

This is the core function:
1. Validate: proposalId is valid, deadline has not passed, voter has not voted
2. Mark voter as having voted
3. Convert \`externalEuint8\` with \`FHE.fromExternal(encVote, inputProof)\` to get \`euint8 voteValue\`
4. Compare against 1: \`ebool isYes = FHE.eq(voteValue, FHE.asEuint8(1))\`
5. Use \`FHE.select(isYes, oneVote, zeroVote)\` for \`yesIncrement\`
6. Use \`FHE.select(isYes, zeroVote, oneVote)\` for \`noIncrement\`
7. Add increments to tallies with \`FHE.add()\`
8. Update ACL with \`FHE.allowThis()\` for both tallies
9. Emit \`VoteCast\` event

---

## Hints

<details>
<summary>Hint 1: createProposal</summary>

\`\`\`solidity
proposals[id].description = description;
proposals[id].yesVotes = FHE.asEuint32(0);
proposals[id].noVotes = FHE.asEuint32(0);
proposals[id].deadline = block.timestamp + duration;
proposals[id].revealed = false;

FHE.allowThis(proposals[id].yesVotes);
FHE.allowThis(proposals[id].noVotes);

emit ProposalCreated(id, description, proposals[id].deadline);
\`\`\`
</details>

<details>
<summary>Hint 2: vote function</summary>

\`\`\`solidity
require(proposalId < proposalCount, "Invalid proposal");
require(block.timestamp <= proposals[proposalId].deadline, "Voting ended");
require(!hasVoted[proposalId][msg.sender], "Already voted");

euint8 voteValue = FHE.fromExternal(encVote, inputProof);
ebool isYes = FHE.eq(voteValue, FHE.asEuint8(1));

euint32 oneVote = FHE.asEuint32(1);
euint32 zeroVote = FHE.asEuint32(0);

proposals[proposalId].yesVotes = FHE.add(
    proposals[proposalId].yesVotes,
    FHE.select(isYes, oneVote, zeroVote)
);
proposals[proposalId].noVotes = FHE.add(
    proposals[proposalId].noVotes,
    FHE.select(isYes, zeroVote, oneVote)
);

FHE.allowThis(proposals[proposalId].yesVotes);
FHE.allowThis(proposals[proposalId].noVotes);

hasVoted[proposalId][msg.sender] = true;
emit VoteCast(proposalId, msg.sender);
\`\`\`
</details>

---

## Bonus Challenges

1. **Reveal function:** Add a \`revealResults(uint256 proposalId)\` function that the owner can call after the deadline. It should grant ACL access to the owner via \`FHE.allow()\`, decrypt the tallies, and store the plaintext results in \`yesResult\` and \`noResult\`. Set \`revealed = true\` and emit the \`ResultRevealed\` event.

2. **Multi-option voting:** Extend the contract to support proposals with N options (not just Yes/No). Use the same \`externalEuint8\` input as an option index and loop through options with \`FHE.eq()\` + \`FHE.select()\`.

3. **Voter eligibility:** Add a whitelist of eligible voters that the owner can manage. Only whitelisted addresses can vote.

4. **Quorum check:** After the deadline, add a function that checks if the total votes (yes + no) meet a minimum quorum threshold. Use \`FHE.ge()\` to compare the encrypted total against a plaintext threshold.

5. **Delegation:** Allow voters to delegate their vote to another address before the voting period starts.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] Proposals are created with encrypted zero tallies (\`euint32\`)
- [ ] Voters can submit encrypted votes via \`externalEuint8\` (0=no, 1=yes)
- [ ] \`FHE.eq(voteValue, FHE.asEuint8(1))\` correctly converts vote to \`ebool\`
- [ ] Duplicate voting is prevented
- [ ] Deadline-based check enforces the voting window
- [ ] \`FHE.select()\` updates both tallies on every vote
- [ ] Tallies cannot be decrypted (only contract has ACL via \`allowThis\`)
- [ ] All encrypted values have proper ACL calls
- [ ] Frontend uses \`input.add8(1)\` (not \`input.addBool(true)\`)
`,
  "13-project-auction": `# Module 13: Exercise -- Build a Sealed-Bid Auction

## Objective

Implement a \`SealedBidAuction\` contract where bids are encrypted, the highest bid is tracked using FHE comparisons, and the winner is only revealed after the auction ends via \`FHE.makePubliclyDecryptable()\`.

---

## Task: SealedBidAuction

### Starter Code

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, externalEuint64, ebool, eaddress} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract SealedBidAuction is ZamaEthereumConfig {
    struct Auction {
        string item;
        uint256 deadline;
        uint64 reservePrice;
        bool ended;
        bool finalized;
        address[] bidders;
    }

    mapping(uint256 => Auction) public auctions;
    mapping(uint256 => mapping(address => euint64)) internal _bids;
    mapping(uint256 => mapping(address => bool)) public hasBid;
    mapping(uint256 => mapping(address => uint256)) public deposits;
    mapping(uint256 => euint64) internal _highestBid;
    mapping(uint256 => eaddress) internal _highestBidder;

    mapping(uint256 => address) public winner;
    mapping(uint256 => uint64) public winningBidAmount;

    uint256 public auctionCount;
    address public owner;

    event AuctionCreated(uint256 indexed auctionId, string item, uint256 deadline, uint64 reservePrice);
    event BidPlaced(uint256 indexed auctionId, address indexed bidder);
    event AuctionEnded(uint256 indexed auctionId);
    event DepositWithdrawn(uint256 indexed auctionId, address indexed bidder, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function createAuction(
        string calldata item,
        uint256 duration,
        uint64 reservePrice
    ) external onlyOwner {
        uint256 id = auctionCount++;
        auctions[id].item = item;
        auctions[id].deadline = block.timestamp + duration;
        auctions[id].reservePrice = reservePrice;
        auctions[id].ended = false;
        auctions[id].finalized = false;

        // TODO: Initialize _highestBid[id] to encrypted 0
        // TODO: Initialize _highestBidder[id] to encrypted address(0)
        // TODO: FHE.allowThis() for both

        // TODO: Emit AuctionCreated event
    }

    function bid(uint256 auctionId, externalEuint64 encBid, bytes calldata inputProof) external payable {
        // TODO: Require auctionId is valid (< auctionCount)
        // TODO: Require auction deadline has not passed
        // TODO: Require auction has not ended
        // TODO: Require sender has not already bid (hasBid mapping)
        // TODO: Require msg.value > 0 (ETH deposit)

        // TODO: Convert encBid with FHE.fromExternal(encBid, inputProof) -- 2 params
        // TODO: Store bid in _bids mapping with ACL (allowThis + allow for sender)
        // TODO: Store deposit amount in deposits mapping

        // TODO: Compare bid against _highestBid[auctionId] using FHE.gt()
        // TODO: Update _highestBid[auctionId] with FHE.select()
        // TODO: FHE.allowThis() for _highestBid[auctionId]

        // TODO: Update _highestBidder[auctionId] with FHE.select() and FHE.asEaddress(msg.sender)
        // TODO: FHE.allowThis() for _highestBidder[auctionId]

        // TODO: Mark hasBid and push to bidders array
        // TODO: Emit BidPlaced event
    }

    function endAuction(uint256 auctionId) external onlyOwner {
        // TODO: Require auctionId is valid
        // TODO: Require deadline has passed (block.timestamp > deadline)
        // TODO: Require auction has not already ended
        // TODO: Set ended to true

        // TODO: Call FHE.makePubliclyDecryptable() on _highestBid[auctionId]
        // TODO: Call FHE.makePubliclyDecryptable() on _highestBidder[auctionId]

        // TODO: Emit AuctionEnded event
    }

    function withdrawDeposit(uint256 auctionId) external {
        // TODO: Require auction has ended
        // TODO: Require sender is not the winner
        // TODO: Get deposit amount and require > 0
        // TODO: Set deposit to 0 (re-entrancy protection)
        // TODO: Transfer ETH back to sender
        // TODO: Emit DepositWithdrawn event
    }

    function getHighestBid(uint256 auctionId) external view returns (euint64) {
        return _highestBid[auctionId];
    }

    function getMyBid(uint256 auctionId) external view returns (euint64) {
        return _bids[auctionId][msg.sender];
    }

    function getBidderCount(uint256 auctionId) external view returns (uint256) {
        return auctions[auctionId].bidders.length;
    }

    function getHighestBidder(uint256 auctionId) external view returns (eaddress) {
        return _highestBidder[auctionId];
    }
}
\`\`\`

---

## Step-by-Step Instructions

### Step 1: createAuction

Initialize the encrypted highest bid and bidder for the new auction:
- \`_highestBid[id] = FHE.asEuint64(0)\`
- \`_highestBidder[id] = FHE.asEaddress(address(0))\`
- Grant \`FHE.allowThis()\` for both
- Emit \`AuctionCreated\` with the auction id, item, deadline, and reservePrice

### Step 2: bid Function

This is the core function:
1. Validate auction id, deadline, duplicate bids, and ETH deposit
2. Convert encrypted input: \`FHE.fromExternal(encBid, inputProof)\` (2 parameters)
3. Store the bid with ACL and record the deposit
4. Compare with \`FHE.gt(newBid, _highestBid[auctionId])\`
5. Update \`_highestBid\` with \`FHE.select()\`
6. Update \`_highestBidder\` with \`FHE.select(isHigher, FHE.asEaddress(msg.sender), _highestBidder[auctionId])\`
7. Update ACL with \`FHE.allowThis()\` for both

### Step 3: endAuction

- Verify the auction deadline has passed
- Mark auction as ended
- Call \`FHE.makePubliclyDecryptable()\` on both \`_highestBid\` and \`_highestBidder\` (no Gateway needed)

### Step 4: withdrawDeposit

- Only after auction has ended
- Only for non-winners
- Transfer ETH back using \`payable(msg.sender).transfer()\`
- Zero out the deposit before transferring (re-entrancy protection)

---

## Hints

<details>
<summary>Hint 1: createAuction initialization</summary>

\`\`\`solidity
_highestBid[id] = FHE.asEuint64(0);
FHE.allowThis(_highestBid[id]);

_highestBidder[id] = FHE.asEaddress(address(0));
FHE.allowThis(_highestBidder[id]);

emit AuctionCreated(id, item, auctions[id].deadline, reservePrice);
\`\`\`
</details>

<details>
<summary>Hint 2: bid function</summary>

\`\`\`solidity
function bid(uint256 auctionId, externalEuint64 encBid, bytes calldata inputProof) external payable {
    require(auctionId < auctionCount, "Invalid auction");
    require(block.timestamp <= auctions[auctionId].deadline, "Bidding ended");
    require(!auctions[auctionId].ended, "Auction ended");
    require(!hasBid[auctionId][msg.sender], "Already bid");
    require(msg.value > 0, "Must deposit ETH");

    euint64 newBid = FHE.fromExternal(encBid, inputProof);

    _bids[auctionId][msg.sender] = newBid;
    FHE.allowThis(_bids[auctionId][msg.sender]);
    FHE.allow(_bids[auctionId][msg.sender], msg.sender);

    deposits[auctionId][msg.sender] = msg.value;

    ebool isHigher = FHE.gt(newBid, _highestBid[auctionId]);
    _highestBid[auctionId] = FHE.select(isHigher, newBid, _highestBid[auctionId]);
    FHE.allowThis(_highestBid[auctionId]);

    _highestBidder[auctionId] = FHE.select(
        isHigher,
        FHE.asEaddress(msg.sender),
        _highestBidder[auctionId]
    );
    FHE.allowThis(_highestBidder[auctionId]);

    hasBid[auctionId][msg.sender] = true;
    auctions[auctionId].bidders.push(msg.sender);

    emit BidPlaced(auctionId, msg.sender);
}
\`\`\`
</details>

<details>
<summary>Hint 3: endAuction function</summary>

\`\`\`solidity
function endAuction(uint256 auctionId) external onlyOwner {
    require(auctionId < auctionCount, "Invalid auction");
    require(block.timestamp > auctions[auctionId].deadline, "Not yet ended");
    require(!auctions[auctionId].ended, "Already ended");

    auctions[auctionId].ended = true;

    FHE.makePubliclyDecryptable(_highestBid[auctionId]);
    FHE.makePubliclyDecryptable(_highestBidder[auctionId]);

    emit AuctionEnded(auctionId);
}
\`\`\`
</details>

<details>
<summary>Hint 4: withdrawDeposit function</summary>

\`\`\`solidity
function withdrawDeposit(uint256 auctionId) external {
    require(auctions[auctionId].ended, "Auction not ended");
    require(msg.sender != winner[auctionId], "Winner cannot withdraw");
    uint256 amount = deposits[auctionId][msg.sender];
    require(amount > 0, "No deposit");

    deposits[auctionId][msg.sender] = 0;
    payable(msg.sender).transfer(amount);
    emit DepositWithdrawn(auctionId, msg.sender, amount);
}
\`\`\`
</details>

---

## Bonus Challenges

1. **Fixed deposit amount:** Modify the contract so all bidders must deposit exactly the same amount (e.g., 1 ETH). This prevents deposit amounts from leaking bid ranges.

2. **Bid update:** Allow bidders to update their bid (but only increase, never decrease). Track the bid update count to limit updates.

3. **Second-price auction (Vickrey):** Track both the highest and second-highest bids. The winner pays the second-highest price. Requires tracking two encrypted values.

4. **Multi-item auction:** Allow the auction to sell N items to the N highest bidders. Track the top N bids using an encrypted sorting approach.

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] \`createAuction()\` initializes encrypted highest bid and bidder with \`FHE.asEuint64(0)\` and \`FHE.asEaddress(address(0))\`
- [ ] \`bid()\` uses \`FHE.fromExternal(encBid, inputProof)\` with 2 parameters
- [ ] Bids are compared with \`FHE.gt()\` and updated with \`FHE.select()\`
- [ ] Highest bidder uses \`FHE.select(isHigher, FHE.asEaddress(msg.sender), _highestBidder[auctionId])\`
- [ ] One bid per address per auction is enforced
- [ ] ETH deposit is required with each bid
- [ ] \`endAuction()\` calls \`FHE.makePubliclyDecryptable()\` on both highest bid and bidder
- [ ] Losers can withdraw deposits after auction ends via \`withdrawDeposit(auctionId)\`
- [ ] Winner cannot withdraw their deposit
`,
  "14-testing-debugging": `# Module 14: Exercise -- Write a Test Suite for ConfidentialERC20

## Objective

Write a comprehensive test suite for the \`ConfidentialERC20\` contract from Module 11. The contract is already deployed and working -- your job is to verify every aspect of its behavior using the testing patterns from this module.

This exercise reinforces:
- The encrypt-act-decrypt-assert pattern
- Multi-user testing with multiple signers
- Silent failure verification (no reverts on encrypted conditions)
- Event verification
- ACL boundary testing
- Edge case coverage

---

## The Contract Under Test

You are testing the existing \`ConfidentialERC20.sol\` contract, which has:

| Function | Description |
|----------|-------------|
| \`constructor(name, symbol)\` | Sets token name, symbol, decimals (6), and owner |
| \`mint(address to, uint64 amount)\` | Owner mints plaintext amount to address (updates encrypted balance) |
| \`transfer(encAmount, inputProof, to)\` | Transfer encrypted amount (silent failure on insufficient balance) |
| \`approve(encAmount, inputProof, spender)\` | Approve spender for encrypted allowance |
| \`transferFrom(from, encAmount, inputProof, to)\` | Transfer with allowance check (silent failure on insufficient allowance) |
| \`balanceOf(address)\` | Returns encrypted balance handle |
| \`allowance(owner, spender)\` | Returns encrypted allowance handle |
| \`name()\`, \`symbol()\`, \`decimals()\`, \`totalSupply()\`, \`owner()\` | Public metadata |

---

## Task

Complete the test file skeleton at \`exercises/14-testing-exercise.ts\`. Each \`TODO\` block describes a specific test you need to implement.

### Required Tests (12 tests minimum)

**Deployment (2 tests)**
1. Should deploy with correct name, symbol, and decimals
2. Should set the deployer as owner with totalSupply 0

**Minting (2 tests)**
3. Should mint tokens and verify encrypted balance
4. Should reject mint from non-owner

**Transfers (3 tests)**
5. Should transfer tokens between users (sender balance decreases, receiver balance increases)
6. Should silently transfer 0 on insufficient balance (sender balance unchanged)
7. Should handle transfer to self (balance unchanged)

**Allowances (3 tests)**
8. Should approve and verify encrypted allowance
9. Should transferFrom within allowance
10. Should silently transfer 0 on insufficient allowance

**Edge Cases (2 tests)**
11. Should handle multiple sequential transfers correctly
12. Should maintain correct totalSupply after multiple mints

---

## Step-by-Step Instructions

### Step 1: Setup

The \`beforeEach\` block is already provided. It:
1. Gets three signers: \`owner\`, \`alice\`, \`bob\`
2. Deploys a fresh \`ConfidentialERC20\` with name "TestToken" and symbol "TT"
3. Waits for deployment and stores the contract address

### Step 2: Deployment Tests

Test that the constructor set the correct values. These are plaintext reads -- no encryption needed:

\`\`\`typescript
expect(await token.name()).to.equal("TestToken");
expect(await token.decimals()).to.equal(6n);
\`\`\`

### Step 3: Mint Tests

The \`mint()\` function takes a plaintext amount and an address. After minting, verify:
- The \`totalSupply\` increased
- The recipient's encrypted balance matches the minted amount (requires decrypt)

For the non-owner test, use try/catch and check for "Not the owner" in the error.

### Step 4: Transfer Tests

For each transfer test:
1. Mint tokens to the sender first
2. Create an encrypted input for the transfer amount
3. Call \`transfer(enc.handles[0], enc.inputProof, recipientAddress)\`
4. Decrypt both sender and receiver balances
5. Verify the expected values

For the silent failure test: transfer more than the balance, then verify the sender's balance is unchanged.

### Step 5: Allowance Tests

1. Mint tokens to Alice
2. Alice calls \`approve(enc.handles[0], enc.inputProof, bob.address)\`
3. Verify allowance by decrypting \`token.allowance(alice.address, bob.address)\`
4. Bob calls \`transferFrom(alice.address, enc.handles[0], enc.inputProof, bob.address)\`
5. Verify balances after transfer

### Step 6: Edge Cases

- **Transfer to self:** Alice transfers to Alice -- balance should stay the same
- **Sequential transfers:** Alice -> Bob, Bob -> Alice, verify final balances
- **Multiple mints:** Mint to Alice twice, verify totalSupply is the sum

---

## Hints

<details>
<summary>Hint 1: Encrypting a transfer amount</summary>

\`\`\`typescript
const enc = await fhevm
  .createEncryptedInput(tokenAddress, alice.address)
  .add64(300)
  .encrypt();
await (await token.connect(alice).transfer(
  enc.handles[0], enc.inputProof, bob.address
)).wait();
\`\`\`

Remember: the signer in \`createEncryptedInput\` must match \`.connect()\`.
</details>

<details>
<summary>Hint 2: Decrypting a balance</summary>

\`\`\`typescript
const handle = await token.balanceOf(alice.address);
const clear = await fhevm.userDecryptEuint(
  FhevmType.euint64, handle, tokenAddress, alice
);
expect(clear).to.equal(700n);
\`\`\`

Note: use \`tokenAddress\` (not \`contractAddress\`) -- the variable name from the test setup.
</details>

<details>
<summary>Hint 3: Testing silent failure on transfer</summary>

\`\`\`typescript
// Alice has 100, tries to send 200
const enc = await fhevm
  .createEncryptedInput(tokenAddress, alice.address)
  .add64(200)
  .encrypt();
await (await token.connect(alice).transfer(
  enc.handles[0], enc.inputProof, bob.address
)).wait();

// Balance should be UNCHANGED (100, not -100, not 0)
const handle = await token.balanceOf(alice.address);
const clear = await fhevm.userDecryptEuint(
  FhevmType.euint64, handle, tokenAddress, alice
);
expect(clear).to.equal(100n);
\`\`\`
</details>

<details>
<summary>Hint 4: Testing approve + transferFrom</summary>

\`\`\`typescript
// 1. Mint to Alice
await (await token.mint(alice.address, 1000)).wait();

// 2. Alice approves Bob for 500
const encApproval = await fhevm
  .createEncryptedInput(tokenAddress, alice.address)
  .add64(500)
  .encrypt();
await (await token.connect(alice).approve(
  encApproval.handles[0], encApproval.inputProof, bob.address
)).wait();

// 3. Bob transfers 300 from Alice
const encTransfer = await fhevm
  .createEncryptedInput(tokenAddress, bob.address)
  .add64(300)
  .encrypt();
await (await token.connect(bob).transferFrom(
  alice.address, encTransfer.handles[0], encTransfer.inputProof, bob.address
)).wait();

// 4. Verify balances
// Alice: 1000 - 300 = 700
// Bob: 0 + 300 = 300
\`\`\`
</details>

---

## Starter File

The exercise template is at: \`exercises/14-testing-exercise.ts\`

The complete solution is at: \`solutions/14-testing-solution.ts\`

---

## Success Criteria

- [ ] All 12+ tests pass when run with \`npx hardhat test exercises/14-testing-exercise.ts\`
- [ ] Deployment tests verify name, symbol, decimals, owner, and totalSupply
- [ ] Mint test uses decrypt to verify encrypted balance (not just totalSupply)
- [ ] Transfer test verifies both sender and receiver balances after transfer
- [ ] Silent failure test verifies balance is unchanged after overdraft transfer
- [ ] Allowance test includes both approve and transferFrom steps
- [ ] Non-owner mint test uses try/catch (not revertedWith)
- [ ] All BigInt assertions use the \`n\` suffix (\`1000n\`, not \`1000\`)
- [ ] All encrypted inputs match the signer in \`.connect()\`

---

## Bonus Challenges

1. **Event coverage:** Add a test that verifies the \`Transfer\`, \`Approval\`, and \`Mint\` events are emitted with correct indexed parameters.

2. **Allowance exhaustion:** Approve Bob for 500, have Bob transfer 300, then verify the remaining allowance is 200 by decrypting the allowance handle.

3. **Multi-user stress test:** Create a scenario with 3+ users performing interleaved mints, transfers, and approvals, then verify all final balances.

4. **ACL boundary test:** After Alice mints tokens, verify that Bob cannot decrypt Alice's balance by attempting \`userDecryptEuint\` as Bob and catching the error.
`,
  "15-gas-optimization": `# Module 15: Exercise -- Optimize the Inefficient Token

## Objective

You are given a deliberately inefficient confidential token contract (\`exercises/15-gas-exercise.sol\`). Your task is to apply the gas optimization patterns from this module to reduce gas consumption by **at least 30%**.

---

## The Problem

The contract \`InefficientToken\` is a working confidential ERC-20-like token with the following features:

- Minting (owner only)
- Transferring tokens between accounts
- Checking if a balance exceeds a threshold

It works correctly, but it wastes enormous amounts of gas through poor FHE patterns:

1. It uses \`euint64\` for balances that never exceed 1,000,000
2. It encrypts plaintext constants before every operation
3. It recomputes a fee rate from components on every transfer
4. It uses redundant comparisons where \`FHE.max\` / \`FHE.min\` would suffice
5. It performs the same comparison twice in one function

---

## Your Task

1. Copy \`exercises/15-gas-exercise.sol\` to \`contracts/OptimizedToken.sol\`
2. Rename the contract to \`OptimizedToken\`
3. Apply optimization patterns to reduce gas usage by at least 30%
4. Write tests that:
   - Verify the optimized contract produces the same results as the original
   - Measure and log gas usage for \`mint\`, \`transfer\`, and \`checkThreshold\`
   - Assert that total gas for a standard workflow (mint + transfer + check) is at least 30% less

---

## Optimization Targets

| Function | Inefficient Patterns | Optimization Hints |
|----------|---------------------|-------------------|
| \`mint()\` | Uses euint64 for small values; encrypts constant 0 | Downsize to euint32; use plaintext 0 |
| \`transfer()\` | Encrypts amount; encrypts fee components each call; double comparison | Use plaintext operands; cache fee rate; eliminate redundant check |
| \`checkThreshold()\` | Uses gt + select instead of max | Replace with FHE.max or simplify |

---

## Starter Test

\`\`\`typescript
import { expect } from "chai";
import { ethers, fhevm } from "hardhat";
import { FhevmType } from "@fhevm/hardhat-plugin";

describe("OptimizedToken", function () {
  let contract: any;
  let contractAddress: string;
  let deployer: any;
  let recipient: any;

  beforeEach(async function () {
    [deployer, recipient] = await ethers.getSigners();
    const Factory = await ethers.getContractFactory("OptimizedToken");
    contract = await Factory.deploy();
    await contract.waitForDeployment();
    contractAddress = await contract.getAddress();
  });

  it("should mint tokens with less gas than the inefficient version", async function () {
    const tx = await contract.mint(deployer.address, 1000);
    const receipt = await tx.wait();
    console.log(\`  OptimizedToken.mint gas: \${receipt.gasUsed}\`);
    // TODO: Compare with InefficientToken gas and assert 30%+ savings
  });

  it("should transfer tokens correctly", async function () {
    await (await contract.mint(deployer.address, 1000)).wait();
    const tx = await contract.transfer(recipient.address, 100);
    const receipt = await tx.wait();
    console.log(\`  OptimizedToken.transfer gas: \${receipt.gasUsed}\`);

    // Verify balances
    // TODO: decrypt and check sender has 900, recipient has 100
  });

  it("should check threshold correctly", async function () {
    await (await contract.mint(deployer.address, 1000)).wait();
    const tx = await contract.checkThreshold(500);
    const receipt = await tx.wait();
    console.log(\`  OptimizedToken.checkThreshold gas: \${receipt.gasUsed}\`);
  });
});
\`\`\`

---

## Success Criteria

- [ ] The optimized contract compiles and passes all functional tests
- [ ] \`mint()\` gas is at least 30% lower than the inefficient version
- [ ] \`transfer()\` gas is at least 30% lower than the inefficient version
- [ ] \`checkThreshold()\` gas is at least 20% lower than the inefficient version
- [ ] All three functions produce the same logical results as the original

---

## Hints

1. Read the lesson section on **plaintext operands** -- the transfer function encrypts the amount before every operation.
2. Read the lesson section on **caching** -- the fee rate is constant but recomputed every call.
3. Read the lesson section on **type sizing** -- the balance cap is 1,000,000 which fits in \`euint32\`.
4. Read the lesson section on **minimizing operations** -- \`checkThreshold\` uses a comparison + select where a single built-in would suffice.

---

## Reference Solution

See \`solutions/15-gas-solution.sol\` after you have completed your attempt.
`,
  "16-security": `# Module 16: Exercise -- Security Audit Challenge

## Objective

You are given a deliberately vulnerable FHE contract (\`exercises/16-security-exercise.sol\`). Your task is to identify **all** security vulnerabilities and produce a fixed version (\`solutions/16-security-solution.sol\`).

This exercise simulates a real-world security audit of an FHE smart contract.

---

## The Contract Under Audit

Open \`exercises/16-security-exercise.sol\`. This is a simplified "Encrypted Vault" contract that allows users to deposit, withdraw, and transfer encrypted token balances. It contains **7 distinct FHE-specific vulnerabilities**.

---

## Instructions

### Step 1: Read the Contract

Read through the entire contract carefully. For each function, ask yourself:

1. Is the ACL correctly set after every FHE state update?
2. Are encrypted inputs validated?
3. Is there any branching on encrypted conditions?
4. Could this function be used for DoS?
5. Does error handling leak information about encrypted state?
6. Is access control properly enforced?
7. Is \`makePubliclyDecryptable\` used appropriately?

### Step 2: Document Each Vulnerability

For each vulnerability you find, write down:

- **Location:** Function name and line
- **Category:** Which of the 7 vulnerability types (gas leak, missing ACL, unvalidated input, DoS, error leak, privacy violation, missing access control)
- **Impact:** What an attacker could learn or do
- **Fix:** The specific code change needed

### Step 3: Write the Fixed Contract

Create your fixed version as \`solutions/16-security-solution.sol\` (a reference solution is provided for comparison). Your fixed contract should:

1. Compile without errors
2. Fix every vulnerability you identified
3. Maintain the same external interface (function signatures)
4. Add any missing patterns (LastError, rate limiting, etc.)

---

## Vulnerability Checklist

Use this checklist to verify you have found all 7 vulnerabilities:

- [ ] **Vulnerability 1:** Missing ACL permissions after encrypted state update
- [ ] **Vulnerability 2:** Gas side channel from branching on encrypted condition
- [ ] **Vulnerability 3:** Missing input validation (no \`FHE.isInitialized()\` check)
- [ ] **Vulnerability 4:** Unbounded loop with FHE operations (DoS vector)
- [ ] **Vulnerability 5:** Information leak via revert on encrypted condition
- [ ] **Vulnerability 6:** Improper use of \`makePubliclyDecryptable\` on user data
- [ ] **Vulnerability 7:** Missing access control on sensitive function

---

## Hints

<details>
<summary>Hint 1: Where to look for missing ACL</summary>

Check the \`deposit()\` function. After \`FHE.add()\`, is \`FHE.allowThis()\` called? Is \`FHE.allow()\` called for the user?
</details>

<details>
<summary>Hint 2: Where is the gas leak?</summary>

Look for any \`if/else\` statement that depends on an encrypted comparison result. The \`withdraw()\` function is a good place to start.
</details>

<details>
<summary>Hint 3: Where is the DoS vector?</summary>

Look for loops that iterate over user-supplied arrays with FHE operations inside. Is there a maximum size?
</details>

<details>
<summary>Hint 4: Which function leaks info via reverts?</summary>

Any function that calls \`require()\` on a condition derived from encrypted values. Look for patterns like "check encrypted balance, then revert if insufficient."
</details>

<details>
<summary>Hint 5: Which function exposes private data?</summary>

Search for \`FHE.makePubliclyDecryptable()\`. Is it being called on individual user data or aggregate data?
</details>

---

## Evaluation Criteria

| Criterion | Points |
|-----------|--------|
| All 7 vulnerabilities identified | 35 (5 each) |
| Correct fix for each vulnerability | 35 (5 each) |
| Fixed contract compiles | 10 |
| Fixed contract maintains same interface | 10 |
| Added LastError pattern for encrypted errors | 5 |
| Added rate limiting for DoS prevention | 5 |
| **Total** | **100** |

---

## Bonus Challenges

1. **Write tests** for your fixed contract that verify each fix works correctly. For example, test that a failed transfer sets the LastError code to \`ERR_INSUFFICIENT_BALANCE\` instead of reverting.

2. **Add overflow protection** to the deposit function using the \`FHE.select()\` pattern (check if \`newBalance < oldBalance\`).

3. **Implement commit-reveal** for the transfer function to mitigate front-running on the recipient address.

---

## Reference Files

- **Vulnerable contract:** \`exercises/16-security-exercise.sol\`
- **Reference solution:** \`solutions/16-security-solution.sol\`
- **Patterns reference:** \`contracts/SecurityPatterns.sol\`
- **Vulnerability examples:** \`contracts/VulnerableDemo.sol\`

---

## Success Criteria

- [ ] Identified all 7 FHE-specific vulnerabilities
- [ ] Produced a fixed contract that compiles
- [ ] Each fix addresses the root cause (not just a workaround)
- [ ] Fixed contract uses \`FHE.select()\` instead of branching
- [ ] Fixed contract has proper ACL on all encrypted state updates
- [ ] Fixed contract validates all encrypted inputs
- [ ] Fixed contract has bounded FHE loops
- [ ] Fixed contract uses LastError pattern instead of reverting on encrypted conditions
`,
  "17-advanced-patterns": `# Module 17: Exercise -- Build an Encrypted Escrow

## Objective

Combine three patterns from this module -- **Encrypted State Machine**, **LastError**, and **Time-Locked Values** -- into a working Encrypted Escrow contract. The escrow holds encrypted payment amounts, transitions through states based on encrypted conditions, provides encrypted error feedback, and enforces time-based deadlines.

---

## Overview

An escrow is a financial arrangement where a third party holds funds on behalf of two parties until predefined conditions are met. In our encrypted escrow:

- **Depositor** creates an escrow with an encrypted payment amount and a deadline
- **Arbiter** (trusted third party) can release funds to the beneficiary or refund the depositor
- Encrypted conditions determine whether release is allowed
- If the deadline passes without release, the depositor can reclaim funds
- All operations provide encrypted error feedback via the LastError pattern

---

## States

\`\`\`
CREATED  -->  FUNDED  -->  RELEASED
                |
                +-------->  DISPUTED  -->  RESOLVED
                |
                +-------->  EXPIRED (after deadline)
\`\`\`

---

## Starter Code

The starter contract is available at \`exercises/17-patterns-exercise.sol\`. It contains the struct definitions, state variables, events, and function signatures with TODO comments. Your job is to implement each function body.

---

## Task 1: Fund the Escrow

Implement \`fundEscrow()\`:
- Accept an encrypted amount via \`externalEuint64\` and \`bytes calldata inputProof\`
- Only the depositor can fund
- Only callable in CREATED state
- Store the encrypted amount
- Transition state to FUNDED
- Set ACL on the stored amount

---

## Task 2: Release Funds

Implement \`releaseFunds()\`:
- Only the arbiter can release
- Only callable in FUNDED state
- Must be before the deadline (\`block.timestamp < deadline\`)
- Compare encrypted escrow amount to an encrypted minimum (set at creation)
- Use \`FHE.ge()\` to check if \`amount >= minimumAmount\`
- Use \`FHE.select()\` to determine actual release: full amount if condition met, 0 if not
- Set LastError: 0 = SUCCESS, 1 = BELOW_MINIMUM
- Transition state to RELEASED on success
- Make the released amount publicly decryptable

---

## Task 3: Dispute

Implement \`dispute()\`:
- Either depositor or beneficiary can dispute
- Only callable in FUNDED state
- Must be before the deadline
- Transition state to DISPUTED

---

## Task 4: Resolve Dispute

Implement \`resolveDispute()\`:
- Only the arbiter can resolve
- Only callable in DISPUTED state
- Takes an \`externalEuint64\` representing the amount to send to the beneficiary
- The remainder goes back to the depositor
- Set LastError: 0 = SUCCESS, 2 = RESOLUTION_EXCEEDS_ESCROW
- Use \`FHE.le()\` to verify resolution amount does not exceed escrow amount
- Make both amounts publicly decryptable
- Transition state to RESOLVED

---

## Task 5: Claim Expired Funds

Implement \`claimExpired()\`:
- Only the depositor can claim
- Only callable in FUNDED state
- Must be after the deadline (\`block.timestamp >= deadline\`)
- Transition state to EXPIRED
- Make the refund amount publicly decryptable

---

## Task 6: Error Retrieval

Implement \`getLastError()\` and \`clearError()\` following the LastError pattern from the lesson.

---

## Hints

<details>
<summary>Hint 1: Release with encrypted condition check</summary>

\`\`\`solidity
ebool meetsMinimum = FHE.ge(_escrowAmount, _minimumAmount);
euint64 releaseAmount = FHE.select(meetsMinimum, _escrowAmount, FHE.asEuint64(0));

// Set error code
euint8 errorCode = FHE.select(meetsMinimum, FHE.asEuint8(0), FHE.asEuint8(1));
_lastError[msg.sender] = errorCode;
FHE.allowThis(_lastError[msg.sender]);
FHE.allow(_lastError[msg.sender], msg.sender);

// Only transition if successful
// Note: state transitions must be based on public data in practice.
// For this exercise, the arbiter submits the decrypted result after reveal.
\`\`\`
</details>

<details>
<summary>Hint 2: Resolve dispute with encrypted split</summary>

\`\`\`solidity
euint64 resolution = FHE.fromExternal(encResolution, inputProof);

// Check resolution <= escrow amount
ebool isValid = FHE.le(resolution, _escrowAmount);
euint64 toBeneficiary = FHE.select(isValid, resolution, FHE.asEuint64(0));
euint64 toDepositor = FHE.select(isValid, FHE.sub(_escrowAmount, resolution), _escrowAmount);
\`\`\`
</details>

<details>
<summary>Hint 3: Time-locked expiration</summary>

\`\`\`solidity
function claimExpired() external {
    require(msg.sender == depositor, "Not depositor");
    require(currentState == State.FUNDED, "Not funded");
    require(block.timestamp >= deadline, "Not expired yet");

    currentState = State.EXPIRED;
    FHE.makePubliclyDecryptable(_escrowAmount);
}
\`\`\`
</details>

---

## Testing Your Implementation

Write tests that verify:

1. **Happy path:** Create escrow, fund it, release to beneficiary
2. **Below minimum:** Release fails when escrow amount is below the minimum, error code = 1
3. **Dispute and resolve:** Fund, dispute, resolve with a split
4. **Expiration:** Fund, wait past deadline, depositor claims
5. **Error retrieval:** Verify encrypted error codes can be decrypted
6. **Access control:** Only depositor can fund, only arbiter can release/resolve

---

## Bonus Challenges

1. **Multi-party escrow:** Support multiple depositors contributing to the same escrow, with encrypted individual contributions tracked separately.

2. **Partial release:** Allow the arbiter to release a partial encrypted amount, keeping the remainder in escrow for future release.

3. **Encrypted arbiter fee:** The arbiter takes an encrypted percentage of the escrow as a fee. Use \`FHE.mul()\` and \`FHE.div()\` to compute it.

4. **Appeal mechanism:** After dispute resolution, allow either party to appeal within a time window, re-entering the DISPUTED state.

---

## Success Criteria

- [ ] Contract compiles with \`pragma solidity ^0.8.24\`
- [ ] All six states are reachable through valid transitions
- [ ] Encrypted amounts are properly stored with \`FHE.allowThis()\` and \`FHE.allow()\`
- [ ] Release checks encrypted condition using \`FHE.ge()\` and \`FHE.select()\`
- [ ] LastError pattern stores encrypted error codes per user
- [ ] Time-lock enforces deadline with \`block.timestamp\`
- [ ] \`makePubliclyDecryptable()\` is called on revealed amounts
- [ ] Events emitted at each state transition
- [ ] Access control enforced (depositor, beneficiary, arbiter roles)
- [ ] Tests cover happy path, error cases, and time-based expiration
`,
  "18-confidential-defi": `# Module 18: Exercise -- Build a Confidential Swap

## Objective

Implement a \`ConfidentialSwap\` contract that allows users to exchange encrypted amounts of two tokens (Token A and Token B) at a fixed exchange rate enforced via FHE. Users deposit encrypted balances and swap between tokens without revealing their amounts.

---

## Task: ConfidentialSwap

### Background

A swap contract is one of the most fundamental DeFi primitives. In a confidential swap:
- Users deposit Token A and Token B balances (encrypted)
- Users can swap Token A for Token B (or vice versa) at a fixed rate
- The exchange rate is public (e.g., 1 Token A = 2 Token B)
- The swap amounts are encrypted -- no one knows how much you swapped
- Insufficient balance handling uses the LastError pattern (no revert)

### Starter Code

The starter code is available at \`exercises/18-defi-exercise.sol\`.

---

## Step-by-Step Instructions

### Step 1: depositTokenA and depositTokenB

Accept encrypted deposits for each token:
- Use \`FHE.fromExternal(encAmount, inputProof)\` to convert the input
- Add the amount to the user's existing balance with \`FHE.add()\`
- Update ACL with \`FHE.allowThis()\` and \`FHE.allow()\`
- Emit a \`Deposited\` event

### Step 2: swapAtoB

Swap Token A for Token B at the fixed rate (1 A = 2 B):
- Convert the encrypted input amount
- Calculate the Token B output: \`outputB = FHE.mul(amountA, FHE.asEuint64(RATE))\`
- Check that the user has enough Token A: \`FHE.ge(balanceA, amountA)\`
- Use \`FHE.select()\` to conditionally update both balances:
  - If sufficient: \`balanceA -= amountA\`, \`balanceB += outputB\`
  - If insufficient: balances unchanged (LastError pattern)
- Update ACL for all new handles

### Step 3: swapBtoA

Swap Token B for Token A (reverse direction):
- Calculate the Token A output: \`outputA = FHE.div(amountB, RATE)\`
- Check sufficient Token B balance
- Conditionally update both balances with \`FHE.select()\`

### Step 4: View Functions

Implement \`getBalanceA()\` and \`getBalanceB()\` that return the encrypted balance handles for the caller.

---

## Hints

<details>
<summary>Hint 1: Initialization pattern</summary>

\`\`\`solidity
function _initUser(address user) internal {
    if (!_initialized[user]) {
        _balanceA[user] = FHE.asEuint64(0);
        FHE.allowThis(_balanceA[user]);
        FHE.allow(_balanceA[user], user);

        _balanceB[user] = FHE.asEuint64(0);
        FHE.allowThis(_balanceB[user]);
        FHE.allow(_balanceB[user], user);

        _initialized[user] = true;
    }
}
\`\`\`
</details>

<details>
<summary>Hint 2: swapAtoB implementation</summary>

\`\`\`solidity
function swapAtoB(externalEuint64 encAmountA, bytes calldata inputProof) external {
    _initUser(msg.sender);

    euint64 amountA = FHE.fromExternal(encAmountA, inputProof);
    euint64 outputB = FHE.mul(amountA, FHE.asEuint64(RATE));

    ebool hasFunds = FHE.ge(_balanceA[msg.sender], amountA);

    _balanceA[msg.sender] = FHE.select(hasFunds,
        FHE.sub(_balanceA[msg.sender], amountA),
        _balanceA[msg.sender]);

    _balanceB[msg.sender] = FHE.select(hasFunds,
        FHE.add(_balanceB[msg.sender], outputB),
        _balanceB[msg.sender]);

    FHE.allowThis(_balanceA[msg.sender]);
    FHE.allow(_balanceA[msg.sender], msg.sender);
    FHE.allowThis(_balanceB[msg.sender]);
    FHE.allow(_balanceB[msg.sender], msg.sender);

    emit Swapped(msg.sender, true);
}
\`\`\`
</details>

<details>
<summary>Hint 3: swapBtoA implementation</summary>

\`\`\`solidity
function swapBtoA(externalEuint64 encAmountB, bytes calldata inputProof) external {
    _initUser(msg.sender);

    euint64 amountB = FHE.fromExternal(encAmountB, inputProof);
    euint64 outputA = FHE.div(amountB, RATE);

    ebool hasFunds = FHE.ge(_balanceB[msg.sender], amountB);

    _balanceB[msg.sender] = FHE.select(hasFunds,
        FHE.sub(_balanceB[msg.sender], amountB),
        _balanceB[msg.sender]);

    _balanceA[msg.sender] = FHE.select(hasFunds,
        FHE.add(_balanceA[msg.sender], outputA),
        _balanceA[msg.sender]);

    FHE.allowThis(_balanceA[msg.sender]);
    FHE.allow(_balanceA[msg.sender], msg.sender);
    FHE.allowThis(_balanceB[msg.sender]);
    FHE.allow(_balanceB[msg.sender], msg.sender);

    emit Swapped(msg.sender, false);
}
\`\`\`
</details>

---

## Bonus Challenges

1. **Variable exchange rate:** Add an \`updateRate()\` function (owner only) that changes the exchange rate. All future swaps use the new rate.

2. **Swap fee:** Deduct a 1% fee from each swap. The fee stays in the contract and the owner can withdraw it. Use \`FHE.div(amount, 100)\` for the fee calculation.

3. **Swap limit:** Add a maximum swap amount per transaction. Use \`FHE.min(requestedAmount, maxAmount)\` to cap it.

4. **Two-party swap:** Instead of a pool, implement a direct peer-to-peer swap where Alice and Bob each deposit encrypted amounts, and the contract executes the exchange only if both sides are satisfied (both have sufficient balances).

---

## Success Criteria

- [ ] Contract compiles without errors
- [ ] \`depositTokenA()\` and \`depositTokenB()\` accept encrypted deposits via \`FHE.fromExternal()\`
- [ ] \`swapAtoB()\` correctly computes output using \`FHE.mul(amountA, FHE.asEuint64(RATE))\`
- [ ] \`swapBtoA()\` correctly computes output using \`FHE.div(amountB, RATE)\`
- [ ] Insufficient balance is handled with \`FHE.select()\` (no revert)
- [ ] Both balances are updated atomically in each swap
- [ ] ACL is correctly set with \`FHE.allowThis()\` and \`FHE.allow()\` after every FHE operation
- [ ] View functions return encrypted handles for the caller's balances
- [ ] All tests pass
`,
  "19-capstone": `# Module 19: Exercise -- Build a Confidential DAO

## Objective

Build a complete Confidential DAO system consisting of a governance token and a DAO contract with weighted encrypted voting, treasury management, and proposal execution.

---

## Overview

You will build two contracts:
1. **GovernanceToken** -- A confidential ERC-20 with cross-contract ACL support
2. **ConfidentialDAO** -- The main DAO contract with proposals, voting, and treasury

---

## Task 1: GovernanceToken

Extend the ConfidentialERC20 from Module 11 with DAO access support.

### Starter Code

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract GovernanceToken is ZamaEthereumConfig {
    string public name;
    string public symbol;
    uint8 public constant decimals = 6;
    uint64 public totalSupply;

    mapping(address => euint64) private _balances;
    mapping(address => bool) private _initialized;

    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
        owner = msg.sender;
    }

    function _initBalance(address account) internal {
        if (!_initialized[account]) {
            _balances[account] = FHE.asEuint64(0);
            FHE.allowThis(_balances[account]);
            FHE.allow(_balances[account], account);
            _initialized[account] = true;
        }
    }

    function mint(address to, uint64 amount) public onlyOwner {
        _initBalance(to);
        _balances[to] = FHE.add(_balances[to], FHE.asEuint64(amount));
        FHE.allowThis(_balances[to]);
        FHE.allow(_balances[to], to);
        totalSupply += amount;
    }

    function balanceOf(address account) public view returns (euint64) {
        return _balances[account];
    }

    function grantDAOAccess(address dao) public {
        // TODO: Require that msg.sender has been initialized
        // TODO: FHE.allow(_balances[msg.sender], dao) to grant the DAO contract read access
    }

    function transfer(address to, externalEuint64 encryptedAmount, bytes calldata inputProof) external {
        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);
        _transfer(msg.sender, to, amount);
    }

    function _transfer(address from, address to, euint64 amount) internal {
        _initBalance(from);
        _initBalance(to);

        // TODO: No-revert pattern (from Module 11)
        // TODO: Check balance >= amount
        // TODO: FHE.select for transfer amount
        // TODO: Update both balances
        // TODO: ACL for both from and to
    }
}
\`\`\`

---

## Task 2: ConfidentialDAO

### Starter Code

\`\`\`solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, ebool, externalEbool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

interface IGovernanceToken {
    function balanceOf(address account) external view returns (euint64);
}

contract ConfidentialDAO is ZamaEthereumConfig {
    struct Proposal {
        string description;
        address recipient;
        uint256 amount;
        uint256 startTime;
        uint256 endTime;
        euint64 yesVotes;
        euint64 noVotes;
        bool exists;
        bool finalized;
        bool executed;
    }

    address public admin;
    IGovernanceToken public governanceToken;
    uint256 public proposalCount;
    uint256 public votingDuration;

    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => mapping(address => bool)) private _hasVoted;

    event ProposalCreated(uint256 indexed proposalId, string description, address recipient, uint256 amount);
    event VoteCast(uint256 indexed proposalId, address indexed voter);
    event ProposalFinalized(uint256 indexed proposalId);
    event ProposalExecuted(uint256 indexed proposalId, address recipient, uint256 amount);
    event TreasuryFunded(address indexed from, uint256 amount);

    modifier onlyAdmin() {
        require(msg.sender == admin, "Not admin");
        _;
    }

    constructor(address _governanceToken, uint256 _votingDuration) {
        admin = msg.sender;
        governanceToken = IGovernanceToken(_governanceToken);
        votingDuration = _votingDuration;
    }

    receive() external payable {
        emit TreasuryFunded(msg.sender, msg.value);
    }

    function createProposal(
        string calldata description,
        address recipient,
        uint256 amount
    ) public returns (uint256) {
        uint256 proposalId = proposalCount++;

        // TODO: Set all proposal fields
        // TODO: Initialize yesVotes and noVotes to encrypted 0
        // TODO: Set startTime = block.timestamp, endTime = block.timestamp + votingDuration
        // TODO: FHE.allowThis() for both tallies
        // TODO: Emit ProposalCreated event

        return proposalId;
    }

    function vote(uint256 proposalId, externalEbool encryptedVote, bytes calldata inputProof) external {
        Proposal storage p = proposals[proposalId];

        // TODO: Validate: exists, active period, not already voted
        // TODO: Mark as voted

        // TODO: Get voter's token balance from governanceToken.balanceOf(msg.sender)
        // TODO: Convert encryptedVote with FHE.fromExternal(encryptedVote, inputProof)

        // TODO: Weighted vote:
        //   yesWeight = FHE.select(voteYes, weight, zero)
        //   noWeight = FHE.select(voteYes, zero, weight)
        // TODO: Add weights to tallies
        // TODO: FHE.allowThis() for both tallies
        // TODO: Emit VoteCast event
    }

    function finalize(uint256 proposalId) public onlyAdmin {
        Proposal storage p = proposals[proposalId];

        // TODO: Validate: exists, voting ended, not finalized
        // TODO: Set finalized = true
        // TODO: Mark both tallies as publicly decryptable using FHE.makePubliclyDecryptable()
        // TODO: Emit ProposalFinalized event
    }

    function executeProposal(
        uint256 proposalId,
        uint64 decryptedYes,
        uint64 decryptedNo
    ) public onlyAdmin {
        Proposal storage p = proposals[proposalId];

        // TODO: Require finalized and not executed
        // TODO: Require decryptedYes > decryptedNo (proposal approved)
        // TODO: Require treasury has enough ETH
        // TODO: Set executed = true
        // TODO: Transfer ETH to recipient
        // TODO: Emit ProposalExecuted event
    }

    function getProposalResults(uint256 proposalId) public view returns (euint64, euint64) {
        Proposal storage p = proposals[proposalId];
        require(p.finalized, "Not finalized");
        return (p.yesVotes, p.noVotes);
    }

    function hasVoted(uint256 proposalId, address voter) public view returns (bool) {
        return _hasVoted[proposalId][voter];
    }

    function treasuryBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
\`\`\`

---

## Step-by-Step Instructions

### Step 1: GovernanceToken

1. Implement \`grantDAOAccess()\` -- one line: \`FHE.allow(_balances[msg.sender], dao)\`
2. Implement \`_transfer()\` using the no-revert pattern from Module 11

### Step 2: ConfidentialDAO - createProposal

1. Set all proposal struct fields
2. Initialize encrypted tallies to 0
3. Set timing (start = now, end = now + duration)

### Step 3: ConfidentialDAO - vote

This is the most complex function:
1. Validate state (exists, active, not voted)
2. Read voter's token balance from the governance token
3. Convert the encrypted vote
4. Use \`FHE.select()\` to compute weighted yes/no
5. Add to tallies

### Step 4: ConfidentialDAO - finalize

1. Validate timing
2. Make tallies publicly decryptable

### Step 5: ConfidentialDAO - executeProposal

1. Check approval (yes > no)
2. Transfer ETH

---

## Hints

<details>
<summary>Hint 1: grantDAOAccess</summary>

\`\`\`solidity
function grantDAOAccess(address dao) public {
    require(_initialized[msg.sender], "No balance");
    FHE.allow(_balances[msg.sender], dao);
}
\`\`\`
</details>

<details>
<summary>Hint 2: vote function</summary>

\`\`\`solidity
function vote(uint256 proposalId, externalEbool encryptedVote, bytes calldata inputProof) external {
    Proposal storage p = proposals[proposalId];
    require(p.exists, "No proposal");
    require(block.timestamp >= p.startTime, "Not started");
    require(block.timestamp < p.endTime, "Ended");
    require(!_hasVoted[proposalId][msg.sender], "Already voted");

    _hasVoted[proposalId][msg.sender] = true;

    euint64 weight = governanceToken.balanceOf(msg.sender);
    ebool voteYes = FHE.fromExternal(encryptedVote, inputProof);
    euint64 zero = FHE.asEuint64(0);

    euint64 yesWeight = FHE.select(voteYes, weight, zero);
    euint64 noWeight = FHE.select(voteYes, zero, weight);

    p.yesVotes = FHE.add(p.yesVotes, yesWeight);
    p.noVotes = FHE.add(p.noVotes, noWeight);

    FHE.allowThis(p.yesVotes);
    FHE.allowThis(p.noVotes);

    emit VoteCast(proposalId, msg.sender);
}
\`\`\`
</details>

<details>
<summary>Hint 3: executeProposal</summary>

\`\`\`solidity
function executeProposal(
    uint256 proposalId,
    uint64 decryptedYes,
    uint64 decryptedNo
) public onlyAdmin {
    Proposal storage p = proposals[proposalId];
    require(p.finalized, "Not finalized");
    require(!p.executed, "Already executed");
    require(decryptedYes > decryptedNo, "Not approved");
    require(address(this).balance >= p.amount, "Insufficient treasury");

    p.executed = true;
    payable(p.recipient).transfer(p.amount);

    emit ProposalExecuted(proposalId, p.recipient, p.amount);
}
\`\`\`
</details>

---

## Bonus Challenges

1. **Quorum requirement:** Add a minimum total vote weight required for a proposal to be valid. After decryption, check that \`yesVotes + noVotes >= quorum\`.

2. **Proposal threshold:** Require that a proposer holds a minimum number of governance tokens to create a proposal.

3. **Timelock execution:** Add a delay between finalization and execution, allowing the community to react.

4. **Multiple proposals:** Allow multiple proposals to be active simultaneously with independent voting.

5. **Frontend:** Build a full React frontend with:
   - Wallet connection
   - Token balance display (decrypted)
   - Proposal creation form
   - Voting interface
   - Results display after finalization

---

## Success Criteria

- [ ] GovernanceToken compiles and supports minting, transfers, and DAO access grants
- [ ] ConfidentialDAO compiles and accepts proposals
- [ ] Weighted voting works using \`FHE.select()\` with token balances
- [ ] Duplicate voting is prevented
- [ ] Time-bounded voting works correctly
- [ ] Finalization makes tallies publicly decryptable
- [ ] Execution transfers ETH only for approved proposals
- [ ] All encrypted values have proper ACL calls
- [ ] Events are emitted at each lifecycle stage
- [ ] Treasury funding and balance checking work correctly
`,
};
